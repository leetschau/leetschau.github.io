
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="netstat -ano 通过命令结果中的PID号对应到Windows进程上。 参考：“利用Windows内置功能轻松查看端口使用情况”（ http://li-donghui123-163-com.iteye.com/blog/248028 ）
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/77">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A note repository aims at Data Mining, Spark, Linux, Python.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:leetschau.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/11/180420/">Check Port Usage in Windows</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-11T18:04:20+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>6:04 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>netstat -ano</p>

<p>通过命令结果中的PID号对应到Windows进程上。</p>

<p>参考：“利用Windows内置功能轻松查看端口使用情况”（ <a href="http://li-donghui123-163-com.iteye.com/blog/248028">http://li-donghui123-163-com.iteye.com/blog/248028</a> ）</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/11/105956/">网元断开连接的日志分析方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-11T10:59:56+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>10:59 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一次连接唯一的标识符是ip+port。当
 首先，GAPI的日志中要有session，例如：
  logger.info(session + &ldquo; has login GODU&rdquo;);</p>

<p> 对应的日志输出为：</p>

<p> 2011-07-31 15:55:02,859 [pool-5-thread-1248] [com.boco.godu.gapi.mina.filter.data.GoduDataLoginFilter,30] [INFO] - [pool-1-thread-11332] (0x00001CD7: nio socket, client, / 10.131.62.61:38359 => / 10.131.62.46:1234 ) has login GODU</p>

<p> 其中黑体字部分分别是GAPI端和GODU accepter端的ip地址和端口号，红字部分是确定 本次连接终端侧的唯一标识符，后面的“10.131.62.46:1234”是GODU服务器的IP地址和端口。</p>

<p> 其次，在GODU日志中查找红字部分，在openne部分可以找到终端侧与</p>

<p> [INFO] [2011-08-11 01:42:40,708] [com.boco.godu.app.server.TelnetServerHandler] - [[30080:/ 10.131.62.61:14409 ] Begin to Connection NE, 10.134.16.100:6000 &hellip;&hellip;&hellip;&hellip;..]</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/11/104245/">日志文件的筛选</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-11T10:42:45+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>10:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>处理日志文件的一个常用操作是筛选出有某一特殊标志的行，日志文件一般比较大，用Ultraedit之类的软件处理会很慢，一般的方法是用Unix的grep命令重定向到一个文件中，例如要筛选出godu.log中所有有“25:/10.0.2.47:54431”的行，在godu.log所在目录下输入指令：
  grep &lsquo;25:/10.0.2.47:54431&rsquo; godu.log >new.log</p>

<p> 会把godu.log中所有包含“25:/10.0.2.47:54431”的行放入 当前目录下新生成new.log文件中。如果输入的指令是\</p>

<p>  grep &lsquo;25:/10.0.2.47:54431&rsquo; >new.log</p>

<p> 则是对当前目录下所有文件操作，将所有包含 “25:/10.0.2.47:54431”的行找出来放在new.log文件中。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/11/103433/">Log4j使用笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-11T10:34:33+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>10:34 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Java程序最常用的日志系统大概就是apache的log4j了，它的功能简单说就是“记录日志”。 它主要由logger、appender和layout这3个对象构成，logger是一个具体的“记录器”，appender是记录器的“输出对象”，它可以是屏幕输出、文件、界面组件、socket等。layout是appender的属性，决定appender所代表的输出中，一条具体的记录由哪些信息组成，排列顺序等。</p>

<p>每一个logger都有一个名字，名字是logger初始化时由getLogger的参数决定的，例如下面的logger的名字是com.foo：</p>

<pre><code>Logger logger = Logger.getLogger("com.foo"); 
</code></pre>

<p>名字是logger的唯一标识符，例如下面的x和y两个logger实际上是同一个对象：</p>

<pre><code>Logger x = Logger.getLogger("wombat"); 
Logger y = Logger.getLogger("wombat"); 
</code></pre>

<p>名字还具有继承性，例如名为com.foo.bar的logger是com.foo这个logger的子logger，com.foo又是com的子logger，子logger会继承所有上级logger的appender。这种继承类似于java包的父目录和子目录的关系，详见[1]的&#8221;Named Hierarchy&#8221;部分。</p>

<p>类似于根目录的概念，rootLogger是logger hierarchy的顶端，简单的log4j应用中，只定义rootLogger的appender，所有类中的logger就继承了rootLogger的特性。</p>

<p>为一个logger指定appender是在log4j配置文件中定义的，格式是：</p>

<pre><code>log4j.rootLogger=level_name, appender_name1, appender_name2, ... 
</code></pre>

<p>或： log4j.logger.logger_name=level_name, appender_name1, appender_name2, &hellip;</p>

<p>前者为rootLogger指定appender，后者为某一个具体的logger指定appender。定义appender属性的方法是：</p>

<pre><code>log4j.appender.appender_name=... 
log4j.appender.appender_name.layout=... 
</code></pre>

<p>例如下面的代码为rootLogger指定了appender A1，并设置A1为界面输出，然后指定了输出的格式，最后一行指定了com.foo的输出级别为WARN，com.foo及其子logger低于WARN的日志将不记录，由于com.foo没有指定appender，所以继承rootLogger的A1作为其输出：</p>

<pre><code>log4j.rootLogger=DEBUG, A1 
log4j.appender.A1=org.apache.log4j.ConsoleAppender 
log4j.appender.A1.layout=org.apache.log4j.PatternLayout 
log4j.appender.A1.layout.ConversionPattern=%d [%t] %-5p %c - %m%n 
log4j.logger.com.foo=WARN 
</code></pre>

<p>logger的级别常用的有debug, info, warn, error四种，详见“ log4j日志的输出级别设置 ”；appender常用的有 ConsoleAppender（控制台输出）、 DailyRollingFileAppender（按照一定的频率滚动输出日志，例如每月、每周、每天、每小时等）和 RollingFileAppender（到一定文件大小时滚动输出） 三种；layout常用的有SimpleLayout, PatternLayout, HTMLLayout, XMLLayout四种，后两种用来输出html和xml文本。不论哪种layout，都输出的是纯文本，因此各种appender与各种layout可以随意组合。</p>

<p>如果对项目中一些类的日志进行特殊处理（例如更改输出级别、指定新的输出文件等），见笔记“ 在包一级定制log4j日志输出 ”。</p>

<p>下面是一个完整的日志演示，首先是测试用例，只打一条日志：</p>

<pre><code>package com.boco.godu.gapi.logger; 
import org.apache.log4j.Logger; 
import org.junit.Test; 
public class Log4jDemo { 
    private final Logger logger = Logger.getLogger(this.getClass()); 
    @Test 
    public void testGapiLogger() { 
        logger.info(" Apache Logger "); 
    } 
} 
</code></pre>

<p>log4j.properties文件：</p>

<p> log4j.rootLogger=debug, console, ft, fh, fx
 log4j.appender.console=org.apache.log4j.ConsoleAppender
 log4j.appender.console.layout=org.apache.log4j.SimpleLayout
 log4j.appender.ft=org.apache.log4j.RollingFileAppender
 log4j.appender.ft.File=./log/debug.log
 log4j.appender.ft.Append=false
 log4j.appender.ft.MaxFileSize=2MB
 log4j.appender.ft.MaxBackupIndex=10
 log4j.appender.ft.layout=org.apache.log4j.PatternLayout
 log4j.appender.ft.layout.ConversionPattern=%d{MM-dd HH:mm:ss,SSS} %t %c,%L %p - %m%n
 log4j.appender.fh=org.apache.log4j.RollingFileAppender
 log4j.appender.fh.File=./log/debug.html
 log4j.appender.fh.Append=false
 log4j.appender.fh.MaxFileSize=2MB
 log4j.appender.fh.MaxBackupIndex=10
 log4j.appender.fh.layout=org.apache.log4j.HTMLLayout
 log4j.appender.fh.layout.LocationInfo=true
 log4j.appender.fh.layout.Title=Test Log4j Layout
 log4j.appender.fx=org.apache.log4j.RollingFileAppender
 log4j.appender.fx.File=./log/debug.xml
 log4j.appender.fx.Append=false
 log4j.appender.fx.MaxFileSize=2MB
 log4j.appender.fx.MaxBackupIndex=10
 log4j.appender.fx.layout=org.apache.log4j.xml.XMLLayout
 log4j.appender.fx.layout.LocationInfo=true</p>

<p>rootLogger一共挂了4个appender，分别是一个控制台输出，一个纯文本格式日志，一个html格式日志，一个xml格式日志。</p>

<p>运行测试用例后的效果如下（黑体字和红圈是源代码打出的日志）：</p>

<p>控制台输出：</p>

<pre><code>INFO - Apache Logger 
</code></pre>

<p>纯文本文件：</p>

<p>08-11 16:04:03,343 main com.boco.godu.gapi.logger.Log4jDemo,11 INFO - Apache Logger</p>

<p>html文件：</p>

<p>xml文件：</p>

<pre><code>&lt;log4j:event logger="com.boco.godu.gapi.logger.Log4jDemo" timestamp="1313049843343" level="INFO" thread="main"&gt; 
    &lt;log4j:message&gt;&lt;![CDATA[ Apache Logger ]]&gt;&lt;/log4j:message&gt; 
    &lt;log4j:locationInfo class="com.boco.godu.gapi.logger.Log4jDemo" method="testGapiLogger" file="Log4jDemo.java" line="11"/&gt; 
&lt;/log4j:event&gt;
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/10/201926/">Mantis安装过程笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-10T20:19:26+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>8:19 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>安装平台：Windows Server 2003 R2 Enterprise x64 Edition</p>

<p>软件：</p>

<p>EasyPHP-5.3.6.1</p>

<p> mantisbt-1.2.6</p>

<p>安装过程：</p>

<p>首先安装EasyPHP，一路next即可，安装到默认位置即可，路径中可以有空格；</p>

<p>将 mantisbt-1.2.6解压到 EasyPHP的www目录下，具体过程可参考 EasyPHP 3 + Mantis 1.2 快速搭建安装免费开源的中文缺陷管理平台 ；</p>

<p>配置：</p>

<p>C:\Program Files (x86)\EasyPHP-5.3.6.1\conf_files中将“Listen 127.0.0.1:80”和“ServerName 127.0.0.1:80”改为本机的IP地址，否则只能在本机登录mantis，局域网的其他机器不能访问。这部分的配置可参考 一步到位安装 Mantis Bug 跟踪系统 ，但其中有些东西已经过时了，例如对EasyPHP版本的限制、路径不能有空格等。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/02/114314/">Convert Java Codes to UML Diagram</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-02T11:43:14+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2011</span></span> <span class='time'>11:43 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Power Designer -> File -> Reverse Engineer -> Object Language
 Object Language: Java</p>

<p> Reverse engineer: Java directories</p>

<p> Add &hellip;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/01/111930/">Ivy配置文件编写规范</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-01T11:19:30+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2011</span></span> <span class='time'>11:19 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><ol>
<li>各依赖条目按严格按字母顺序排列；</li>
<li><p>对于平行开发的多个项目产品之间的依赖关系，要将changing参数设为true，否则可能造成缓存更新不及时导致编译错误；</p></li>
<li><p>如果要避免依赖传递，使用 conf=&ldquo;compile->master&#8221;，如果要显式的打开依赖传递，则使用transitive=&#8221;true&#8221;；</p></li>
</ol>


<p> 例如：</p>

<p> <dependency org="com.boco.ty" name="gapi" rev="alpha" conf="compile->master&#8221; changing=&ldquo;true&rdquo;/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/26/091657/">GAPI的同步返回实现方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-26T09:16:57+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>9:16 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>GAPI 所基于 MINA 是一个异步网络通信框架，因此要实现 API 调用的同步方式返回，需要采用锁机制，即在主线程启动 filter 后进入“睡眠”状态， 当filter 处理任务完毕后唤醒主线程继续运行。具体实现的方法如下（以 execScript() 方法为例）。</p>

<p>测试用例：</p>

<p> public class SimpleExpScriptTest {</p>

<p>   private IConnection conn;</p>

<p>  @Test</p>

<p>  public void testPWD() throws Exception {</p>

<p>   conn = ConnFactory.getInstance().getConnection(Constants.PORT_CONNECT_GODU_DATA);</p>

<p>   conn.setSyncType(Constants.TYPE_DATA_CMD_SYNC);</p>

<p>   if (conn.getConnection(&ldquo;<aa><7001><administrator><autocmd>&rdquo;, &ldquo;goduapp&rdquo;, &ldquo;10.0.2.47&rdquo;, 1234, 100)) {</p>

<pre><code>System.out.println("Connect GODU OK!"); 
</code></pre>

<p>   }</p>

<p>   conn.sendGoduCmd(&ldquo;settelnetcodec switch=y&rdquo;);</p>

<p>   conn.set_script_timeout(500);</p>

<p>   Map&lt;String, Object> params = new HashMap&lt;String, Object>();</p>

<p>   params.put(&ldquo;user_name&rdquo;, &ldquo;test&rdquo;);</p>

<p>   params.put(&ldquo;old_pwd&rdquo;, &ldquo;godu123&rdquo;);</p>

<p>   params.put(&ldquo;new_pwd&rdquo;, &ldquo;testgodu&rdquo;);</p>

<p>   IResult result = conn. execScript (&ldquo;-1200187081&rdquo;, &ldquo;script/PWD&rdquo;, &ldquo;&rdquo;, params);</p>

<p>   System.out.println(&ldquo;***result is:\n&rdquo; + result.getString());</p>

<p>  }</p>

<p> }</p>

<p> execScript 方法：</p>

<p> package com.boco.godu.gapi.conn;</p>

<p> import &hellip;</p>

<p> public class GoduDataConnection extends AbstractConnection {</p>

<p>  private static final GapiLogger logger = LogUtils.getLogger(this.getClass().getName());</p>

<p>  private final Object lock = new Object(); //对象锁</p>

<p>  public IResult execScript(String ne_id, String scriptPath, String name, Map&lt;String, Object> params) throws &hellip; {</p>

<p>   // check if connected GODU successfully</p>

<p>   &hellip;</p>

<p>   // parse script file</p>

<p>   GoduScript gs = new GoduScript(scriptPath, script_buffer_size, params);</p>

<p>   // add execute_script filter</p>

<p>   session.getFilterChain().addBefore(&hellip;);</p>

<p>   // open NE</p>

<p>   &hellip;</p>

<p>   // 在执行完脚本或者超时之前阻止代码继续运行，在ExecScriptFilter.messageReceived方法中解锁</p>

<p>   GapiIosessionUtils. lockSession (session, lock , script_timeout );</p>

<p>   GoduReturnResult res = new GoduReturnResult();</p>

<p>   String script_result = (String) session.getAttribute(</p>

<pre><code>      ExecScriptFilter.EXEC_SCRIPT_RESULT, ""); 
</code></pre>

<p>   res.setArrays(script_result.getBytes());</p>

<p>   int return_status = (Integer) session.getAttribute(</p>

<pre><code>      ExecScriptFilter.EXEC_SCRIPT_RETURN_STATUS, 0); 
</code></pre>

<p>   res.setReturnStatus(return_status);</p>

<p>   return res;</p>

<p>  }</p>

<p> }</p>

<p> 这样代码运行到lockSession时暂停，直到超时时间到，或者被其他线程上持有同一个锁的“唤醒”方法唤醒，这实现了同步方式的前一半：下面是同步方式的后一半：filter执行脚本完毕后唤醒主线程继续运行：</p>

<p> package com.boco.godu.gapi.mina.filter.data;</p>

<p> import &hellip;</p>

<p> public class ExecScriptFilter extends AGapiFilter {</p>

<p>  @Override</p>

<p>  public void messageReceived(NextFilter nextFilter, IoSession session,</p>

<pre><code>     Object message) throws Exception { 
</code></pre>

<p>   &hellip;</p>

<p>   if (&hellip;) { // 如果脚本执行完毕：</p>

<pre><code>... 

GapiIosessionUtils. unlockSession (session); 

return; 
</code></pre>

<p>   }</p>

<p>   &hellip;</p>

<p>  }</p>

<p> }</p>

<p>那么 lockSession 和 unlockSession 方法又是如何实现的呢，继续往下看：</p>

<p> public class GapiIosessionUtils {</p>

<p>  public static void lockSession(final IoSession session, final Object lock , final int timeout ) throws &hellip; {</p>

<p>   try {</p>

<pre><code>if (session.isConnected() &amp;&amp; !session.isClosing()) { 

 long beforeLockTime = System.currentTimeMillis(); 

 session.setAttribute(GoduFilterConstants. GODU_DATA_LOCK , lock ); 

 session.getConfig().setBothIdleTime(timeout); 

 ThreadUtil. waitIt ( lock , timeout * 1000 + 1000); 

 long afterLockTime = System.currentTimeMillis(); 

 logger.debug("lockTime=" + (afterLockTime - beforeLockTime) + "ms"); 

} 
</code></pre>

<p>   } catch (Exception e) {</p>

<pre><code>e.printStackTrace(); 

logger.error("lockSession exception: ", e); 

throw new GapiException(e); 
</code></pre>

<p>   }</p>

<p>  }</p>

<p>  public static void unlockSession(final IoSession session) throws &hellip; {</p>

<p>   try {</p>

<pre><code>if (session.isConnected() &amp;&amp; !session.isClosing()) { 

 Object status = session.getAttribute(GoduFilterConstants. GODU_DATA_LOCK ); 

 ThreadUtil.notifyIt(status); 

} 
</code></pre>

<p>   } catch (Exception e) {</p>

<pre><code>... 
</code></pre>

<p>   }</p>

<p>  }</p>

<p> }</p>

<p> 可以看到加锁的时候将锁（lock对象）放在了session的一个attribute上，解锁的时候从这个attribute上取出这个锁，然后解锁。这里用到的 冻结线程的 waitIt 方法以及唤醒线程的 notifyIt 方法实现如下：</p>

<p> package com.boco.godu.common.util;</p>

<p> public class ThreadUtil {</p>

<p>  public static void  waitIt  (final Object o, final long time) {</p>

<p>   synchronized (o) {</p>

<pre><code>try { 

 if (time == -1) { 

  o.wait(); 

 } else { 

  o.wait(time); 

 } 

} catch (InterruptedException iex) { 

 iex.printStackTrace(); 

} 
</code></pre>

<p>   }</p>

<p>  }</p>

<p>   public static void  notifyIt (final Object o) {</p>

<p>   synchronized (o) {</p>

<pre><code> o.notifyAll(); 
</code></pre>

<p>   }</p>

<p>  }</p>

<p> }</p>

<p> 当代码到 o.wait(time); 时进入阻塞状态（停止运行，实际上是java.lang.Object.wait()方法），直到下列情况之一出现：</p>

<ol>
<li><p>超时时间time到；</p></li>
<li><p>被唤醒，也就是调用同一个对象的notifyAll方法（即java.lang.Object.notifyAll()方法）。</p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/23/103345/">Groovy正则表达式复杂逻辑判断实例</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-23T10:33:45+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2011</span></span> <span class='time'>10:33 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>下面的两个pattern（p1和p2）分别代表了(A or B) and (C or D)和(A and B) or (C and D)的跨行匹配结果，当然还可以用正则表达式构建更复杂的pattern，但这个实例证明了Groovy具备跨行匹配复杂逻辑表达式的能力。</p>

<p> 值得注意的是，多行匹配文本时需要在匹配字符串前加“(?ms)”。</p>

<p> 该实例同时演示了Groovy闭包的使用方法。
 源代码</p>

<p> msg1 = &lsquo;&rsquo;&lsquo;one two three four</p>

<p> five six&#8217;&lsquo;&rsquo;</p>

<p> msg2 = &lsquo;&rsquo;&lsquo;Jan Feb Mar</p>

<p> Apr May Jun&#8217;&lsquo;&rsquo;</p>

<p> msg3 = &lsquo;&rsquo;&lsquo;one two three</p>

<p> Apr May Jun&#8217;&lsquo;&rsquo;</p>

<p> msg4 = &lsquo;&rsquo;&lsquo;Jan Feb Mar</p>

<p> four five six&#8217;&lsquo;&rsquo;</p>

<p> p1 = / (?ms) (two|Feb).*(five|May)/</p>

<p> p2 = / (?ms) (two.<em>five)|(Feb.</em>May)/</p>

<p> msgs = [msg1, msg2, msg3, msg4]</p>

<p> patterns = [p1, p2]</p>

<p> patterns.each { pattern-></p>

<p> println &lsquo;pattern is: &rsquo;+pattern</p>

<p> msgs.each { msg-></p>

<p> println &lsquo;msg is: &rsquo;+msg</p>

<p> println &lsquo;match result is:&rsquo;</p>

<p> matcher = msg =~ pattern</p>

<p> if (matcher)</p>

<p> println &ldquo;true&rdquo;</p>

<p> else</p>

<p> println &ldquo;false&rdquo;</p>

<p> println &lsquo;&mdash;&rsquo;</p>

<p> }</p>

<p> println &lsquo;===&rsquo;</p>

<p> }
 运行结果
 pattern is: (?ms)(two|Feb).*(five|May)</p>

<p> msg is: one two three four</p>

<p> five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: one two three</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> four five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<hr />

<p> pattern is: (?ms)(two.<em>five)|(Feb.</em>May)</p>

<p> msg is: one two three four</p>

<p> five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: one two three</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> false</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> four five six</p>

<p> match result is:</p>

<p> false</p>

<hr />

<hr />
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/21/154602/">基于Tcc的C语言编译器</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-21T15:46:02+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2011</span></span> <span class='time'>3:46 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://bellard.org/tcc">TCC: Tiny C Compiler</a>是一款Windows平台上的迷你型C编译器，适合于学习算法时编译、演示一些简单的C语言程序，下面分别是基于vim和Notepad++的两种开发环境搭建方法。</p>

<h1>安装TCC</h1>

<p>TCC是绿色软件，下载软件包（tcc-0.9.25-win32-bin.zip）后解压即可运行，假设解压到&#8221;d:\apps\tcc&#8221;目录下。</p>

<h1>vim</h1>

<ol>
<li>将以下程序保存到hello.c文件中。</li>
</ol>


<p> #include &lt;stdio.h>
 main()
 {
  printf(&ldquo;hello, world!!!\n&rdquo;);
 }</p>

<ol>
<li>运行&#8221;:!d:\Apps\tcc\tcc.exe -run %&#8221;</li>
</ol>


<h1>Notepad++</h1>

<p>需要的软件：<a href="http://notepad-plus-plus.org/">Notepad++</a> v5.8.3 绿色版和它的NppExec插件；</p>

<h2>编译器</h2>

<p>下载tcc的windows压缩包后解压到一个目录下，例如”f:\Software\tcc“；</p>

<h2>语法高亮</h2>

<p>Notepad++内置了对C语言的语法高亮，如果在“语言”菜单下没有&#8221;C&#8221;语言项，在【设置->首选项->语言】下从”禁用项“列表中把C放到”启用项“列表中即可。</p>

<h2>命令行输出</h2>

<p>安装NppExec：下载NppExec后解压到npp安装目录的plugins文件夹下，例如我的npp绿色版路径是f:\Software\Notepad++583，则解压后目录结构为f:\Software\Notepad++583\plugins\NppExec.dll和f:\Software\Notepad++583\plugins\NppExec（下面是几个.h文件），压缩包doc目录下文件放在f:\Software\Notepad++583\plugins\doc下。启动Npp后可看到【插件->NppExec】菜单，【插件->NppExec->Show Console Dialog】打开命令输出窗口，可用【插件->NppExec->Change Console Font】修改输出窗口的字体和字号；</p>

<h2>定义运行脚本</h2>

<p> 【插件->NppExec->Execute】打开Execute窗口，输入</p>

<p> NPP_SAVE
 &ldquo;f:\Software\tcc\tcc.exe&rdquo; &ldquo;$(FULL_CURRENT_PATH)&rdquo; -run</p>

<p> 点Save保存此脚本为”Run C“；第一行脚本表示保存文件，第二行脚本使用了tcc.exe的-run参数，将编译、连接、运行一次性搞定；</p>

<h2>定义菜单项</h2>

<p> 【插件->NppExec->Advanced Options】中选择&#8221;Run C&#8221;，然后勾选&#8221;Place to the Macro submenu&#8221;；</p>

<p> 绑定快捷键</p>

<p> 【设置->管理快捷键】的&#8221;Macros&#8221;或者&#8221;Plugins commands&#8221;下面找到&#8221;Run C&#8221;，为其设置一个快捷键；</p>

<h2>编译运行</h2>

<p>Npp中打开前述hello.c文件，【宏->Run C】或者使用前面设置的快捷键启动Run C脚本，在Console窗口中可以看到程序的输出。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/78">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/76">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/10/02/005047/">Clojure Web Development</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/01/210506/">Dmenu Notes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/27/113819/">A Simple Ring Server</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/24/073009/">Xen on CentOS 6</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/20/105816/">Lightweight Web Browser Dwb</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
