
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="剪贴板软件的功能要求包括：固定条目（favorite clips）、粘贴控制，强力粘贴（power paste）、条目排列（clips arrangements）、合并条目（merge clips）、条目组织（organize clips）、Clipboard Routing、快捷键定义、 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/104">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A note repository aims at Data Mining, Spark, Linux, Python.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:leetschau.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/16/135347/">剪贴板软件比较</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-16T13:53:47+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>1:53 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>剪贴板软件的功能要求包括：固定条目（favorite clips）、粘贴控制，强力粘贴（power paste）、条目排列（clips arrangements）、合并条目（merge clips）、条目组织（organize clips）、Clipboard Routing、快捷键定义、富文本控制（RichText）、条目数量设置等，
 固定条目 （favorite clips）
有一些东西经常用，又比较长，敲键盘太慢，希望有个软件能把这些东西记下来，需要用的时候能够很方便地调出来，比如GODU的登录用户名<aa><7001><administrator><autocmd>，也就是所谓的“固定条目”功能。</p>

<p>最先用的是Ditto，固定条目功能找不到，分组平时也用不到， 感觉不好用，用了一段时间后放弃了。</p>

<p>然后是CLCL，固定条目放在一个叫“Template”的地方，但奇怪的是选中条目后回车却不粘贴，不靠谱，放弃。</p>

<p>然后是 clipx ，要实现固定条目需要下一个叫stickies的插件，装好后在Configuration下 stickies中add，就可以实现固定条目功能了。将快捷键设置为Alt+P，然后字母键是固定条目，比CLCL少按一个键，且快捷键可自定义，数字是普通条目。</p>

<p> ClipCache设置固定条目（这里叫“favorite clips”）的方法是在clipcache主窗口里右键该条目，然后选“Add to favorite clips”为该条目设一个标签（label），然后为“Favorite Clips”设置快捷键（在Tools->Options->Hotkey->Show Favorites），以后需要使用该条目时，用设好的快捷键呼出favorite clips窗口，然后用label匹配想要的条目即可，支持简写，例如有个条目的标签是“gu”，只写“g”然后回车即可。</p>

<p> Ditto、Clipx和CLCL详细的功能对比参见善用佳软上的文章：“剪贴板增强软件综述:CLCL,ClipX,Ditto等”（ <a href="http://xbeta.info/clipx-clcl-ditto.htm">http://xbeta.info/clipx-clcl-ditto.htm</a> ），后面介绍了一个叫ArsClip的软件，功能很多，但我都用不上，不过它是开源的这一点很好。
 粘贴控制  Windows默认的粘贴快捷键是“Ctrl+v”，但有些程序有自己特殊的快捷键，例如SecureCRT是“SHIFT+INSERT”，“cmd.exe”是“Alt+space+e+p”应具备识别某一窗口然后定制特殊快捷键的能力。在Clipcache中是在 Tools->Options-> Pasting中定义。  强力粘贴（power paste）
 例如文件1里有20处文本需要放到文件2的20个地方，基本的方法是文件1里复制，切换到文件2，粘贴，在切回文件1，处理20条文本需要80次鼠标和键盘动作，借助power paste则只需要在文件1里连续复制20次，再切到文件2里连续粘贴20次即可，只需要41次动作。目前所有的开源/免费软件中仅Hamsin Clipboard（v 3.03）支持此功能，但此软件只能记录10条clip，它有单独的power paste模式，进入此模式后才能开始连续复制，之前的clip是不能连续粘贴的。clipcache对强力粘贴支持很好，可定义单独的快捷键，且有两种移动方向，结合它的条目排序功能（默认是按使用时间排序，还可以按名称、大小、加入时间等排序）和条目组织功能（将某组条目放入一个单独的文件夹中），能够极大简化大量条目的复制/粘贴劳动量。
 条目排列
 改变条目的排列顺序，例如按使用时间、名称、大小、加入时间等方式排列条目，只有软件具备强力粘贴、条目合并等功能时改变排列次序才有意义。
 合并条目
 将N个条目合并为一个条目，可以进行各种格式转换，例如每个条目一行、条目之间插入tab、删除条目起始/结尾空格、删除空行等等，目前只有clipcache具备此功能。
 条目组织
 可以将条目分类组织，例如放在不同的文件夹里，这项功能也是配合强力粘贴才有意义。
 Clipboard Routing
在网页/文件A里复制时，能够自动切到目标窗口粘贴，然后再切换回A里，目前仅clipcache支持此功能。
 快捷键定义
 似乎只有CLCL不支持快捷键定义，其他软件都支持，clipcache快捷键定义中不支持Win键。
 富文本控制
主要是是否能够粘贴富文本和图片，以及是否支持将富文本转换为普通文本（plain text），clipcache具备此功能，如果要clipcache直接将拷贝到的RichText粘贴为PlainText（而不需要专门“转换”），在clipcache主菜单【Tools->Options->Capture】中取消勾选【Capture HTML】。
 条目数量设置
 clipcache没有上限限制，支持3种限制策略：按条目数量限制、按数据库大小限制、按日期限制（如删除N天前的条目）。
 总结
整体而言开源/免费软件的功能远弱于商业软件，clipcache的条目组织能力目前只有Ditto可以相比，但Ditto其他方面远逊，</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/12/143709/">Log4j配置文件编码不同可能导致log4j日志运行异常</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-12T14:37:09+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>2:37 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>有时即使log4j的配置文件log4j.properties放在了正确的位置上，内容也没有错误，但运行程序时总报appender异常，无法生成日志文件。可能的原因是配置文件的编码与项目设定的编码不一致（例如项目设置的编码是GBK，配置文件的编码使用UTF-8），导致读配置文件失败。解决的办法是将配置文件转换为项目设置的编码格式，为保证转换成功，文件中（包括注释部分）最好不要使用中文。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/11/085442/">将队列转换为字符串</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-11T08:54:42+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:54 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>LinkedBlockingQueue<Byte> inputQ = new LinkedBlockingQueue<Byte>();</p>

<p> Byte[] destArr = inputQ.toArray( new Byte[0]);</p>

<p> byte [] resultArr = new  byte [destArr. length ];</p>

<p> for ( int i = 0; i &lt; resultArr. length ; i++) {</p>

<p>  resultArr[i] = destArr[i].byteValue();</p>

<p> }</p>

<p> strRes = new String(resultArr);</p>

<p> 转换过程是：队列==>Byte数组==>byte数组==>字符串。下面是应用了此一转换的完整的Result类实现。</p>

<p> /**</p>

<ul>
<li><p>通过字节队列创建一个新的返回结果实例</p></li>
<li></li>
<li><p>@param inputQ</p></li>
<li><p> 结果字节队列</p></li>
<li><p>@param cmdType</p></li>
<li><p> 命令返回类型</p></li>
</ul>


<p> */</p>

<p> public Result( final LinkedBlockingQueue<Byte> inputQ, final  int cmdType) {</p>

<p>  cmdReturnType = cmdType;</p>

<p>  Byte[] destArr = inputQ.toArray( new Byte[0]);</p>

<p>  byte [] resultArr = new  byte [destArr. length ];</p>

<p>  for ( int i = 0; i &lt; resultArr. length ; i ++) {</p>

<p>   resultArr[ i ] = destArr[ i ].byteValue();</p>

<p>  }</p>

<p>  strRes = new String(resultArr);</p>

<p> }</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/10/203539/">在队列中寻找字符串算法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-10T20:35:39+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:35 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在一个队列destQ中，从前向后搜索是否有字符串flag，下面是算法实现以及测试程序。回溯功能暂未实现。</p>

<p> private  int findFlag( final LinkedBlockingQueue<Byte> destQ,</p>

<p> final String flag) {</p>

<p> byte [] flagArr = flag.getBytes();</p>

<p> Byte[] destArr = destQ.toArray( new Byte[0]);</p>

<p> int matchCount = 0; // 已匹配的字节数</p>

<p> int flagPos = -1; // 标志末尾的编号</p>

<p> int i = 0;</p>

<p> int  backupIndex = 0; // 用于回溯的索引</p>

<p> while (i &lt;= destQ.size()) {</p>

<p> if (flag.length() &lt;= matchCount) {</p>

<p> flagPos = i;</p>

<p> break ;</p>

<p> } else {</p>

<p> if (destArr[i] == flagArr[matchCount]) {</p>

<p> matchCount++;</p>

<p> } else {</p>

<p> matchCount = 0;</p>

<p> // i = backupIndex;</p>

<p> }</p>

<p> }</p>

<p> i = i + 1;</p>

<p> if (matchCount == 1) {</p>

<p> backupIndex = i;</p>

<p> }</p>

<p> }</p>

<p> return flagPos;</p>

<p> }</p>

<p> @Test</p>

<p> public  void runFindFlag() {</p>

<p> LinkedBlockingQueue<Byte> analyzerBuffer = new LinkedBlockingQueue<Byte>();</p>

<p> for ( int i = 33; i &lt; 123; i++) {</p>

<p> analyzerBuffer.offer( new Byte(( byte ) i));</p>

<p> }</p>

<p> String endFlag = &ldquo;123&rdquo; ;</p>

<p> int endFlagPos = findFlag(analyzerBuffer, endFlag);</p>

<p> List<Byte> cmplXmlStr = new ArrayList<Byte>();</p>

<p> analyzerBuffer.drainTo(cmplXmlStr, endFlagPos);</p>

<p> System. out .println(cmplXmlStr);</p>

<p> }</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/10/190026/">为Eclipse配置绿色版JDK</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-10T19:00:26+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>7:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1、解压JDK，例如f:\warez\Develop\Java\jdk1.5.0_16；</p>

<p>2、修改环境变量，在Path中增加：f:\warez\Develop\Java\jdk1.5.0_16\bin；</p>

<p>3、解压Eclipse，例如f:\warez\IDEs\Eclipse0621目录下；启动Eclipse（f:\warez\IDEs\Eclipse0621\eclipse.exe），如果提示找不到jre，可以用 “f:\warez\IDEs\Eclipse0621\eclipse.exe -vm f:\warez\Develop\Java\jdk1.5.0_16\bin” 的方式启动；</p>

<p>4、在Eclipse的Window==>Preferences==>Java==>Installed JREs中添加：</p>

<p> F:\warez\Develop\Java\jdk1.5.0_16；</p>

<p>5、重启Eclipse，如果仍然提示找不到jre，在Installed JREs==>Execution Enviroments中选对应的JDK版本打勾；</p>

<p>6、重启Eclipse验证设置成功；</p>

<p>7、为eclipse.exe增加快捷键，例如在Hoekey里加一行：~@E = Run|&ldquo;f:\warez\IDEs\Eclipse0621\eclipse.exe&rdquo;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/10/162133/">LinkedBlockingQueue的drainTo方法示例代码</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-10T16:21:33+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>4:21 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>LinkedBlockingQueue<String> analyzerBuffer = new LinkedBlockingQueue<String>();</p>

<p> String abc = &ldquo;abc&rdquo; ;</p>

<p> analyzerBuffer.offer(abc);</p>

<p> List<String> tmp = new ArrayList<String>();</p>

<p> analyzerBuffer.drainTo(tmp);</p>

<p> System. out .println(tmp);</p>

<p> System. out .println(analyzerBuffer);</p>

<p> analyzerBuffer.offer(abc);</p>

<p> analyzerBuffer.offer(abc);</p>

<p> analyzerBuffer.drainTo(tmp);</p>

<p> System. out .println(tmp);</p>

<p> System. out .println(analyzerBuffer);</p>

<p> 输出：</p>

<p> [abc]</p>

<p> []</p>

<p> [abc, abc, abc]</p>

<p> []</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/10/140800/">Arraycopy将数组分为两部分时游标的设置方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-10T14:08:00+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>2:08 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>System.arraycopy是复制数组的一个常用工具，它在游标处如何分为两个是一个需要注意的问题，例如下面的示例代码：</p>

<p>  byte [] src = { 104, 101, 108, 108, 111 };</p>

<p> int endPos = 2;</p>

<p> byte [] dest = new  byte [endPos];</p>

<p> byte [] surplus = new  byte [src. length - endPos];</p>

<p> System. arraycopy (src, 0, dest, 0, dest. length );</p>

<p> System. arraycopy (src, endPos, surplus, 0, src. length - endPos);</p>

<p> 游标（变量endPos）位置为2时，dest数组是{104, 101}，surplus数组是{108, 108, 111}。</p>

<p> 也就是说，编号为游标的元素（从0开始编号）在原数组分割后变为后面数组的第一个元素。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/09/170059/">VIM的搜索模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-09T17:00:59+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>5:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>用VIM当文本分析器分析log4j打出的日志时，有一个问题很棘手，那就是经常要搜索
[DEBUG] [2010-08-09 15:44:49,421] [com.boco.godu.GAPI.impl.DataReader]
这样的字符串，直接在/后面粘贴上字符串肯定不行，因为里面有大量的[、]、-、点号、冒号这样的特殊字符，要想能查到，就得在它们之前加反斜杠\，每次查都这么一下，实在太麻烦，解决方法是：告诉VIM所有字符都是普通字符，不用做正则符号，告诉的方法就是设置magic属性，VIM默认是magic状态，可以用:set nomagic的方法切换到普通搜索模式，但这样一来以后再想用正则搜索还得再写:set magic，比较麻烦，最简单的方法是在/和要查找的字符串中间加上\V（注意是大写V，小写代表完全相反的意思），例如
 bad.magic dam
dbm dcm aa dkm
 用/d.m搜，d.m、dam、dbm等等都符合，改为/\Vd.m，就只有d.m符合了（\V前后都没有空格）。
 关于\V详见:h magic。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/05/112702/">VIM的文件编码问题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-05T11:27:02+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>11:27 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>转换文件编码</h1>

<p>:set fileencoding=gbk/utf-8</p>

<h1>关于vim的编码</h1>

<p>Vim 有四个跟字符编码方式有关的选项，encoding、fileencoding、fileencodings、termencoding (这些选项可能的取值请参考 Vim 在线帮助 :help encoding-names)，它们的意义如下:
1. encoding：Vim内部（软件自身）使用的字符编码方式，包括 Vim 的 buffer (缓冲区)、菜单文本、消息文本等。默认是根据你的locale选择。用户手册上建议只在 .vimrc 中改变它的值，事实上也只有在.vimrc 中改变它的值才有意义。为了理解这个参数的含义，可做如下实验：
启动一个VIM，用:set encoding查询当前该参数的值，例如为utf-8，然后执行:set encoding=latin1，然后随便写一个命令让VIM提示出错，你会发现提示信息全是乱码。
反过来，如果你的VIM在运行后提示信息、菜单等处是乱码，可以用:set encoding=&hellip;来尝试一下别的编码。你可以用另外一种编码来编辑和保存文件，如你的vim的encoding为utf-8，所编辑的文件采用cp936编码，VIM会自动将读入的文件转成utf-8(VIM的能读懂的方式），而当你写入文件时，又会自动转回成GBK（文件的保存编码)。
1. fileencoding：VIM中当前编辑的文件的字符编码方式，VIM保存文件时也会将文件保存为这种字符编码方式 (不管是否新文件都如此)，可用:set fileencoding查询当前文件的编码类型，用:set fileencoding=utf-8将当前文件转换为utf-8格式。
1. fileencodings：VIM读文件时尝试的编码方案的列表，启动时VIM按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将 fileencoding 设置为最终尝试成功的字符编码方式。因此最好将Unicode 编码方式放到这个列表的最前面，将拉丁语系编码方式 latin1 放到最后面。
1. termencoding：VIM所工作的终端 (或者 Windows 的 Console 窗口) 的字符编码方式。如果VIM所在的term与VIM编码相同，则无需设置。如其不然，你可以用VIM的termencoding选项将自动转换成term 的编码。这个选项对Windows 下的gVim 无效（gVim是GUI 模式的，不是Console模式），因此无需关心这个参数，一般置空就行了。
Windows下的gVim的vimrc文件关于文件编码部分应设为：
set encoding=utf-8
set fileencodings=utf-8,chinese,latin-1
set fileencoding=utf-8
其中编码方案的第二项chinese主要是为了保持与windows上的很多默认编码格式兼容（如记事本的ANSI格式）。chinese 是个别名，在Unix 里表示gb2312，在Windows里表示cp936，也就是GBK与微软的ANSI兼容。当VIM打开cp936格式的文件时，编辑完后不要用:set fileencoding=utf-8命令将其转换为utf-8格式再保存，因为VIM生成的utf-8格式文件不带BOM表，与windows仍不兼容。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/05/112601/">Vim的剪贴板操作</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-05T11:26:01+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>11:26 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Normal模式下，用双引号加剪贴板编号（可以是数字和字母）来引用这个剪贴板，后面加上复制/粘贴命令就用使用这个剪贴板了，例如：</p>

<p>&ldquo;1yw：将光标所在单词拷贝到1号剪贴板上；</p>

<p>&ldquo;cd$：将从光标到行尾的内容剪切到c号剪贴板上；</p>

<p>&ldquo;dp：将d号剪贴板上的内容粘贴到光标后；</p>

<p>用:reg可以查看vim剪贴板的列表。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/105">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/103">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/05/10/091733/">Git初体验</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/08/155132/">Run Mongo Scripts in Shell</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/07/151147/">Find Verified User in MongoDB</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/07/111310/">Calculate String Length Containing Chinese Characters</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/07/093644/">CoffeeScript Notes</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
