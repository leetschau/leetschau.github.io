
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="lscpu 运行lscpu命令，输出中，&#8221;CPU(s)&ldquo;是逻辑CPU数，&#8221;Socket(s)&#8221;是物理插槽数，&#8221;Core(s) per socket&#8221;是每颗CPU的核数，&#8221;Thread(s) per core&# &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/66">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A note repository aims at Data Mining, Spark, Linux, Python.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:leetschau.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/29/095503/">Linux系统CPU信息查询方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-29T09:55:03+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>9:55 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>lscpu</h1>

<p>运行<code>lscpu</code>命令，输出中，&#8221;CPU(s)&ldquo;是逻辑CPU数，&#8221;Socket(s)&#8221;是物理插槽数，&#8221;Core(s) per socket&#8221;是每颗CPU的核数，&#8221;Thread(s) per core&#8221;是每个核的线程数，一般是1或者2，后者叫做“超线程”。
逻辑CPU数是物理插槽数、核数和每核线程数3者的乘积。
平常所说的“CPU个数”，就是指逻辑CPU数，也就是&#8221;CPU(s)&#8221;的值。</p>

<h1>cat /proc/cpuinfo</h1>

<p>下面是一个实例：</p>

<pre><code>processor  : 0 
vendor_id  : GenuineIntel 
cpu family  : 6 
model   : 26 
model name  : Intel(R) Xeon(R) CPU   X5550 @ 2.67GHz 
stepping  : 5 
cpu MHz   : 2666.851 
cache size  : 8192 KB 
physical id  : 0 
siblings  : 8 
core id   : 0 cpu cores  : 4 
apicid   : 0 
fpu   : yes 
fpu_exception  : yes 
cpuid level  : 11 
wp   : yes 
flags   : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm syscall nx rdtscp lm constant_tsc ida nonstop_tsc pni monitor ds_cpl vmx est tm2 cx16 xtpr popcnt lahf_lm 
bogomips  : 5333.70 
clflush size  : 64 
cache_alignment  : 64 
address sizes  : 40 bits physical, 48 bits virtual 
power management: [8] 
processor  : 1 
... 
cpu cores  : 4 
... 
</code></pre>

<p>processor  : n &hellip; cpu cores  : 4 &hellip; processor  : 15 &hellip; cpu cores  : 4 &hellip;</p>

<p>【所以CPU(processor)的数量是最后一个cpu标号加1，每颗CPU的核数是其中&#8221;cpu cores&#8221;的值，这是一个有16颗4核CPU的服务器】</p>

<p>上面的结论错误，阅读cpuinfo的正确方法是：</p>

<ol>
<li><p>通过physical id确定有多少个物理CPU（即多少个CPU插槽socket，或者叫物理封装）；</p></li>
<li><p>通过cpu cores确定某一个物理CPU有多少核；</p></li>
<li><p>如果siblings数量与cpu core一致，说明没有超线程。反之如果siblings的值大于cpu cores，说明开启了超线程（hyperthreading），开启超线程的另一个证据是不同的processor拥有同样的core id，这一点可以用&#8221;cat /proc/cpuinfo|grep &ldquo;core id&#8221;确认；</p></li>
<li><p>processor的数量应该等于物理CPU的数量与siblings的乘积；</p></li>
</ol>


<p>根据以上方法分析，上面的服务器有两颗4核CPU（即两个CPU插槽，每个插槽上的CPU有4个核），开启了超线程，共有16个逻辑CPU。</p>

<p>参考<a href="http://www.richweb.com/cpu_info">Understanding Linux /proc/cpuinfo</a></p>

<h1>相关资料</h1>

<ul>
<li><p>查看CPU是32位还是64的方法是：cpuinfo的flags参数中是否有&#8221;lm&#8221;这一项，lm表示long mode，可以用&#8221;cat /proc/cpuinfo|grep &ldquo;\&lt;lm>&#8221;查询；</p></li>
<li><p>CPU超线程技术可以参考<a href="https://en.wikipedia.org/wiki/Hyper-threading">Hyper-threading</a>。</p></li>
</ul>


<h1>另：用free指令查看系统内存大小</h1>

<p>用free -g以GB为单位显示内存大小，另外可以通过查看cat /proc/meminfo指令结果第一行的方法确定物理内存大小；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/28/165932/">Linux中网络相关的配置文件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-28T16:59:32+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>4:59 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>/etc/hosts</h1>

<pre><code>10.31.1.71 servername1
10.31.1.52 servername2
</code></pre>

<p>当本机连接servername1时，通过这个文件将主机名映射为ip地址，相当于本机本部的DNS服务，对该文件的详细说明见Richard Petersen &ldquo;Linux: The Complete Reference&rdquo; p723: Identifying Hostnames: /etc/hosts。</p>

<h1>/etc/sysconfig/network</h1>

<p>用于定义主机的整体网络配置。</p>

<p> # /etc/sysconfig/network-scripts/ifcfg-eth0</p>

<p>专门定义eth0的属性，如果有多个网卡， network-scripts下可能还有ifcfg-eth1,ifcfg-eth2等几个文件。</p>

<h1>设置网卡eth0的IP地址</h1>

<pre><code>ifconfig &lt;eth0&gt; 10.31.1.251 netmask 255.255.255.0 up 
</code></pre>

<p>其中eth0是网卡名称，要根据ifconfig中列出的具体的网卡名字确定。</p>

<h1>修改主机名</h1>

<pre><code>hostname newHostname 
</code></pre>

<p>查询当前主机名：hostname</p>

<p>参见<a href="http://serverfault.com/questions/260034/what-is-the-difference-between-these-two-network-configuration-files">What is the difference between these two network configuration files?</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/27/201234/">源代码版本管理策略</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-27T20:12:34+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>8:12 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>基于DVCS的版本控制策略</h1>

<p>总体架构：主仓库（origin）中有两个<strong>永久</strong>分支：master和develop，master用来对外发布版本，所有的发布包都是从这个分支上打的；develop用来收集可用的开发特性，BVT系统是从这个分支上获取代码做nightly builds的；</p>

<p>每个开发者可能发起3种<strong>临时</strong>分支：feature, release和hotfix，临时的意思是这3中分支最终都要被合并到某个永久分支（master/develop）中。</p>

<p>下面是总体架构的图示：</p>

<ul>
<li><p>feature用来开发新产品特性的分支，只能从develop分支上分出，特性测试稳定之后合并回develop中去。命名规范：&lt;特征名>；</p></li>
<li><p>release用来准备发布的分支，当develop中的特性已经满足当前发布版本的所有要求时，就得分一个release分支出来供测试部门测试，所有测试过程中发现的bug都在这个分支上修改，修完所有bug可以发布时，将这个分支合并到develop上和master上，这个分支就消失了。在release上修改bug的同时，不影响为未来版本开发的feature合并到develop中。命名规范：release-<Rev>，Rev是计划的版本号，例如release-1.2；</p></li>
<li><p>hotfix用来修改master上代码发布到现场后出现的bug，修完后同时合并到develop和master上，master从1.2变为1.2p1或者1.2.1，然后删掉这个hotfix分支。命名规范：hotfix-&lt;目标版本号>，例如hotfix-1.2.1；</p></li>
</ul>


<p>各分支间的关系见下图：</p>

<p>以上基于<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>。</p>

<h2>评价</h2>

<ul>
<li><p>结构清晰，易于理解和使用；</p></li>
<li><p>不同现场的特殊需求问题：如果某个A现场使用v1.0，B现场使用v2.0，现在A报了bug，则只能给A使用高版本（v2.1），而不能通过在v1.0上打patch的方法解决，因为如果从master的tag v1.0处签出代码，修改bug，得到v1.0p1，还得将修改再合并到v2.0上，而且v1.0p1将变成一个无法合并的分支，但如果采用升级版本的方式改bug，就要求版本间功能具备连续性，如果为A现场的v1.0开发了一个特殊的功能X，又不能合并到master里去（因为其他现场不需要这个功能），升级将导致A无法使用X。所以怎样将各现场的特殊需求与版本控制结合起来仍然是一个未解决的问题。</p></li>
</ul>


<h2>后续工作</h2>

<ul>
<li><p>怎样在分支上打tag?</p></li>
<li><p>在Hg上重现上面的流程；</p></li>
</ul>


<h1>Hg的工作流程</h1>

<ol>
<li><p>在中心服务器origin上建立一个branch name为develop的分支；</p></li>
<li><p>假设开发者chad负责在现有版本上增加一个“使用正则表达式的预期-发送”功能，则chad先从origin上clone一份代码到&#8221;f:\ghost\tmpFiles\myProj&#8221;文件夹中；</p></li>
<li><p>将这份代码导入到Eclipse中，项目路径为d:\workspace\myProj，注意&#8221;.hg&#8221;文件夹也要导入；</p></li>
<li><p>删除&#8221;f:\ghost\tmpFiles\myProj&#8221;中的仓库，打开新的d:\workspace\myProj仓库，新建一个branch命名为&#8221;exp-send-regex&#8221;；</p></li>
<li><p>Eclipse中开发功能，提交本地版本；</p></li>
<li><p>当功能稳定后由origin将chad的代码pull到自己的代码库中：</p>

<ol type="a">
<li><p>启动chad的hg web server；</p></li>
<li><p>在origin上用&#8221;pull selected changes from selected URL&#8221;，将chad上面测试稳定的“使用正则表达式的预期-发送”功能分支拉过来；</p></li>
<li><p>合并到develop分支中：在exp-send-regex分支顶端的changeset上右键->merge with local；</p></li>
</ol>
</li>
</ol>


<h1>其他资料</h1>

<p><a href="http://www.51testing.com/?uid-300987-action-viewspace-itemid-823031">版本控制的分支策略及初步实践</a></p>

<p><a href="http://juvenshun.iteye.com/blog/376422">Maven最佳实践：版本管理</a></p>

<p><a href="http://www.infoq.com/articles/agile-version-control">Version Control for Multiple Agile Teams</a></p>

<p><a href="http://stackoverflow.com/questions/597707/best-branching-strategy-when-doing-continuous-integration">Best branching strategy when doing continuous integration</a></p>

<p><a href="http://www.hillside.net/plop/plop98/final_submissions/P37.doc">Streamed Lines: Branching Patterns for Parallel Software Development</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/24/114358/">Maven笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-24T11:43:58+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>11:43 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>mvn archetype:generate -DgroupId=org.leechau.maven -DartifactId=HelloWorldApp
mvn validate, mvn compile, mvn package, mvn test, &hellip; = maven install</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/23/090345/">Beginning Java EE 6 Platform With GlassFish 3源代码编译问题解决办法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-23T09:03:45+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2012</span></span> <span class='time'>9:03 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>根目录下pom.xml中
<repository>
   <id>EclipseLink Repo</id>
下的
<url><a href="http://mirror.csclub.uwaterloo.ca/eclipse/rt/eclipselink/maven.repo/">http://mirror.csclub.uwaterloo.ca/eclipse/rt/eclipselink/maven.repo/</a></url>
改为：
<url><a href="http://download.eclipse.org/rt/eclipselink/maven.repo/">http://download.eclipse.org/rt/eclipselink/maven.repo/</a></url>
可以解决无法找到eclipselink 2.0.1导致mvn compile失败问题；第二章编译成功；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/19/173502/">读取配置文件的方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-19T17:35:02+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>5:35 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>读取配置文件需要指定配置文件的路径和文件名，可以在Java代码里硬编码配置文件名，然后将配置文件所在目录加入classpath；也可以把路径和文件名都硬编码在Java代码里，只要启动脚本和配置文件的相对位置不变，就不必修改代码。第一种方法更灵活（指定配置文件路径的工作放在了启动脚本里，而不是Java代码中），推荐使用。</p>

<h1>硬编码配置文件名</h1>

<p>用Class的getResourceAsStream(String name)方法加载配置文件，代码如下：</p>

<p> InputStream in = this.getClass().getResourceAsStream(&ldquo;/db.properties&rdquo;);</p>

<p> Properties p = new Properties();</p>

<p> p.load(in);
 System.out.println(&ldquo;value is: &rdquo; + p.getProperty(&ldquo;db&rdquo;));</p>

<p>其中GetResources是运行这段代码所在类的类名，部署目录结构是：</p>

<p>root</p>

<p> |-bin</p>

<p>  |-start.bat</p>

<p> |-conf</p>

<p>  |-db.properties</p>

<p> |-lib</p>

<p>  |-res.jar</p>

<p>启动脚本start.bat内容是：</p>

<p> java -cp f:\VMFiles\tmpFiles\goduEx2\lib\res.jar;f:\VMFiles\tmpFiles\goduEx2\conf getResources.GetResources</p>

<p>其中res.jar的结构是：getResources/GetResources.class（假设代码所在文件的包名是getResources）。</p>

<p>这里最重要的是getResourceAsStream方法的参数前面要加上&#8221;/&ldquo;。</p>

<p>在static方法里无法使用&#8221;this&#8221;关键字，可以硬编码类名，在Eclipse中重构可以同时修改类名：</p>

<p> InputStream in = GetResources.class.getResourceAsStream(&ldquo;/db.properties&rdquo;);</p>

<h1>指定配置文件相对路径</h1>

<p>将上面代码的第一句改为：</p>

<p>InputStream in = new FileInputStream(&ldquo;../conf/db.prop&rdquo;);</p>

<p>相应地start.bat也不需要把conf加到classpath里：</p>

<p> java -cp f:\VMFiles\tmpFiles\goduEx2\lib\res.jar getResources.GetResources</p>

<p>不推荐ResourceBundle.getBundle()方法，因为这个方法不是用来加载文件的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/19/105207/">用jstack监控远程主机上的java进程</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-19T10:52:07+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>10:52 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前面提到用visualvm监控远程主机上的java进程，这种方法的好处是可以“实时”监控，缺点是需要启动jstatd，且只能看到线程总数，无法显示每个线程的详细情况，jstack可以生成某一进程的dump，包含在特定时刻（命令执行时）Java进程内部各个线程的详细情况。</p>

<p>首先用&#8221;jps -l&#8221;找到目标进程的PID，然后用&#8221;jstack [PID]&ldquo;获得dump，对于大型程序这个dump一般也比较大，所以用&#8221;jstack [PID] > dump_file_name&#8221;的方法将结果保存在文件dump_file_name里。</p>

<p>下面是dump文件中的一段：</p>

<p>&ldquo; HSQLDB Timer @5a1b5e32 &rdquo; daemon prio=3 tid=0x0000000101116800 nid=0x420a in Object.wait() [0xfffffffb5c2ff000]
 java.lang.Thread.State : TIMED_WAITING (on object monitor)
  at java.lang.Object.wait(Native Method)
  - waiting on <0xfffffffb721e7700> (a org.hsqldb.lib.HsqlTimer$TaskQueue)
  at org.hsqldb.lib.HsqlTimer$TaskQueue.park(HsqlTimer.java:883)
  - locked <0xfffffffb721e7700> (a org.hsqldb.lib.HsqlTimer$TaskQueue)
  at org.hsqldb.lib.HsqlTimer.nextTask(HsqlTimer.java:531)
  - locked <0xfffffffb721e7700> (a org.hsqldb.lib.HsqlTimer$TaskQueue)
  at org.hsqldb.lib.HsqlTimer$TaskRunner.run(HsqlTimer.java:611)
  at java.lang.Thread.run(Thread.java:662)</p>

<p>以上文本包含的信息包括：</p>

<p>线程名：HSQLDB Timer @5a1b5e32</p>

<p>锁住的资源：<0xfffffffb721e7700></p>

<p>线程堆栈</p>

<p>线程类型：daemon;</p>

<p>线程优先级（prio）：3</p>

<p>线程ID（tid）：0x0000000101116800</p>

<p>线程状态：&#8221;Object.wait()&ldquo;和&#8221;TIMED_WAITING&rdquo;</p>

<p>下面的一段供对照：</p>

<p>&ldquo; T-14319652 &rdquo; prio=3 tid=0x000000010294d000 nid=0x4208 runnable [0xfffffffb5d5f8000]
 java.lang.Thread.State: RUNNABLE
  at org.hsqldb.ExpressionColumn.getValue(ExpressionColumn.java:627)
  at org.hsqldb.ExpressionLogical.getValue(ExpressionLogical.java:1172)
  at org.hsqldb.ExpressionLogical.getValue(ExpressionLogical.java:1120)
  at org.hsqldb.ExpressionLogical.getValue(ExpressionLogical.java:1120)
  at org.hsqldb.ExpressionLogical.getValue(ExpressionLogical.java:1120)</p>

<p>参考：</p>

<p><a href="http://zheng12tian.iteye.com/blog/1420508">Java自带的性能监测工具用法简介——jstack、jconsole、jinfo、jmap、jdb、jsta、jvisualvm</a></p>

<p><a href="http://www.blogjava.net/jzone/articles/303979.html">JAVA线程dump的分析 &mdash; jstack pid</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/18/204259/">Top指令用法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-18T20:42:59+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>8:42 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>输出结果的含义：</p>

<p><a href="http://blog.csdn.net/jackyren007/article/details/3728075">Linux下查看CPU使用率!系统资源使用情况</a></p>

<p>指令参数说明：</p>

<p><a href="http://www.thegeekstuff.com/2010/01/15-practical-unix-linux-top-command-examples/">Can You Top This? 15 Practical Linux Top Command Examples</a></p>

<p>top界面上输入1（数字一）可以列出CPU每个核的情况，输入shift+h可以列出thread情况（详细说明在top界面上按h键）；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/18/202220/">用ps指令查看进程内的线程数量</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-18T20:22:20+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>8:22 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>[godu@goduserver ~]$ jps
24121 Jps
23854 PoolServer
22522 AppMain
22351 ResFreshAppMain
23898 PoolServer
22713 SimpleJettyServer</p>

<p>[godu@goduserver ~]$ ps -p 23854 -L -o tid,pcpu,state,nlwp
 TID %CPU S NLWP
23854 0.0 S 40
23855 0.0 S 40
23856 0.0 S 40</p>

<p>其中-L参数是列出进程内的线程（详见man ps的&#8221;THREAD DISPLAY&#8221;一节），-o是指定输出项（详见man ps的&#8221;STANDARD FORMAT SPECIFIERS&#8221;一节）。</p>

<p>参考：<a href="http://www.thegeekstuff.com/2011/04/ps-command-examples/">UNIX / Linux: 7 Practical PS Command Examples for Process Monitoring</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/18/193739/">用visualvm监控远程主机上的java进程</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-18T19:37:39+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>7:37 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>启动参数配置</h1>

<p>要监控PoolServer的运行情况，需要在启动时加上以下参数：</p>

<p> &ldquo;${JAVA_HOME}/bin/java&rdquo; -Dcom.sun.management.jmxremote \
 -Dcom.sun.management.jmxremote.port=9090 \
 -Dcom.sun.management.jmxremote.authenticate=false \
 -Dcom.sun.management.jmxremote.ssl=false \
 -Djava.rmi.server.hostname=10.0.2.47 \
 -Dservice_name=godu-3.0 -cp $JARS transfer.PoolServer</p>

<h1>系统配置</h1>

<p>首先在jstatd所在目录下（$JAVA_HOME/bin）新建一个policy文件jstatd.all.policy：</p>

<p>grant codebase &ldquo;file:${java.home}/../lib/tools.jar&rdquo; {</p>

<p> permission java.security.AllPermission;</p>

<p>};</p>

<p>然后运行jstatd：</p>

<p> jstatd -J-Djava.security.policy=jstatd.all.policy</p>

<p>程序启动后没有任何输出，但用jps和netstat -an|grep 1099可以验证jstatd是否启动成功。</p>

<p>参考：<a href="http://liwenqiu.github.com/blog/2012/02/22/use-visualvm-monitor-remote-java/">用VisualVM远程监控Java进程</a>（此文应该是基于<a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstatd.html">jstatd - Virtual Machine jstat Daemon</a>），注意其中的policy文件的写法，不要把${java.home}误写成${java_home}，因为这不是环境变量。</p>

<hr />

<p>2013-02-22更新</p>

<p>不运行上述&#8221;jstatd -J-D&hellip;&ldquo;情况下连接113服务器失败，运行jstatd命令需要首先安装openjdk6，装完后运行该命令，又用Ctrl+C停止，在jVisualVM中配置远程主机10.31.1.113，在上面右键：添加JMX连接，“连接”项设为10.31.1.113:9090，连接成功后在“抽样器”中首先进行“CPU设置”，仅分析&#8221;transfer.*&#8221;，然后点击&#8221;CPU&#8221;按钮进行CPU抽样，可以看到各个public方法的执行时间。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/67">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/65">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/02/01/134829/">Full Text Search for Meteor App</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/30/183509/">基于Search Source的简单查询实现方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/29/141348/">Git-flow Notes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/26/174649/">Meteor Development Styles</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/26/173952/">离线保存网页</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
