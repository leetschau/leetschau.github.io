
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="hg add
hg cat filename
hg ci，简短的注释可以用hg ci -m &ldquo;short comment"直接提交，如果没有配置用户，会导致提交失败，配置用户方法见笔记“ hg的常用配置 ”；
hg ci &ndash;amend: 修改上一次提交的备注信息
hg &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/66/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A notes repository for Meteor.js, data mining, Linux, etc.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="leetschau.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/26/184302/">Hg常用命令</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-26T18:43:02+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>6:43 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li><p>hg add</p></li>
<li><p>hg cat filename</p></li>
<li><p>hg ci，简短的注释可以用hg ci -m &ldquo;short comment"直接提交，如果没有配置用户，会导致提交失败，配置用户方法见笔记“ hg的常用配置 ”；
hg ci &ndash;amend: 修改上一次提交的备注信息</p></li>
<li><p>hg diff file：显示某个版本所做的更改</p>

<p>hg diff -c 19 filename；比较两个版本间的差异</p>

<p>hg diff -r 19 -r 20 filename</p></li>
<li><p>hg heads 列出所有头版本，用于合并分支(hg merge)前的查询</p></li>
<li><p>hg help <command_name>: show help information of <command_name>;</p></li>
<li><p>hg init：如果在非空目录中运行此命令，表示将已有的文件纳入到hg库中；</p></li>
<li><p>hg log</p>

<p>hg log -l n：只显示最近的n个changeset</p>

<p>hg log -v: 包含文件变化列表和完整的提交注释</p>

<p>hg log -k &ldquo;Your Name"：用户Your Name提交的changeset列表</p>

<p>hg log -G: 用分支图的形式列出changeset，可与-l参数配合使用</p>

<p>hg log filename: 列出与filename有关的各次提交的信息</p></li>
<li><p>hg merge 合并分支</p></li>
<li><p>hg pull <source_repo_url>：将<source_repo_url>中的change_set拉到本地repository中来，不影响working directory中的文件；</p>

<p>hg pull -u &lt;=> hg pull &ndash;update &lt;=> &ldquo;hg pull; hg update&rdquo; &lt;=> svn update</p>

<p>DVCS与SVN的区别在于DVCS存在两种类型的同步：repository之间以及本地repository与working directory之间，push/pull用于同步前者，update/commit用于同步后者；</p></li>
<li><p>hg push</p></li>
<li><p>hg rollback: 删除最近一次提交(commit)</p></li>
<li><p>hg st: 无参数表示tip与working dir的区别</p>

<p>hg st &ndash;rev 19：版本19的变化</p>

<p>hg st &ndash;rev x:y：比较x和y版本的变化，x与y的顺序无所谓；</p></li>
<li><p>hg update：用本地repository中的内容更新working_copy中的文件；</p>

<p>hg update -C: 抛弃本地未提交的更改，用版本库中的文件更新working directory；</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/26/181500/">Hg的常用配置</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-26T18:15:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>6:15 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>hg的配置文件分为全局配置和每个Repo自己的配置，
Linux下全局配置文件是~/.hgrc，Win7系统下是C:\Users\chad\mercurial.ini，
各repo的配置文件是$REPO_PATH/.hg/hgrc。</p>

<h1>常用配置</h1>

<h2>设置Repo的用户名</h2>

<pre><code>[ui] 
username = Your Name
</code></pre>

<h2>push/pull目标仓库</h2>

<pre><code>[paths] 
default = http://ip_or_hostname:8000/ 
repo1 = = https://user@bitbucket.org/user/nep
</code></pre>

<p>之后可以用hg push推送到default库，用hg push repo1推送到repo1库；</p>

<h2>push目标禁用ssl验证</h2>

<pre><code>[web] 
push_ssl = false 
allow_push = *
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/26/181254/">使用vimdiff做hg的版本比较工具</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-26T18:12:54+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>6:12 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>gvim的文本比较功能很强，命令行用法：gvim -d file1 file2，hg自带的hg diff没有颜色标示，含义也不够清晰，所以需要用vim的diff代替它，实现方法是在全局配置文件中增加：</p>

<p> [extensions]
 hgext.extdiff =
 [extdiff]
 cmd.vdiff = D:\Apps\Vim\vim73\gvim.exe
 opts.vdiff = -d</p>

<p>使用时首先用hg st定位哪些文件有变化，然后hg vdiff filename查看文件的变动，例如：</p>

<p> E:\workspace\JDK6UTF8\GoduServerGD>hg st
 M conf\logback.xml
 M &hellip;
 E:\workspace\JDK6UTF8\GoduServerGD>hg vdiff conf/logback.xml</p>

<p>文件路径和文件名在唯一的情况下可以使用通配符，例如上面的指令可以简写为"hg vdiff conf/log*&ldquo;；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/25/124302/">基于hg的多用户单分支协同开发试验</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-25T12:43:02+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:43 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>协同方法</h1>

<p>在所有开发人员中指定一个Server，类似于svn repo。其他人（Client）的代码是server的副本，修改、测试稳定后立即合并回server（最好通过server的pull方法实现，比client push更保险），server将client提交的更新与自己的更新合并（merge）后立即push回client，要注意的是server在pull之前要确保working directory中没有未提交的更改（未完成功能，用"hg st"命令的输出是否为空来检验，为空说明没有未完成功能），因为merge后必须提交一个“合并版本”到版本库，如果有未完成功能，也会被提交到版本库中。</p>

<p>A和B在同步过代码后，如果A提交了新changeset，而此期间B没有提交过，则A可以把变化push给B，这时B不需要merge，只update即可，update后可以用hg log -l 1 -v查看哪些文件发生了变化，以及A的提交说明；</p>

<p>整个协同过程中不需要新建branch或者bookmark，估计是最简单的分布式版本控制系统的协同模型。</p>

<h1>试验过程</h1>

<p>Server（username: Li Chao）新建一个repo，添加文件，提交changeset，Client（username: chadOnPC）clone此repo，修改其中一个文件，与此同时Li Chao修改了另一个文件，chadOnPC将修改push回笔记本，Li Chao合并两部分修改，再修改这两个文件，push到Client，由于这期间Client没有修改，所以只要update就把Server push的内容更新到了working directory中。</p>

<p>========== Server ================</p>

<p>c:\tmp\HgRepo>hg init
// 新建两个文件：forChadLaptop.txt和forChadPC.txt并写一些内容在文件里
c:\tmp\HgRepo>hg add <em>.txt
c:\tmp\HgRepo>hg stat
A forChadLaptop.txt
A forChadPC.txt
c:\tmp\HgRepo>hg ci -m &ldquo;first checkin&rdquo;
c:\tmp\HgRepo>hg log
changeset: 0:fd200857b086
tag:   tip
user:  Li Chao
date:  Thu Apr 25 11:32:24 2013 +0800
summary:  first checkin
c:\tmp\HgRepo>hg heads
changeset: 0:fd200857b086
tag:   tip
user:  Li Chao
date:  Thu Apr 25 11:32:24 2013 +0800
summary:  first checkin
c:\tmp\HgRepo>hg serve
listening at <a href="http://chadlaptop:8000/">http://chadlaptop:8000/</a> (bound to </em>:8000)
=========== Client ==============
E:\lc\clonedRepo>hg clone <a href="http://chadlaptop:8000/">http://chadlaptop:8000/</a>
&hellip;
E:\lc\clonedRepo>hg log
changeset: 0:fd200857b086
tag:   tip
user:  Li Chao
date:  Thu Apr 25 11:32:24 2013 +0800
files:  forChadLaptop.txt forChadPC.txt
description:
first checkin
E:\lc\clonedRepo>hg st
// edit file &ldquo;forChadPC.txt&rdquo;
E:\lc\clonedRepo>hg st
M forChadPC.txt
E:\lc\clonedRepo>hg ci -m &ldquo;first on pc&rdquo;
forChadPC.txt
committed changeset 1:2c5fbbb6645b
E:\lc\clonedRepo>hg log
changeset: 1:2c5fbbb6645b
tag:   tip
user:  chadOnPC
date:  Thu Apr 25 11:42:09 2013 +0800
files:  forChadPC.txt
description:
first on pc
changeset: 0:fd200857b086
user:  Li Chao
date:  Thu Apr 25 11:32:24 2013 +0800
files:  forChadLaptop.txt forChadPC.txt
description:
first checkin
/<strong> 需要在被push的repo的.hg/hgrc文件中增加如下内容（如果文件不存在新建之）：
 * [web]
 * push_ssl = false
 * allow_push = *
</strong>/
E:\lc\clonedRepo>hg push <a href="http://chadlaptop:8000/">http://chadlaptop:8000/</a>
pushing to <a href="http://chadlaptop:8000/">http://chadlaptop:8000/</a>
searching for changes
1 changesets found
remote: adding changesets
remote: adding manifests
remote: adding file changes
remote: added 1 changesets with 1 changes to 1 files
============= Server ==================
// 修改forChadLaptop.txt文件
c:\tmp\HgRepo>hg st
M forChadLaptop.txt // 修改被感知到
c:\tmp\HgRepo>hg heads
changeset: 1:2c5fbbb6645b
tag:   tip
user:  chadOnPC
date:  Thu Apr 25 11:42:09 2013 +0800
summary:  first on pc // 与push之前笔记本上"hg heads"命令相比，head变成了push过来的那个changeset
c:\tmp\HgRepo>hg st
M forChadLaptop.txt // push不改变working dirctory中的文件
c:\tmp\HgRepo>hg ci -m &ldquo;second commit on laptop&rdquo;
created new head
c:\tmp\HgRepo>hg heads
changeset: 2:42809e7d6c58
tag:   tip
parent:  0:fd200857b086
user:  Li Chao
date:  Thu Apr 25 11:54:05 2013 +0800
summary:  second commit on laptop
changeset: 1:2c5fbbb6645b
user:  chadOnPC
date:  Thu Apr 25 11:42:09 2013 +0800
summary:  first on pc  // head变成了两个
c:\tmp\HgRepo>hg branch
default   // branch始终只有default一个
c:\tmp\HgRepo>hg merge
1 files updated, 0 files merged, 0 files removed, 0 files unresolved
(branch merge, don&rsquo;t forget to commit)
c:\tmp\HgRepo>hg st
M forChadPC.txt  // merge命令改变了working directory中文件的内容
c:\tmp\HgRepo>hg ci -m &ldquo;merge from pc&rdquo;
c:\tmp\HgRepo>hg log
changeset: 3:ba028970a1d0
tag:   tip
parent:  2:42809e7d6c58
parent:  1:2c5fbbb6645b
user:  Li Chao
date:  Thu Apr 25 11:57:17 2013 +0800
summary:  merge from pc
changeset: 2:42809e7d6c58
parent:  0:fd200857b086
user:  Li Chao
date:  Thu Apr 25 11:54:05 2013 +0800
summary:  second commit on laptop
changeset: 1:2c5fbbb6645b
user:  chadOnPC
date:  Thu Apr 25 11:42:09 2013 +0800
summary:  first on pc
changeset: 0:fd200857b086
user:  Li Chao
date:  Thu Apr 25 11:32:24 2013 +0800
summary:  first checkin
=========== Client =====================</p>

<p>E:\lc\clonedRepo>hg serve</p>

<p>=========== Server ===================</p>

<p>c:\tmp\HgRepo>hg push <a href="http://china-a9598ee91:8000/">http://china-a9598ee91:8000/</a></p>

<p>&hellip;</p>

<p>=========== Client ===============</p>

<p>E:\lc\clonedRepo>hg update // 由于Client没有同时修改代码，所以不需要merge，update即可</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/23/110349/">运行时动态指定文件名的日志工具实现方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-23T11:03:49+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>11:03 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>网元日志的特点是：每个网元的日志要写在单独的文件中，文件名要能够唯一地确定一组“用户-网元”连接，因此不可能预先指定或者写在配置文件里，只能在运行时根据登录的用户名和连接网元的ID动态生成。</p>

<p>使用JDK原生的java.io.FileOutputStream等类可以达到上述目的，但文件的关闭比较麻烦，由于JVM垃圾回收的特点，日志包装类被回收的时间是不确定的，如果它被回收的比较慢，文件句柄就不会被关闭，导致系统资源消耗变大。</p>

<p>下面的代码基于Logback实现了运行时动态指定日志文件名的日志工具，并发500个线程写日志文件，大约耗时3s左右。</p>

<p> import ch.qos.logback.classic.Logger;
 import ch.qos.logback.classic.LoggerContext;
 import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
 import ch.qos.logback.classic.spi.ILoggingEvent;
 import ch.qos.logback.core.FileAppender;
 public class DynamicLogWriter {
  private String loggerName = null;
  private final Logger logbackLogger;
  public DynamicLogWriter(String logfileName) {
   loggerName = logfileName;
   LoggerContext loggerContext = new LoggerContext();
   FileAppender<ILoggingEvent> fileAppender = new FileAppender<ILoggingEvent>();
   fileAppender.setContext(loggerContext);
   fileAppender.setName(&ldquo;logfile&rdquo;);
   fileAppender.setFile(&ldquo;log/&rdquo; + loggerName + &ldquo;.log&rdquo;);
   PatternLayoutEncoder encoder = new PatternLayoutEncoder();
   encoder.setContext(loggerContext);
   encoder.setPattern(&ldquo;%msg&rdquo;);
   encoder.start();
   fileAppender.setEncoder(encoder);
   fileAppender.start();
   logbackLogger = loggerContext.getLogger(&ldquo;nelogger&rdquo;);
   logbackLogger.addAppender(fileAppender);
   // OPTIONAL: print logback internal status messages
   // StatusPrinter.print(loggerContext);
  }
  public void writeNeLog(String msg) {
   logbackLogger.debug(msg);
  }
  public static void main(String[] args) {
   for (int i = 0; i &lt; 500; i++) {
    new Thread(new ThreadWrapper(i)).start();
   }
  }
 }
 class ThreadWrapper implements Runnable {
  private final int id;
  public ThreadWrapper(int i) {
   id = i;
  }
  @Override
  public void run() {
   DynamicLogWriter logWriter = new DynamicLogWriter(&ldquo;192.168.0.2.&rdquo; + id);
   logWriter.writeNeLog(&ldquo;Welcome t&rdquo;);
   logWriter.writeNeLog(&ldquo;o Ubuntu 11.4\r\nlogi&rdquo;);
   logWriter.writeNeLog(&ldquo;n:user\r\npasswor&rdquo;);
   logWriter.writeNeLog(&ldquo;d:\r\nlast login&hellip;&rdquo;);
  }
 }</p>

<p>参考： <a href="http://stackoverflow.com/questions/7824620/logback-set-log-file-name-programatically">http://stackoverflow.com/questions/7824620/logback-set-log-file-name-programatically</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/22/131818/">Hg单用户操作的分支合并</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-22T13:18:18+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2013</span></span> <span class='time'>1:18 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>$ hg init hgBranchTest // 新建一个名为hgBranchTest的repo，hg自动创建目录</p>

<p>$ cd hgBranchTest</p>

<p>$ vi readme.txt</p>

<p>$ cat readme.txt
this is the first version</p>

<p>$ hg add readme.txt
$ hg ci -m &ldquo;first time commit&rdquo; // or use &ldquo;hg ci -A -m &hellip;&rdquo; for add and commit
$ vi readme.txt
$ cat readme.txt
this is the first version
add a line
$ hg st
M readme.txt
$ hg log
修改集:  0:ffecf69346a5
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit
$ hg diff
diff -r ffecf69346a5 readme.txt
&mdash; a/readme.txt  Mon Apr 22 05:49:29 2013 +0100
+++ b/readme.txt  Mon Apr 22 05:51:03 2013 +0100
@@ -1,1 +1,2 @@
this is the first version
+add a line
$ hg ci -m &ldquo;第二次提交&rdquo;
$ hg log
修改集:  1:770a5cda1659
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
修改集:  0:ffecf69346a5
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit
$ hg branch
default
$ hg branches
default      1:770a5cda1659
$ hg branch red
marked working directory as branch red
(branches are permanent and global, did you want a bookmark?)
$ vi readme.txt
$ cat readme.txt
this is the first version
add a line
add the 3rd line
$ hg branches   // 没有提交（commit）之前分支不出现在branches列表中
default      1:770a5cda1659
$ hg branch   // 当前仍在red分支下
red
$ hg ci -m &ldquo;commit on branch red&rdquo;
$ hg branches
red       2:86e30b1564a9
default      1:770a5cda1659 (inactive)
$ hg log
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
修改集:  1:770a5cda1659
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
修改集:  0:ffecf69346a5
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit
$ hg log -b red // 只显示red分支上的changeset
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
$ hg tip  // tip是最近版本的意思
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
$ hg heads  // head表示各分支最近版本
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
修改集:  1:770a5cda1659
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
$ hg up default   // 切换当前分支为default
1 files updated, 0 files merged, 0 files removed, 0 files unresolved
$ cat readme.txt  // 分支合并前文件内容
this is the first version
add a line
$ hg merge red
1 files updated, 0 files merged, 0 files removed, 0 files unresolved
(branch merge, don&rsquo;t forget to commit)
$ cat readme.txt  // 合并后文件内容改变
this is the first version
add a line
add the 3rd line
$ hg st
M readme.txt
$ hg ci -m &ldquo;after merge with branch red&rdquo;
$ hg log
修改集:  3:9a5f0a2b7b9c
标签:  tip
父亲:  1:770a5cda1659 // 合并后提交的版本的特点是有两个parent
父亲:  2:86e30b1564a9
用户:  Li Chao
日期:  Mon Apr 22 06:00:31 2013 +0100
摘要:  after merge with branch red
修改集:  2:86e30b1564a9
分支:  red
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
修改集:  1:770a5cda1659
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
修改集:  0:ffecf69346a5
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/20/105251/">局域网聊天和文件传输工具</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-20T10:52:51+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>10:52 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>以前用飞秋在局域网内聊天、传文件，经常找不到目标，很难用，在网上找了一个开源、跨平台（Win, Linux &amp; Mac）的局域网聊天软件<a href="http://lanmsngr.sourceforge.net/">LAN Messenger</a>，以及<a href="http://portableapps.com/apps/internet/lan-messenger-portable">Portable版</a>，下载的文件是便携版LANMessengerPortable_1.2.35.paf.exe，聊天、传文件、群聊的功能都有，很方便。</p>

<p>LANMessenger在Mint上安装后无法正常运行，发现Linux上的iptux（apt-get install iptux）实际山就是Windows上的FeiQ（下载压缩包FeiQ.rar后解压运行），目前工作良好。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/17/111523/">基于ScheduledExecutorService的并发定时任务处理能力测试</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-17T11:15:23+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>11:15 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>测试代码</h1>

<h2>定时器类</h2>

<p> package business.util;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 import transfer.IUserParser;
 public class MyTimer {
  private static ScheduledExecutorService ses = Executors
    .newSingleThreadScheduledExecutor();</p>

<p>   // .newScheduledThreadPool(10);
  private MyTimer() {
  }
  /<strong>
   * 设置某一parser正在执行脚本的超时时间
   *
   * @param parser
   *   进行超时控制的解析器
   * @param timeout
   *   超时时间，单位：秒
   * @return
   */
  public static ScheduledFuture&lt;?> set(IUserParser parser, int timeout) {
   CloseRutine routine = new CloseRutine(parser);
   ScheduledFuture&lt;?> job = ses.schedule(routine, timeout,
     TimeUnit.SECONDS);
   return job;
  }
  /</strong>
   * 清除计时器
   *
   * @param unit
   * @return
   <em>/
  public static boolean cancel(ScheduledFuture&lt;?> job) {
   return job.cancel(true);
  }
  /**
   * 关闭此计时器（进程）
   </em>/
  public static void shutdown() {
   ses.shutdown();
  }
 }
 class CloseRutine implements Runnable {
  private final IUserParser parser;
  CloseRutine(IUserParser parser) {
   this.parser = parser;
  }
  @Override
  public void run() {
   parser.closePeer();
  }
 }</p>

<h1>#</h1>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/16/120452/">Java语言子类调用父类构造函数的规则</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-16T12:04:52+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:04 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>子类初始化时，调用父类构造函数的规则是：如果父类没有任何构造函数，系统会</p>

<ul>
<li><p>父类如果没有任何构造函数，系统会自动为父类生成一个无参构造函数，如果父类有带参构造函数，系统不会为父类生成无参构造函数；</p></li>
<li><p>如果父类和子类的构造函数都有参数且参数列表一样（包括参数的个数、类型、顺序），子类如果想调用父类的构造方法，必须在构造函数第一行用super(params)显式调用，否则子类的构造函数会去找父类的默认（无参）构造函数；</p></li>
<li><p>如果父类有无参构造函数，子类的构造函数除非显式用super(params)调用父类的带参构造函数，否则一定会执行父类的无参构造函数（不需要写super()）；</p></li>
</ul>


<p>参考：google &ldquo;java constructor&rdquo;, <a href="http://www.leepoint.net/notes-java/oop/constructors/constructor.html">http://www.leepoint.net/notes-java/oop/constructors/constructor.html</a></p>

<h1>父类有默认构造函数时</h1>

<p> class SuperClass {
  public SuperClass() {
   System.out.println(&ldquo;I am the super class.&rdquo;);
  }
  public SuperClass (String name) {
   System.out.println(&ldquo;I am the super class with a name: &rdquo; + name);
  }</p>

<p>  public SuperClass (int age) {
   System.out.println(&ldquo;I am sub class with age: &rdquo; + age);
  }</p>

<p> }
 public class TestedSubClass extends SuperClass {
  public TestedSubClass(){
   System.out.println(&ldquo;I am sub class&rdquo;);
  }
  public TestedSubClass(String name){
   super(name);
   System.out.println(&ldquo;I am sub class with a name: &rdquo; + name);
  }
  public TestedSubClass(int age) {
   System.out.println(&ldquo;I am sub class with age: &rdquo; + age);
  }</p>

<p>  public static void main(String[] args) {
   TestedSubClass tsc = new TestedSubClass();
   TestedSubClass tsc2 = new TestedSubClass(&ldquo;chad&rdquo;);
   TestedSubClass tsc3 = new TestedSubClass(33);
  }
 }</p>

<p>运行结果：</p>

<p> [java] I am the super class.
 [java] I am sub class
 [java] I am the super class with a name: chad
 [java] I am sub class with a name: chad
 [java] I am the super class.
 [java] I am sub class with age: 33</p>

<p>当父类有默认（无参数）构造函数情况下，子类初始化时，除非子类用super(param)显式调用其他构造函数，否则一定会执行父类的默认构造函数，不论子类初始化时有没有参数。</p>

<h1>父类无默认构造函数</h1>

<p>如果仅将父类的默认（无参）构造函数去掉重新运行，报找不到初始化方法错误，原因是当父类有带参构造函数时，系统不为父类生成构造函数，而第1次和第3次初始化子类对象时，会调用父类的无参构造方法，所以报错；</p>

<p>如果去掉父类中所有的构造函数，子类中保留无参和int参数两个构造函数，运行正常；</p>

<p>如果仅保留父类和子类的String参数构造方法，初始化运行正常；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/07/230132/">Sublime Text笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-07T23:01:32+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>11:01 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Sublime Text作为一款文本编辑器，最强大的是快速响应能力和"Goto Anything"功能，用Ctrl+Shift+P执行编辑器功能，用Ctrl+P+@进行文件间与文件内部的跳转，目前的编辑器还没有类似的，Vintage将vi的强大编辑能力吸收了进来，更是如虎添翼。</p>

<p>它不适合作为静态语言（如Java）的正式开发IDE，与“标准的”IDE（如Eclipse）比较，它不具备针对静态语言的代码重构功能；在代码自动补全方面，无法提供类库的类名/方法补全（能够提供语言关键字和变量的补全）；它无法提供调试环境，需要单独的代码调试器（如JSwat）。所以Sublime Text适合作为展现语言（如HTML，Latex等）或者动态语言（Python, PHP等）的开发工具。</p>

<p>但很多时候我们只是想浏览代码，或是写一些简单的试验程序，或是修改代码的一处细节，启动Eclipse太慢了，用Sublime text这样text editor处理正合适。</p>

<h1>借助Ant打造Java IDE</h1>

<p>项目目录结构：项目根目录（$PORJ_HOME）下存放源代码、编译后的class文件和需要引用的jar包（而不是分开放在src, bin, lib文件夹下，适合于技术验证式的小项目），以及sublime项目定义文件（ProjectName.sublime-project）和build.xml，通过Ant的javac和java指令编译和运行Java代码，源代码不论什么包名都放在$PORJ_HOME下（Ant的javac指令会根据源代码的包名创建class文件的目录结构）；</p>

<h2>准备工作</h2>

<ol>
<li><p>指定用Ant做构建工具：修改[Preferences -> Browse Packages]打开packages文件夹，修改Java/JavaC.sublime-build文件，将原来"cmd"后面的"javac"改为"ant.bat"，如果ant所在目录没有加到系统的$Path里，这里需要写文件完整路径，例如"D:/Apps/apache-ant-1.8.1/bin/ant.bat"，然后将工作目录设置为项目根目录（默认的就是项目文件所在目录，因此这句不写也行）："working_dir": &ldquo;$project_path"；</p></li>
<li><p>安装AdvancedNewFile插件：利用package control的install new package功能，装完后就可以用快捷键"Ctrl + Alt + N"在项目根目录下创建文件了；</p></li>
</ol>


<h2>创建Java项目</h2>

<ol>
<li><p>创建项目文件夹（TotalCMD），拷贝此文件夹的完整路径；</p></li>
<li><p>Sublime Text -> Project -> Add Folder: 将上一步创建的文件夹加入到Project中；</p></li>
<li><p>生成新的Sublime项目文件：Sublime Text -> Project -> Save Project As，这样项目文件就定义好了，如果希望隐藏不必要的文件和文件夹：[Project -> Save Project As]，用file_exclude_patterns和folder_exclude_patterns属性实现，例如：</p></li>
</ol>


<p> {
  &ldquo;folders&rdquo;:
  [
   {
    &ldquo;path&rdquo;: &ldquo;/e/workspace/PNProject&rdquo;,</p>

<pre><code>"file_exclude_patterns": 
[ 
  "*.sublime*" 
] 
</code></pre>

<p>   }</p>

<p>  ]
 }</p>

<p>注：还可以用"folder_exclude_patterns":[&ldquo;build&rdquo;]这样的方式去掉文件夹。</p>

<ol>
<li>在项目根目录下新建一个build.xml文件，主要内容是编译和运行java代码（注意每个项目的启动类是不同的（java命令的classname参数），拷贝这个模板时需要修改）：</li>
</ol>


<p> &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
 <project name="ExProj" basedir="./" default="run">
  <path id="lib.path">
   <fileset dir="${basedir}">
    <include name="**/*.jar"/>
   </fileset>
  </path>
  <target name="compile">
   <javac srcdir="${basedir}" destdir="${basedir}"
    classpathref="lib.path" encoding="UTF-8" debug="true"/>
  </target>
  <target name="run" depends="compile">
   <java classname="org.leechau.HelloWorld">
    <classpath>
     <pathelement path="${basedir}"/>
    </classpath>
   </java>
  </target>
 </project></p>

<ol>
<li>运行构建：[Tools -> Build]（快捷键Ctrl+B）；</li>
</ol>


<h1>打开Vintage模式</h1>

<p>Vintage是vi风格的操作方式，当然要打开啦，方法是：</p>

<ol>
<li><p>在user preference里加上："ignored_packages": []</p></li>
<li><p>如果希望打开文档时初始状态是命令模式而不是插入模式，再加上："vintage_start_in_command_mode": true</p></li>
</ol>


<h1>自定义代码模板</h1>

<ol>
<li><p>[Tools -> New Snippet&hellip;];</p></li>
<li><p>填写模板内容（content），触发器（写完触发器按tab键展开为content中定义的代码）和有效范围（定义那些文件中此模板有效）；</p></li>
<li><p>保存模板文件：文件名统一约定为“范围名-触发器 .sublime-snippet”；</p></li>
</ol>


<p>参考<a href="http://www.granneman.com/webdev/editors/sublime-text/top-features-of-sublime-text/quickly-insert-text-and-code-with-sublime-text-snippets/#test">http://www.granneman.com/webdev/editors/sublime-text/top-features-of-sublime-text/quickly-insert-text-and-code-with-sublime-text-snippets/#test</a></p>

<p>实例：Java代码中终端打印语句的代码模板（spl + <Tab> -> System.out.println(${1});）：</p>

<p> <snippet>
  <content>&lt;![CDATA[
 System.out.println(${1});
 ]]></content>
  <!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
  <tabTrigger>spl</tabTrigger>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <scope>source.java</scope>
 </snippet></p>

<p>如果设置后不生效，检查各个标签的大小写是否正确（snippet文件是大小写敏感的），例如CDATA要大写，tabTrigger中T大写。</p>

<h1>Best Practice</h1>

<ul>
<li>所有的个性化配置都写在"Settings - User"，不要修改"Settings -> Default"；</li>
</ul>


<h1>Trouble Shooting</h1>

<ul>
<li><p>&ldquo;Decode error - output not utf-8&rdquo; when build java files: this is caused by adding &ldquo;"shell&rdquo;: true" in JavaC.sublime-build. cmd.exe use GBK(cp936) for console output encoding, which is different with sublime&rsquo;s default output encoding utf-8. So adding &ldquo;"encoding&rdquo;: &ldquo;cp936&rdquo;&ldquo; in JavaC.sublime-build will resolve this problem. Reference: <a href="http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=1535&amp;start=0">http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=1535&amp;start=0</a></p></li>
<li><p>Run Java without Ant: reference <a href="http://stackoverflow.com/questions/12030865/sublime-text-2-wont-run-java.">http://stackoverflow.com/questions/12030865/sublime-text-2-wont-run-java.</a> But when your java codes have package names, it&rsquo;s really difficult to compile and run them because package names are hardly get by sublime. So always use Ant to build java codes in sublime.</p></li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/67">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/65">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/02/21/110422/">3月6日演讲提纲</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/20/010838/">Merge Multiple PDF Files in Ubuntu</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/16/212514/">Debug Python Script</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/09/120142/">Golang Notes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/07/103930/">Cabal Notes</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
