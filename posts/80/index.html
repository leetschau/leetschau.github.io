
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="Java程序最常用的日志系统大概就是apache的log4j了，它的功能简单说就是“记录日志”。 它主要由logger、appender和layout这3个对象构成，logger是一个具体的“记录器”，appender是记录器的“输出对象”，它可以是屏幕输出、文件、界面组件、socket等。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/80">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A note repository aims at Data Mining, Spark, Linux, Python.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:leetschau.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/11/103433/">Log4j使用笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-11T10:34:33+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>10:34 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Java程序最常用的日志系统大概就是apache的log4j了，它的功能简单说就是“记录日志”。 它主要由logger、appender和layout这3个对象构成，logger是一个具体的“记录器”，appender是记录器的“输出对象”，它可以是屏幕输出、文件、界面组件、socket等。layout是appender的属性，决定appender所代表的输出中，一条具体的记录由哪些信息组成，排列顺序等。</p>

<p>每一个logger都有一个名字，名字是logger初始化时由getLogger的参数决定的，例如下面的logger的名字是com.foo：</p>

<pre><code>Logger logger = Logger.getLogger("com.foo"); 
</code></pre>

<p>名字是logger的唯一标识符，例如下面的x和y两个logger实际上是同一个对象：</p>

<pre><code>Logger x = Logger.getLogger("wombat"); 
Logger y = Logger.getLogger("wombat"); 
</code></pre>

<p>名字还具有继承性，例如名为com.foo.bar的logger是com.foo这个logger的子logger，com.foo又是com的子logger，子logger会继承所有上级logger的appender。这种继承类似于java包的父目录和子目录的关系，详见[1]的&#8221;Named Hierarchy&#8221;部分。</p>

<p>类似于根目录的概念，rootLogger是logger hierarchy的顶端，简单的log4j应用中，只定义rootLogger的appender，所有类中的logger就继承了rootLogger的特性。</p>

<p>为一个logger指定appender是在log4j配置文件中定义的，格式是：</p>

<pre><code>log4j.rootLogger=level_name, appender_name1, appender_name2, ... 
</code></pre>

<p>或： log4j.logger.logger_name=level_name, appender_name1, appender_name2, &hellip;</p>

<p>前者为rootLogger指定appender，后者为某一个具体的logger指定appender。定义appender属性的方法是：</p>

<pre><code>log4j.appender.appender_name=... 
log4j.appender.appender_name.layout=... 
</code></pre>

<p>例如下面的代码为rootLogger指定了appender A1，并设置A1为界面输出，然后指定了输出的格式，最后一行指定了com.foo的输出级别为WARN，com.foo及其子logger低于WARN的日志将不记录，由于com.foo没有指定appender，所以继承rootLogger的A1作为其输出：</p>

<pre><code>log4j.rootLogger=DEBUG, A1 
log4j.appender.A1=org.apache.log4j.ConsoleAppender 
log4j.appender.A1.layout=org.apache.log4j.PatternLayout 
log4j.appender.A1.layout.ConversionPattern=%d [%t] %-5p %c - %m%n 
log4j.logger.com.foo=WARN 
</code></pre>

<p>logger的级别常用的有debug, info, warn, error四种，详见“ log4j日志的输出级别设置 ”；appender常用的有 ConsoleAppender（控制台输出）、 DailyRollingFileAppender（按照一定的频率滚动输出日志，例如每月、每周、每天、每小时等）和 RollingFileAppender（到一定文件大小时滚动输出） 三种；layout常用的有SimpleLayout, PatternLayout, HTMLLayout, XMLLayout四种，后两种用来输出html和xml文本。不论哪种layout，都输出的是纯文本，因此各种appender与各种layout可以随意组合。</p>

<p>如果对项目中一些类的日志进行特殊处理（例如更改输出级别、指定新的输出文件等），见笔记“ 在包一级定制log4j日志输出 ”。</p>

<p>下面是一个完整的日志演示，首先是测试用例，只打一条日志：</p>

<pre><code>package com.boco.godu.gapi.logger; 
import org.apache.log4j.Logger; 
import org.junit.Test; 
public class Log4jDemo { 
    private final Logger logger = Logger.getLogger(this.getClass()); 
    @Test 
    public void testGapiLogger() { 
        logger.info(" Apache Logger "); 
    } 
} 
</code></pre>

<p>log4j.properties文件：</p>

<pre><code>log4j.rootLogger=debug, console, ft, fh, fx 
log4j.appender.console=org.apache.log4j.ConsoleAppender 
log4j.appender.console.layout=org.apache.log4j.SimpleLayout 
log4j.appender.ft=org.apache.log4j.RollingFileAppender 
log4j.appender.ft.File=./log/debug.log 
log4j.appender.ft.Append=false 
log4j.appender.ft.MaxFileSize=2MB 
log4j.appender.ft.MaxBackupIndex=10 
log4j.appender.ft.layout=org.apache.log4j.PatternLayout 
log4j.appender.ft.layout.ConversionPattern=%d{MM-dd HH:mm:ss,SSS} %t %c,%L %p - %m%n 
log4j.appender.fh=org.apache.log4j.RollingFileAppender 
log4j.appender.fh.File=./log/debug.html 
log4j.appender.fh.Append=false 
log4j.appender.fh.MaxFileSize=2MB 
log4j.appender.fh.MaxBackupIndex=10 
log4j.appender.fh.layout=org.apache.log4j.HTMLLayout 
log4j.appender.fh.layout.LocationInfo=true 
log4j.appender.fh.layout.Title=Test Log4j Layout 
log4j.appender.fx=org.apache.log4j.RollingFileAppender 
log4j.appender.fx.File=./log/debug.xml 
log4j.appender.fx.Append=false 
log4j.appender.fx.MaxFileSize=2MB 
log4j.appender.fx.MaxBackupIndex=10 
log4j.appender.fx.layout=org.apache.log4j.xml.XMLLayout 
log4j.appender.fx.layout.LocationInfo=true 
</code></pre>

<p>rootLogger一共挂了4个appender，分别是一个控制台输出，一个纯文本格式日志，一个html格式日志，一个xml格式日志。</p>

<p>运行测试用例后的效果如下（黑体字和红圈是源代码打出的日志）：</p>

<p>控制台输出：</p>

<pre><code>INFO - Apache Logger 
</code></pre>

<p>纯文本文件：</p>

<p>08-11 16:04:03,343 main com.boco.godu.gapi.logger.Log4jDemo,11 INFO - Apache Logger</p>

<p>html文件：</p>

<p>xml文件：</p>

<pre><code>&lt;log4j:event logger="com.boco.godu.gapi.logger.Log4jDemo" timestamp="1313049843343" level="INFO" thread="main"&gt; 
    &lt;log4j:message&gt;&lt;![CDATA[ Apache Logger ]]&gt;&lt;/log4j:message&gt; 
    &lt;log4j:locationInfo class="com.boco.godu.gapi.logger.Log4jDemo" method="testGapiLogger" file="Log4jDemo.java" line="11"/&gt; 
&lt;/log4j:event&gt;
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/10/201926/">Mantis安装过程笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-10T20:19:26+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>8:19 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>安装平台：Windows Server 2003 R2 Enterprise x64 Edition</p>

<p>软件：</p>

<p>EasyPHP-5.3.6.1</p>

<p> mantisbt-1.2.6</p>

<p>安装过程：</p>

<p>首先安装EasyPHP，一路next即可，安装到默认位置即可，路径中可以有空格；</p>

<p>将 mantisbt-1.2.6解压到 EasyPHP的www目录下，具体过程可参考 EasyPHP 3 + Mantis 1.2 快速搭建安装免费开源的中文缺陷管理平台 ；</p>

<p>配置：</p>

<p>C:\Program Files (x86)\EasyPHP-5.3.6.1\conf_files中将“Listen 127.0.0.1:80”和“ServerName 127.0.0.1:80”改为本机的IP地址，否则只能在本机登录mantis，局域网的其他机器不能访问。这部分的配置可参考 一步到位安装 Mantis Bug 跟踪系统 ，但其中有些东西已经过时了，例如对EasyPHP版本的限制、路径不能有空格等。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/02/114314/">Convert Java Codes to UML Diagram</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-02T11:43:14+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2011</span></span> <span class='time'>11:43 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Power Designer -> File -> Reverse Engineer -> Object Language
 Object Language: Java</p>

<p> Reverse engineer: Java directories</p>

<p> Add &hellip;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/08/01/111930/">Ivy配置文件编写规范</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-08-01T11:19:30+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2011</span></span> <span class='time'>11:19 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><ol>
<li>各依赖条目按严格按字母顺序排列；</li>
<li><p>对于平行开发的多个项目产品之间的依赖关系，要将changing参数设为true，否则可能造成缓存更新不及时导致编译错误；</p></li>
<li><p>如果要避免依赖传递，使用 conf=&ldquo;compile->master&#8221;，如果要显式的打开依赖传递，则使用transitive=&#8221;true&#8221;；</p></li>
</ol>


<p> 例如：</p>

<p> <dependency org="com.boco.ty" name="gapi" rev="alpha" conf="compile->master&#8221; changing=&ldquo;true&rdquo;/></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/26/091657/">GAPI的同步返回实现方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-26T09:16:57+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>9:16 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>GAPI 所基于 MINA 是一个异步网络通信框架，因此要实现 API 调用的同步方式返回，需要采用锁机制，即在主线程启动 filter 后进入“睡眠”状态， 当filter 处理任务完毕后唤醒主线程继续运行。具体实现的方法如下（以 execScript() 方法为例）。</p>

<p>测试用例：</p>

<p> public class SimpleExpScriptTest {</p>

<p>   private IConnection conn;</p>

<p>  @Test</p>

<p>  public void testPWD() throws Exception {</p>

<p>   conn = ConnFactory.getInstance().getConnection(Constants.PORT_CONNECT_GODU_DATA);</p>

<p>   conn.setSyncType(Constants.TYPE_DATA_CMD_SYNC);</p>

<p>   if (conn.getConnection(&ldquo;<aa><7001><administrator><autocmd>&rdquo;, &ldquo;goduapp&rdquo;, &ldquo;10.0.2.47&rdquo;, 1234, 100)) {</p>

<pre><code>System.out.println("Connect GODU OK!"); 
</code></pre>

<p>   }</p>

<p>   conn.sendGoduCmd(&ldquo;settelnetcodec switch=y&rdquo;);</p>

<p>   conn.set_script_timeout(500);</p>

<p>   Map&lt;String, Object> params = new HashMap&lt;String, Object>();</p>

<p>   params.put(&ldquo;user_name&rdquo;, &ldquo;test&rdquo;);</p>

<p>   params.put(&ldquo;old_pwd&rdquo;, &ldquo;godu123&rdquo;);</p>

<p>   params.put(&ldquo;new_pwd&rdquo;, &ldquo;testgodu&rdquo;);</p>

<p>   IResult result = conn. execScript (&ldquo;-1200187081&rdquo;, &ldquo;script/PWD&rdquo;, &ldquo;&rdquo;, params);</p>

<p>   System.out.println(&ldquo;***result is:\n&rdquo; + result.getString());</p>

<p>  }</p>

<p> }</p>

<p> execScript 方法：</p>

<p> package com.boco.godu.gapi.conn;</p>

<p> import &hellip;</p>

<p> public class GoduDataConnection extends AbstractConnection {</p>

<p>  private static final GapiLogger logger = LogUtils.getLogger(this.getClass().getName());</p>

<p>  private final Object lock = new Object(); //对象锁</p>

<p>  public IResult execScript(String ne_id, String scriptPath, String name, Map&lt;String, Object> params) throws &hellip; {</p>

<p>   // check if connected GODU successfully</p>

<p>   &hellip;</p>

<p>   // parse script file</p>

<p>   GoduScript gs = new GoduScript(scriptPath, script_buffer_size, params);</p>

<p>   // add execute_script filter</p>

<p>   session.getFilterChain().addBefore(&hellip;);</p>

<p>   // open NE</p>

<p>   &hellip;</p>

<p>   // 在执行完脚本或者超时之前阻止代码继续运行，在ExecScriptFilter.messageReceived方法中解锁</p>

<p>   GapiIosessionUtils. lockSession (session, lock , script_timeout );</p>

<p>   GoduReturnResult res = new GoduReturnResult();</p>

<p>   String script_result = (String) session.getAttribute(</p>

<pre><code>      ExecScriptFilter.EXEC_SCRIPT_RESULT, ""); 
</code></pre>

<p>   res.setArrays(script_result.getBytes());</p>

<p>   int return_status = (Integer) session.getAttribute(</p>

<pre><code>      ExecScriptFilter.EXEC_SCRIPT_RETURN_STATUS, 0); 
</code></pre>

<p>   res.setReturnStatus(return_status);</p>

<p>   return res;</p>

<p>  }</p>

<p> }</p>

<p> 这样代码运行到lockSession时暂停，直到超时时间到，或者被其他线程上持有同一个锁的“唤醒”方法唤醒，这实现了同步方式的前一半：下面是同步方式的后一半：filter执行脚本完毕后唤醒主线程继续运行：</p>

<p> package com.boco.godu.gapi.mina.filter.data;</p>

<p> import &hellip;</p>

<p> public class ExecScriptFilter extends AGapiFilter {</p>

<p>  @Override</p>

<p>  public void messageReceived(NextFilter nextFilter, IoSession session,</p>

<pre><code>     Object message) throws Exception { 
</code></pre>

<p>   &hellip;</p>

<p>   if (&hellip;) { // 如果脚本执行完毕：</p>

<pre><code>... 

GapiIosessionUtils. unlockSession (session); 

return; 
</code></pre>

<p>   }</p>

<p>   &hellip;</p>

<p>  }</p>

<p> }</p>

<p>那么 lockSession 和 unlockSession 方法又是如何实现的呢，继续往下看：</p>

<p> public class GapiIosessionUtils {</p>

<p>  public static void lockSession(final IoSession session, final Object lock , final int timeout ) throws &hellip; {</p>

<p>   try {</p>

<pre><code>if (session.isConnected() &amp;&amp; !session.isClosing()) { 

 long beforeLockTime = System.currentTimeMillis(); 

 session.setAttribute(GoduFilterConstants. GODU_DATA_LOCK , lock ); 

 session.getConfig().setBothIdleTime(timeout); 

 ThreadUtil. waitIt ( lock , timeout * 1000 + 1000); 

 long afterLockTime = System.currentTimeMillis(); 

 logger.debug("lockTime=" + (afterLockTime - beforeLockTime) + "ms"); 

} 
</code></pre>

<p>   } catch (Exception e) {</p>

<pre><code>e.printStackTrace(); 

logger.error("lockSession exception: ", e); 

throw new GapiException(e); 
</code></pre>

<p>   }</p>

<p>  }</p>

<p>  public static void unlockSession(final IoSession session) throws &hellip; {</p>

<p>   try {</p>

<pre><code>if (session.isConnected() &amp;&amp; !session.isClosing()) { 

 Object status = session.getAttribute(GoduFilterConstants. GODU_DATA_LOCK ); 

 ThreadUtil.notifyIt(status); 

} 
</code></pre>

<p>   } catch (Exception e) {</p>

<pre><code>... 
</code></pre>

<p>   }</p>

<p>  }</p>

<p> }</p>

<p> 可以看到加锁的时候将锁（lock对象）放在了session的一个attribute上，解锁的时候从这个attribute上取出这个锁，然后解锁。这里用到的 冻结线程的 waitIt 方法以及唤醒线程的 notifyIt 方法实现如下：</p>

<p> package com.boco.godu.common.util;</p>

<p> public class ThreadUtil {</p>

<p>  public static void  waitIt  (final Object o, final long time) {</p>

<p>   synchronized (o) {</p>

<pre><code>try { 

 if (time == -1) { 

  o.wait(); 

 } else { 

  o.wait(time); 

 } 

} catch (InterruptedException iex) { 

 iex.printStackTrace(); 

} 
</code></pre>

<p>   }</p>

<p>  }</p>

<p>   public static void  notifyIt (final Object o) {</p>

<p>   synchronized (o) {</p>

<pre><code> o.notifyAll(); 
</code></pre>

<p>   }</p>

<p>  }</p>

<p> }</p>

<p> 当代码到 o.wait(time); 时进入阻塞状态（停止运行，实际上是java.lang.Object.wait()方法），直到下列情况之一出现：</p>

<ol>
<li><p>超时时间time到；</p></li>
<li><p>被唤醒，也就是调用同一个对象的notifyAll方法（即java.lang.Object.notifyAll()方法）。</p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/23/103345/">Groovy正则表达式复杂逻辑判断实例</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-23T10:33:45+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2011</span></span> <span class='time'>10:33 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>下面的两个pattern（p1和p2）分别代表了(A or B) and (C or D)和(A and B) or (C and D)的跨行匹配结果，当然还可以用正则表达式构建更复杂的pattern，但这个实例证明了Groovy具备跨行匹配复杂逻辑表达式的能力。</p>

<p> 值得注意的是，多行匹配文本时需要在匹配字符串前加“(?ms)”。</p>

<p> 该实例同时演示了Groovy闭包的使用方法。
 源代码</p>

<p> msg1 = &lsquo;&rsquo;&lsquo;one two three four</p>

<p> five six&#8217;&lsquo;&rsquo;</p>

<p> msg2 = &lsquo;&rsquo;&lsquo;Jan Feb Mar</p>

<p> Apr May Jun&#8217;&lsquo;&rsquo;</p>

<p> msg3 = &lsquo;&rsquo;&lsquo;one two three</p>

<p> Apr May Jun&#8217;&lsquo;&rsquo;</p>

<p> msg4 = &lsquo;&rsquo;&lsquo;Jan Feb Mar</p>

<p> four five six&#8217;&lsquo;&rsquo;</p>

<p> p1 = / (?ms) (two|Feb).*(five|May)/</p>

<p> p2 = / (?ms) (two.<em>five)|(Feb.</em>May)/</p>

<p> msgs = [msg1, msg2, msg3, msg4]</p>

<p> patterns = [p1, p2]</p>

<p> patterns.each { pattern-></p>

<p> println &lsquo;pattern is: &rsquo;+pattern</p>

<p> msgs.each { msg-></p>

<p> println &lsquo;msg is: &rsquo;+msg</p>

<p> println &lsquo;match result is:&rsquo;</p>

<p> matcher = msg =~ pattern</p>

<p> if (matcher)</p>

<p> println &ldquo;true&rdquo;</p>

<p> else</p>

<p> println &ldquo;false&rdquo;</p>

<p> println &lsquo;&mdash;&rsquo;</p>

<p> }</p>

<p> println &lsquo;===&rsquo;</p>

<p> }
 运行结果
 pattern is: (?ms)(two|Feb).*(five|May)</p>

<p> msg is: one two three four</p>

<p> five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: one two three</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> four five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<hr />

<p> pattern is: (?ms)(two.<em>five)|(Feb.</em>May)</p>

<p> msg is: one two three four</p>

<p> five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: one two three</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> false</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> four five six</p>

<p> match result is:</p>

<p> false</p>

<hr />

<hr />
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/21/154602/">基于Tcc的C语言编译器</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-21T15:46:02+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2011</span></span> <span class='time'>3:46 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://bellard.org/tcc">TCC: Tiny C Compiler</a>是一款Windows平台上的迷你型C编译器，适合于学习算法时编译、演示一些简单的C语言程序，下面分别是基于vim和Notepad++的两种开发环境搭建方法。</p>

<h1>安装TCC</h1>

<p>TCC是绿色软件，下载软件包（tcc-0.9.25-win32-bin.zip）后解压即可运行，假设解压到&#8221;d:\apps\tcc&#8221;目录下。</p>

<h1>vim</h1>

<ol>
<li>将以下程序保存到hello.c文件中。</li>
</ol>


<p> #include &lt;stdio.h>
 main()
 {
  printf(&ldquo;hello, world!!!\n&rdquo;);
 }</p>

<ol>
<li>运行&#8221;:!d:\Apps\tcc\tcc.exe -run %&#8221;</li>
</ol>


<h1>Notepad++</h1>

<p>需要的软件：<a href="http://notepad-plus-plus.org/">Notepad++</a> v5.8.3 绿色版和它的NppExec插件；</p>

<h2>编译器</h2>

<p>下载tcc的windows压缩包后解压到一个目录下，例如”f:\Software\tcc“；</p>

<h2>语法高亮</h2>

<p>Notepad++内置了对C语言的语法高亮，如果在“语言”菜单下没有&#8221;C&#8221;语言项，在【设置->首选项->语言】下从”禁用项“列表中把C放到”启用项“列表中即可。</p>

<h2>命令行输出</h2>

<p>安装NppExec：下载NppExec后解压到npp安装目录的plugins文件夹下，例如我的npp绿色版路径是f:\Software\Notepad++583，则解压后目录结构为f:\Software\Notepad++583\plugins\NppExec.dll和f:\Software\Notepad++583\plugins\NppExec（下面是几个.h文件），压缩包doc目录下文件放在f:\Software\Notepad++583\plugins\doc下。启动Npp后可看到【插件->NppExec】菜单，【插件->NppExec->Show Console Dialog】打开命令输出窗口，可用【插件->NppExec->Change Console Font】修改输出窗口的字体和字号；</p>

<h2>定义运行脚本</h2>

<p> 【插件->NppExec->Execute】打开Execute窗口，输入</p>

<p> NPP_SAVE
 &ldquo;f:\Software\tcc\tcc.exe&rdquo; &ldquo;$(FULL_CURRENT_PATH)&rdquo; -run</p>

<p> 点Save保存此脚本为”Run C“；第一行脚本表示保存文件，第二行脚本使用了tcc.exe的-run参数，将编译、连接、运行一次性搞定；</p>

<h2>定义菜单项</h2>

<p> 【插件->NppExec->Advanced Options】中选择&#8221;Run C&#8221;，然后勾选&#8221;Place to the Macro submenu&#8221;；</p>

<p> 绑定快捷键</p>

<p> 【设置->管理快捷键】的&#8221;Macros&#8221;或者&#8221;Plugins commands&#8221;下面找到&#8221;Run C&#8221;，为其设置一个快捷键；</p>

<h2>编译运行</h2>

<p>Npp中打开前述hello.c文件，【宏->Run C】或者使用前面设置的快捷键启动Run C脚本，在Console窗口中可以看到程序的输出。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/19/164331/">日期格式转换的正则表达式实现</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-19T16:43:31+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>4:43 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原始文本：</p>

<blockquote><p>2011年7月18日：修改密码的核心功能开发完毕；
2011年7月19日：上午换座位，下午提交了著作权文档的电子流程；</p></blockquote>

<p>目标格式文本：</p>

<blockquote><p>2011-7-18：修改密码的核心功能开发完毕；
2011-7-19：上午换座位，下午提交了著作权文档的电子流程；</p></blockquote>

<h1>vim实现</h1>

<pre><code>:%s/\(\d\{4}\).\(\d\{1,2}\).\(\d\{1,2}\)./\1-\2-\3/g 
</code></pre>

<p>说明： 采用 :%s/old/new/g 命令进行替换，其中%表示对所有行进行替换操作，最后的g参数表明对一行中所有的new均替换为old。\d代表任意数字，old pattern中每个括号（即(&hellip;)）中的内容构成一个group member，new pattern中对group member的引用用\1、\2、\3&hellip;代表，即&#8221;BRE&#8221;, back references.</p>

<h1>Groovy实现</h1>

<pre><code>oriStr = '''2011年7月18日：修改密码的核心功能开发完毕； 
2011年7月19日：上午换座位，下午提交了著作权文档的电子流程；'''; 
pattern = /(\d{4})\W(\d{1,2})\W(\d{1,2})\W/; 
matcher = oriStr =~ pattern; 
matcher.each { all,y,m,d-&gt; 
    println 'Patten is: '+all; 
    println 'Replaced by: '+y+'-'+m+'-'+d; 
}; 
println '*****'; 
println oriStr.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d;}; 
</code></pre>

<p>运行结果：</p>

<pre><code>Patten is: 2011年7月18日 
Replaced by: 2011-7-18 
Patten is: 2011年7月19日 
Replaced by: 2011-7-19 
***** 
2011-7-18：修改密码的核心功能开发完毕； 
2011-7-19：上午换座位，下午提交了著作权文档的电子流程； 
</code></pre>

<p>说明： 跨行字符串用三引号括起来；匹配模式用“ /&hellip;/” 括起来；用模式匹配字符串时，每一次成功匹配构成了matcher的一个元素（代码中用matcher.each得到），如果模式当中包含group（可以matcher.hasGroup()判断），则这个元素本身也是一个List，其中第一个元素是符合模式的substring（代码中的all），各个group member可以用下标引用，也可以分别起名字（代码中分别为y、m、d）。这部分内容可参见《Groovy in Action》（2007版）第3.5节“Working with regular expressions”。Groovy的String.replaceAll方法包括两个参数，第一个是要被代替的pattern，第二个是用来代替pattern的closure，该closure的返回结果是最后一行代码的值。</p>

<p>例如：<code>println oriStr.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d;return 'Date'};</code> 的输出是：</p>

<pre><code>Date：修改密码的核心功能开发完毕； 
Date：上午换座位，下午提交了著作权文档的电子流程； 
</code></pre>

<h1>基于文件读写的Groovy实现</h1>

<pre><code>pattern = /(\d{4})\W(\d{1,2})\W(\d{1,2})\W/; 
convStr = ''; 
new File('f:/Edit3.txt').eachLine{ 
    convStr += (it.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d})+'\n' 
} 
new File('f:/conv.txt').write convStr; 
</code></pre>

<p>说明： 第4行的it表示此行文本（字符串）。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/18/112537/">Java Assert关键字的使用方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-18T11:25:37+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>11:25 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>assert后面的表达式为假时会抛出AssertionError类对象，此类继承自Throwable类，可以用try..catch(AssertionError e)&hellip;语句捕获并处理，如果不处理，将会向其他Exception一样向上层调用抛出，导致线程运行中断。</p>

<h2>使用assert的方法</h2>

<p>assert适用于定义服务器的能力边界，如最大负载等，不适于对外部条件（例如检验用户输入格式）进行判断（参考<a href="http://stackoverflow.com/questions/1276308/exception-vs-assertion%EF%BC%89%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A4%84%E7%90%86%E8%BF%99%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%8F%8D%E9%A6%88%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E3%80%82%E5%9F%BA%E4%BA%8E%E6%AD%A4%EF%BC%8C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%88%9D%E6%9C%9F%E5%8F%AF%E4%BB%A5%E7%94%A8assert%E5%B0%86%E6%B5%81%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6%E5%86%99%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%BD%86%E5%9C%A8%E4%BA%A7%E5%93%81%E5%8F%91%E5%B8%83%E5%89%8D%E5%BA%94%E5%B0%86%E8%BF%99%E4%BA%9B%E4%B8%B4%E6%97%B6assert%E6%94%B9%E6%88%90%E6%AD%A3%E5%BC%8F%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5%E3%80%82">http://stackoverflow.com/questions/1276308/exception-vs-assertion%EF%BC%89%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A4%84%E7%90%86%E8%BF%99%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%8F%8D%E9%A6%88%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E3%80%82%E5%9F%BA%E4%BA%8E%E6%AD%A4%EF%BC%8C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%88%9D%E6%9C%9F%E5%8F%AF%E4%BB%A5%E7%94%A8assert%E5%B0%86%E6%B5%81%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6%E5%86%99%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%BD%86%E5%9C%A8%E4%BA%A7%E5%93%81%E5%8F%91%E5%B8%83%E5%89%8D%E5%BA%94%E5%B0%86%E8%BF%99%E4%BA%9B%E4%B8%B4%E6%97%B6assert%E6%94%B9%E6%88%90%E6%AD%A3%E5%BC%8F%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5%E3%80%82</a></p>

<p>JUnit的assert*提供了比内置assert更丰富的判断方法，但本质上仍然是抛出AssertionError，且增加了对JUnit的依赖，因此不建议用JUnit代替assert。</p>

<p>（2012-12-19更新）</p>

<hr />

<p>Java的assert关键字是从JAVA SE 1.4 引入的，为了和老版本兼容，Java在执行的时候默认是不启动断言检查的，这种情况下所有的assert语句都将被忽略。要开启断言检查，则需要在运行时加参数-enableassertions或-ea来开启，在Eclipse中，就是在要运行的类（或测试方法）的Run Configurations中的“Arguments”下的“VM arguments”部分写上：“-ea”。为了避免由于忘记加这个开关造成assert失效导致错误的测试结果，建议不要使用java的assert，而使用JUnit的org.junit.Assert.assertTrue(expr)方法。</p>

<h1>assert关键字的两种用法：</h1>

<ol>
<li>assert &lt;boolean表达式></li>
</ol>


<p>如果&lt;boolean表达式>为true，则程序继续执行。</p>

<p>如果为false，则抛出 java.lang.AssertionError；</p>

<ol>
<li>assert &lt;boolean表达式> : &lt;提示信息> （boolean表达式和提示信息之间用冒号分隔）</li>
</ol>


<p>如果&lt;boolean表达式>为true，则程序继续执行。</p>

<p>如果为false，则抛出java.lang.AssertionError，并输出提示信息。</p>

<p>另外assert后面可以指定对哪些类断言生效，详见<a href="http://www.ibm.com/developerworks/cn/java/l-javaassertion/index.html">深入解析Java的新特性assertion</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/07/113549/">Use `Resolve Dependency in Workspace` Feature of IvyDE to Resolve Project Dependency in Develop Stage</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-07T11:35:49+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>11:35 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/81">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/79">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/11/28/084428/">Jump Between Tabs in Firefox With Keyboard Shortcuts</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/27/092846/">Vim as a HTML Editor</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/20/100341/">Using Empathy as Local Network Instant Messaging Tool</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/19/153734/">Add Customized Files and Folders Into Deployed Zip File Created by Gradle</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/13/114946/">Using Pub of Dart With Jayproxy</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
