
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="先看下面的例子（引自[1]）： def nano() = { println(&ldquo;Go into nano&rdquo;) System.nanoTime
}
def delayed(t: => Long) = { println(&ldquo;In delayed method& &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/89/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A notes repository for Meteor.js, data mining, Linux, etc.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="leetschau.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/11/03/103632/">Scala中Call by Name与普通参数调用的区别</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-11-03T10:36:32+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2011</span></span> <span class='time'>10:36 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>先看下面的例子（引自[1]）：</p>

<p> def nano() = {
 println(&ldquo;Go into nano&rdquo;)
 System.nanoTime
}
def delayed(t: => Long) = {
 println(&ldquo;In delayed method&rdquo;)
 println(&ldquo;Param: &rdquo;+t)
 t
}
def undelayed(t: Long) = {
 println(&ldquo;In not delayed method&rdquo;)
 println(&ldquo;Param: &rdquo;+t)
 t
}
在scala中以call by name方式调用nano：</p>

<p> scala> delayed(nano())</p>

<p>结果为：</p>

<p> In delayed method Go into nano
Param: 4475258994017 Go into nano
res3: Long = 4475259694720</p>

<p>以普通方式调用nano：</p>

<p> scala> notDelayed(nano())</p>

<p>结果为：</p>

<p> Go into nano
In not delayed method
Param: 4513758999378
res4: Long = 4513758999378</p>

<p>上述3个method中，delayed()和notdelayed()是caller（调用者），nano()是callee（被调用者）。可以看出当以普通方式调用callee时，nano()会在caller一开始运行的时候被计算一遍，在caller内部用到callee时，只要取出之前得到的结果即可，不会重新执行一遍callee；但Call by Name方式下不会预计算callee，而是严格地在每个使用callee的地点完整运行一遍callee。</p>

<p>[1] David Pollak, Beginning Scala, Apress, 2009, p31</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/31/111849/">VIM的键映射</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-10-31T11:18:49+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2011</span></span> <span class='time'>11:18 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>ESC键</h1>

<p>在vim中ESC是一个重度使用的键，但不幸的是这个键离手的默认位置比较远（最初设计VIM的键盘与现在的键盘不同，那个时候的ESC键基本上处在现在TAB键的位置上），按一次就得看一下键盘，严重影响VIM这种神器的使用者的风范，解决这个问题最好的方法不是刻苦训练手的机械记忆，首先训练比较花时间，其次孔子他老人家教导我们君子不器，我们怎么能把自己（的一部分）训练成机器呢？最后也是最重要的理由是：即使能训练出来，手在键盘上来回飞舞还是比较花时间， 基于以上理由，我决定采用如下键映射方法解决这个问题。
在$vim/_vimrc里加上：</p>

<pre><code>imap ;; &lt;ESC&gt; 
cmap ;; &lt;ESC&gt;
</code></pre>

<p>这样，在插入和命令行模式下，只要连按两个分号就相当于按了一次ESC键。那么，如果在插入模式下确实需要输入;;怎么办呢？只要在输入第一个;之后停顿一下，再输入就行了，详见“:h timeout”。对上述代码的详细解释见附1和附2。</p>

<p>上面是用;;代替ESC键，其实在还有别的很多替代方案，比如用jj代替ESC也比较常见，详见“ Avoid the escape key ”， 但我觉得都没有;;方案方便、安全、有效。</p>

<h1>Ctrl键</h1>

<p>比较普遍的方案是用Capslock键代替Ctrl键，这个vim自己就搞不定了，比较好的方法是用另一个神器：Autohotkey完成这个功能，下面的ahk代码实现Capslock键代替Ctrl键，而原来Capslock键的功能用Shift+Capslock实现；</p>

<pre><code>#IfWinActive VIM ; if in vim 
+Capslock::Capslock ; make shift+Caps-Lock the Caps Lock toggle 
Capslock::Control ; make Caps Lock the control button 
#IfWinActive  ; end if in vim 
</code></pre>

<p>详见“ MovingTheCtrlKey ”。</p>

<p>附1：键映射与模式</p>

<p>所谓键映射，就是将一个按键（或者组合按键）转换为另一个按键（或者组合按键）。为什么要转换呢？主要是为了提高效率，比如原始键位置太远，或者要输入的东西太多，或者需要两手同时操作。由于vim有多种模式，就出现了一个键映射在什么模式下有效的问题。以上面的ESC键为例，VIM一共有5种模式（详见:h map-modes）：normal, insert, operator-pending, visual, command-line，需要按ESC的只有insert和command-line两种，其他3种模式中jj往往表示光标移动，若映射会造成操作不便。map系列指令的第一个字母表示模式，上述五个模式分别用n, i, o, v, c表示（详见“:h map-overview”），所以imap表示仅在insert模式下这个映射有效。</p>

<p>附2：map与noremap的区别</p>

<p>若有“map A B”和“map B C”，则“map A B”最终的效果是执行C，这就是映射定义的嵌入与递归问题（详见“:h noremap”），不论是否存在“map B C”，“noremap A B”都执行B。结合附1的说明，nnoremap就是normal模式下的noremap指令；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/28/170614/">为VIM增加新的语法支持</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-10-28T17:06:14+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>5:06 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>添加语法高亮和自动缩进
以Scala语言为例。</p>

<p>在scala 2.9.1安装包的misc\scala-tool-support\vim下有4个文件夹：ftdetect, indent, plugin和syntax，将这4个文件夹合并到$vim/vimfiles（例如C:\Program Files\Vim\vimfiles）对应的文件夹中，这样打开扩展名为scala的文件时就会自动增加语法高亮和缩进了。</p>

<p>如果没有语法高亮和自动缩进效果，在$vim/_vimrc中增加：</p>

<p> filetype on &ldquo; Switch on filetype detection and loads</p>

<p> filetype indent on &ldquo; indent file (indent.vim) for specific file types</p>

<p> syntax on &ldquo; Turn on syntax highligthing</p>

<p> set autoindent &ldquo; Copy indent from the row above</p>

<p> set si &ldquo; Smart indent</p>

<p> set showmatch &ldquo;Show matching bracets when text indicator is over them</p>

<p>文件名匹配的原理见：:h new-filetype</p>

<p>手工启动语法高亮的方法：</p>

<p> copy scala.vim to $vim/vim72/syntax;</p>

<p> open test.scala with vim</p>

<p> :set syntax=scala</p>

<p>详见:h mysyntaxfile
 添加代码导航（code insight）
下载 Exuberant Ctags 5.8，解压；</p>

<p>下载 Tag List vim plugin 4.5，解压到$vim/vimfiles下；</p>

<p>到这里就可以显示ctags支持的语言（如C, JAVA, PYTHON等）了，但Scala不在支持之列，需要手工添加ctags和taglist对scala的支持：</p>

<p>新建$HOME/.ctags文件（对于Windows是命令行程序cmd.exe的启动位置，win7下是c:\Users[user_name].ctags，例如c:\Users\chad.ctags），内容如下：</p>

<p> &ndash;langdef=scala</p>

<p> &ndash;langmap=scala:.scala</p>

<p> &ndash;regex-scala=/^[ \t]*class[ \t]+([a-zA-Z0-9_]+)/\1/c,classes/</p>

<p> &ndash;regex-scala=/^[ \t]*trait[ \t]+([a-zA-Z0-9_]+)/\1/t,traits/</p>

<p> &ndash;regex-scala=/^[ \t]*type[ \t]+([a-zA-Z0-9_]+)/\1/T,types/</p>

<p> &ndash;regex-scala=/^[ \t]*def[ \t]+([a-zA-Z0-9_\?]+)/\1/m,methods/</p>

<p> &ndash;regex-scala=/^[ \t]*val[ \t]+([a-zA-Z0-9_]+)/\1/C,constants/</p>

<p> &ndash;regex-scala=/^[ \t]*var[ \t]+([a-zA-Z0-9_]+)/\1/l,local variables/</p>

<p> &ndash;regex-scala=/^[ \t]*package[ \t]+([a-zA-Z0-9_.]+)/\1/p,packages/</p>

<p> &ndash;regex-scala=/^[ \t]*case class[ \t]+([a-zA-Z0-9_]+)/\1/c,case classes/</p>

<p> &ndash;regex-scala=/^[ \t]*final case class[ \t]+([a-zA-Z0-9_]+)/\1/c,case classes/</p>

<p> &ndash;regex-scala=/^[ \t]*object[ \t]+([a-zA-Z0-9_]+)/\1/o,objects/</p>

<p> &ndash;regex-scala=/^[ \t]*private def[ \t]+([a-zA-Z0-9_]+)/\1/pd,defs/</p>

<p>这样每次ctags被调用时就会读取这个文件，语法格式详见“ Creating a user-defined language ”。</p>

<p> 在$vim/_vimrc里增加：</p>

<p> let Tlist_Ctags_Cmd=&ldquo;f:/Software/ctags58/ctags.exe&rdquo;</p>

<p> let tlist_scala_settings=&lsquo;scala;c:Classes;t:Traits;o:Objects;m:Methods;p:Packages;C:Constants;l:Local variables;T:Types&rsquo;</p>

<p>可以看到tlist_scala_settings的定义与.ctags里的定义是有对应关系的，以上参考了taglist文档第9节：“ Extending ”；还可以增加一个开/关taglist窗口的快捷键：</p>

<p> nnoremap <silent> <F4> :TlistToggle<CR></p>

<p> taglist常用操作： 在taglist窗口按F1； 添加自动补全
下载插件 AutoComplPop 和 L9 ，解压到$vim/vim72目录下（plugin, doc, autoload都要解压，且不能解压到$vim/vimfiles下），重启VIM即可。验证环境是win7, vim v7.2, AutoComplPop v2.14.1, L9 v1.1。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/27/152904/">Add Tags to Files With Xplorer2</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-10-27T15:29:04+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>3:29 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Win7 nowadays supports adding tags to files, and sorting/displaying files according to tags. However, only documents created by Office or image files support adding tags, while my favorite tag-arranged files are pdfs and archives (zip, rar, iso, etc). So this nested functionality of win7 can not satisfy me. Meanwhile, TotalCommander can add comments to files, but this functionality is insignificant, because these comments are stored in a separated file, which means if the target file is copied/moved to another place, comments will be lost.</p>

<p> Today I find this longing functionality in Xplorer2, which only works under NTFS format. Firstly you can add comments(here I use it as tags) to any kinds of files by selecting this file and [Action->Set comments]. Then you can search or select files with a particular tag as follow:</p>

<p> Open the find files window: ctrl+f;</p>

<p> Add a new rule in the “Additional Rules” frame;</p>

<p> In “Rule definition” panel, select “Comment” from “Property &amp; description” drop-down list, and specify the tags in the textbox beneath “Text Settings”;</p>

<p> Bingo!</p>

<p> For more details see &ldquo;Attaching comments to selected items&rdquo; of Xplorer2&rsquo;s documents.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/26/144257/">Buffer-related Operations in Vim</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-10-26T14:42:57+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>2:42 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Build-in Shortcuts</h1>

<p>:enew   open a new buffer in the current window (old buffers still exist);</p>

<p>:e <filename> open a existed file in the current window;</p>

<p>:sp <filename> open a file in a horizontal split window;</p>

<p>:vsp <filename> open a file in a vertical split window;</p>

<p>:new    open a new buffer in a horizontal split window;</p>

<p>:vnew   open a new buffer in a vertical split window;</p>

<p>:ls    list all buffers available. Current buffer is marked as &ldquo;%a&rdquo; and last edited buffer marked as &ldquo;#&rdquo;;</p>

<p>:b[N]   switch to [N]th buffers, [N] is buffer number from :ls command;</p>

<p>:b#    switch to last edited buffer;</p>

<p>:bn    switch to next buffer(based on buffer number);</p>

<p>:bp    switch to previous buffer(based on buffer number);</p>

<p>:bd    close current buffer(if this is the only one buffer, a new one will be created);</p>

<p>:sbn/:sbp  open the next/previous buffer in a horizontal split window;</p>

<p>:vert sbn  open the next buffer in a vertical split window;</p>

<p>:bd[N]   close buffer number [N], [N] is buffer number from :ls command;</p>

<p>:sb[N]   open buffer [N] in a horizontal split window;</p>

<p>:vert sb[N]  open another buffer in a vertical split window;</p>

<p>:vs / C-w v  split window vertically;</p>

<p>:clo / C-w q  close window;</p>

<p>:q    quit vim no matter how many buffers exist, or close window when more than one window exist;</p>

<p>Read :h buffer for more.</p>

<h1>Recommended user defined shortcuts</h1>

<p>In .vimrc:</p>

<p>noremap <silent> <left> <C-w>h
noremap <silent> <right> <C-w>l
noremap <silent> <up> <C-w>k
noremap <silent> <down> <C-w>j
nnoremap <leader>q <C-w>q</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/26/114224/">Netstat指令笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-10-26T11:42:24+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>11:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>指令参数</h1>

<p>c: show continous output every second</p>

<p>t: tcp protocol</p>

<p>u: udp protocol</p>

<p>p: show PID &amp; program name to which each socket belongs</p>

<p>l: only show listening port</p>

<p>n: show numeric port number instead of protocol name</p>

<h1>各项输出含义</h1>

<p> Local Address  Remote Address Swind Send-Q Rwind Recv-Q State</p>

<hr />

<p>10.168.68.191.41872 10.168.68.230.389 50320  0 50320  0 ESTABLISHED
  <em>.</em>     <em>.</em>    0  0 49152  0 IDLE
10.168.68.191.40297 10.168.68.230.389 50320  0 50320  0 ESTABLISHED
10.168.68.191.23  10.173.0.165.39679 64128  0 49232  0 ESTABLISHED
10.168.68.191.1234 10.173.0.132.4721 64987  0 5840  0 ESTABLISHED
10.168.68.191.1234 10.173.0.132.4722 64987  0 5840  0 ESTABLISHED
10.168.68.191.23  10.173.0.165.36957 64128  0 49232  0 ESTABLISHED</p>

<p>Rwind/Swind: tcp window size</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/26/091320/">检查windows的端口连接情况</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-10-26T09:13:20+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>9:13 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>例如服务器10.0.2.47上运行GODU，在1234端口上监听，netstat -an得到如下结果：</p>

<p>[godu@goduserver ~]$ netstat -an|grep 1234
tcp  0  0 :::1234      :::*      LISTEN<br/>
tcp  0  0 ::ffff:127.0.0.1:1234  ::ffff:127.0.0.1:57233  TIME_WAIT
tcp  0  0 ::ffff:10.0.2.47:1234  ::ffff:10.32.1.9:49694  ESTABLISHED</p>

<p>其中10.32.1.9是本机IP，如何验证本机上也有与47的连接？在命令行下运行netstat指令结果如下：</p>

<p>C:\Users\chad>netstat -an|findstr &ldquo;49694&rdquo;
 TCP 10.32.1.9:49694  10.0.2.47:1234   ESTABLISHED</p>

<p>这样就验证了本机的49694端口正在与47的1234端口连接。</p>

<p>总结：windows和linux的netstat指令通用，管道操作符"|&ldquo;通用，linux的grep对应windows的findstr。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/24/171356/">SQL语法笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-10-24T17:13:56+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>5:13 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>结果取并集：Union</p>

<p>计算结果数量：Count()</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/24/101855/">Use VIM as Lightweight Scala IDE</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-10-24T10:18:55+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>10:18 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>This is a demo of how to use VIM as a lightweight IDE to run Scala scripts. We will create a script named &ldquo;HelloWorld.scala&rdquo; and run it under /home/godu/test for linux or e:\mydoc\scalafiles for windows.</p>

<h1>Prerequisite</h1>

<p>We can compile and run Scala scripts in console. This means we&rsquo;ve already installed JRE and scala run-time files, and defined necessary enviroment variables such as JAVA_HOME and SCALA_HOME, and add $SCALA_HOME/bin to $PATH.</p>

<h1>Create &amp; Run Source Files</h1>

<p>In Linux:</p>

<pre><code>cd /home/godu/test 
vi HelloWorld.scala 
&lt;INSERT&gt;println("hello, world!")&lt;ESC&gt; 
:w HelloWorld.scala 
:!scala % 
</code></pre>

<p>In Windows:</p>

<pre><code>&lt;Open gvim&gt; 
:lcd e:\mydoc\scalafiles 
&lt;INSERT&gt;println("hello, world!")&lt;ESC&gt; 
:w HelloWorld.scala 
:!scala % 
</code></pre>

<h1>Add IDE functionality support</h1>

<p>syntax hightlight, auto-indent, auto-complete, code insight, etc, see note &ldquo;为VIM增加新的语法支持&rdquo;;</p>

<p>_vimrc settings for scala IDE</p>

<pre><code>let Tlist_Ctags_Cmd="f:/Software/ctags58/ctags.exe" 
let tlist_scala_settings='scala;c:Classes;t:Traits;o:Objects;m:Methods;p:Packages;C:Constants;l:Local variables;T:Types' 
nnoremap &lt;silent&gt; &lt;F4&gt; :TlistToggle&lt;CR&gt;  
nnoremap &lt;silent&gt; &lt;F9&gt; :!scala %&lt;CR&gt; 
colo evening 
imap jj &lt;ESC&gt; 
cmap jj &lt;ESC&gt; 
set directory=C:\Windows\Temp 
set backupdir=C:\Windows\Temp 
set clipboard+=unnamed 
set guifont=Consolas:h13 
set guioptions= 
set ts=2 
cd e:/mydoc/scalafiles 
</code></pre>

<p>For more information about the usage of filename-relative shortenings, use the following command for detail.</p>

<pre><code>:h filename-modifiers 
</code></pre>

<p>Frequently Used:</p>

<p> :!echo %  // show file name and extension</p>

<p> :!echo %&lt;  // show only file name</p>

<p> :!echo %:t:r // show only file name</p>

<p> :!echo %:p // show full path</p>

<p> :!echo %:e // show only file extension</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/10/21/171026/">JVM的内存管理机制</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-10-21T17:10:26+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2011</span></span> <span class='time'>5:10 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>JVM使用的内存分为两部分：堆（Heap）和栈（Stack），简单理解，堆可以看做是数据区，栈可以看做是指令区；下面详细说明二者的区别。</p>

<p>堆中存放的是对象实例（但不包括对象的方法，因为方法是指令，放在栈里），new出来的对象都放在堆里，对象不再被使用（不可达）时由GC（垃圾回收）机制回收，而无需代码显式释放，堆由于是在运行时动态分配的，因此存取速度比较慢；</p>

<p>栈中存放基本数据类型（primitive types: byte, int, float, long, char, boolean, etc）、常量、指令（例如对象的方法）和对象的引用地址（对象实例在堆中分配以后，需要在栈中保存一个4字节的堆内存地址，也就是所谓的对象句柄，用来确定该对象实例在堆中的位置）。栈中数据存取的速度比堆快，仅次于寄存器，但它必须在编译期间指定，且由于它采用FIFO(first in, first out)方式分配内存，因此不存在内存回收问题，因此GC是仅工作在堆上的。</p>

<p>堆又可以分为3个部分：年轻代（Young Generation,YG）、老代（Old Generation,OG）和永久代（Permanent Generation,PG），新创建的对象都放在YG里，经过几次GC后仍然生存的就被放到了OG里，PG里放的是类信息以及相关元数据（详见[1]）；YG的GC最频繁，PG的GC最少，这样可以极大地提高JVM的性能；</p>

<p>[1] 维基百科对JVM的堆的说明：<a href="http://en.wikipedia.org/wiki/Java_Virtual_Machine#Heap">http://en.wikipedia.org/wiki/Java_Virtual_Machine#Heap</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/90">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/88">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/02/093547/">Move Window Between Multiple Screens via Tmux</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/31/011200/">Synchronize Data From MongoDB to Elasticsearch</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/30/131706/">Elasticsearch River for MongoDB</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/29/204739/">Session Management in Web Browser</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/29/200553/">将Meteor应用完整从1.2版本降级到1.1版本</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
