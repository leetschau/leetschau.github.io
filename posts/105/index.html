
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="通过修改源文件中包名和手工编译源文件的方法，说明使用Java引用的方法是：
JAR文件实际上是zip格式压缩包，假设包结构为dir_a/dir_b/c.class（dir_a目录下是dir_b目录，dir_b目录下是c.class文件），将该JAR包的绝对路径加入到classpath中， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/105/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A notes repository for Meteor.js, data mining, Linux, etc.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="leetschau.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/04/085500/">Java中classpath与包名关系的一个试验</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-04T08:55:00+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:55 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>通过修改源文件中包名和手工编译源文件的方法，说明使用Java引用的方法是：
JAR文件实际上是zip格式压缩包，假设包结构为dir_a/dir_b/c.class（dir_a目录下是dir_b目录，dir_b目录下是c.class文件），将该JAR包的绝对路径加入到classpath中，然后在源文件里用import a.b.c的方法使用c类。下面分别用手工编译、运行不同包名源文件的方法证明以上论述。
方案1：类文件中不写包名： DOS命令为： cd e:\ex\leechau
set CLASSPATH=e:\MyDoc\JEx\MinaServer\lib\slf4j-jdk14-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\slf4j-api-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\mina-core-2.0.0-RC1.jar;.
javac SamplMinaServerHandler.java
javac MyMinaServer.java
java MyMinaServer  SamplMinaServerHandler.java文件内容为：  // package ex.leechau;  import org.apache.mina.core.service.IoHandlerAdapter;  import org.apache.mina.core.session.IoSession;   public class SamplMinaServerHandler extends IoHandlerAdapter{   private int count=0;   //当一个客端端连结进入时   @Override   public void sessionOpened(IoSession session) throws Exception {   System.out.println(&ldquo;incomming client : &rdquo;+session.getRemoteAddress());   }   //当一个客户端关闭时   @Override   public void sessionClosed(IoSession session) {    System.out.println(&ldquo;one Clinet Disconnect !&rdquo;);   }   @Override   public void messageReceived(IoSession session, Object message)     throws Exception {    //我们己设定了服务器解析消息的规则是一行一行读取,这里就可转为String:    String s=(String)message;    // Write the received data back to remote peer    System.out.println(&ldquo;收到客户机发来的消息: &rdquo;+s);    //测试将消息回送给客户端    session.write(s+count);    count++;   }  }  MyMinaServer.java文件内容为：  // package ex.leechau;
import java.io.IOException;
import java.net.InetSocketAddress;
import org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder;
import org.apache.mina.filter.codec.ProtocolCodecFilter;
import org.apache.mina.filter.codec.textline.TextLineCodecFactory;
import org.apache.mina.transport.socket.SocketAcceptor;
import org.apache.mina.transport.socket.nio.NioSocketAcceptor;
public class MyMinaServer {
  public static void main(String[] args) throws IOException {
   //创建一个非阻塞的Server端Socket,用NIO
  SocketAcceptor acceptor = new NioSocketAcceptor();
  //创建接收数据的过滤器
  DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();
  //设定这个过滤器将一行一行(/r/n)的读取数据
  chain.addLast(&ldquo;myChin&rdquo;, new ProtocolCodecFilter(new TextLineCodecFactory()));
  //设定服务器端的消息处理器:一个SamplMinaServerHandler对象,
  acceptor.setHandler(new SamplMinaServerHandler());
  // 服务器端绑定的端口
  int bindPort=9988;
  //绑定端口,启动服务器
  acceptor.bind(new InetSocketAddress(bindPort));
  System.out.println(&ldquo;Mina server is listening on port: &rdquo; + bindPort);
  }
}  方案2：类文件中写包名，在源文件目录下编译： cd e:\ex\leechau
set CLASSPATH=e:\MyDoc\JEx\MinaServer\lib\slf4j-jdk14-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\slf4j-api-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\mina-core-2.0.0-RC1.jar;e:\
javac SamplMinaServerHandler.java
javac MyMinaServer.java
java MyMinaServer  SamplMinaServerHandler.java和MyMinaServer.java文件取消方案1中包名上的注释。
方案3：类文件中写包名，在项目根目录下编译： cd e:\
set CLASSPATH=e:\MyDoc\JEx\MinaServer\lib\slf4j-jdk14-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\slf4j-api-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\mina-core-2.0.0-RC1.jar;.
javac ex/leechau/SamplMinaServerHandler.java
javac ex/leechau/MyMinaServer.java
java ex/leechau/MyMinaServer SamplMinaServerHandler.java和MyMinaServer.java文件与方案2一样。
以上3中方案都可以是Mina Server正常运行，但如果在有包名的情况下使用方案1的方法定义classpath，则编译MyMinaServer.java时会出现“无法识别SamplMinaServerHandler”错误。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/04/085015/">用UltraEdit Color Scheme Manager修改UE的配色主题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-04T08:50:15+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:50 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>UltraEdit的各种配置信息都保存在一个叫UEdit32.ini的文件中，配色主题是其中的一部分，UltraEdit Color Scheme Manager为修改此部分提供了一个便捷的工具，用户可首先生成自己的配色文件（或者使用别人制作的配色文件），然后用它导入到UEdit32.ini中，就实现了添加配色主题的目的。具体步骤是：
 下载压缩包uecolors_v1.2.1.1006.zip，解压，运行其中的uecolors.exe；
 为UltraEdit Color Scheme Manager指定UE的ini文件位置【Settings->Set INI File Location】，根据版本不同，ini文件可能出现在两处：c:\Documents and Settings\Administrator\Application Data\IDMComp\UltraEdit\UEdit32.ini或者UE的安装目录下；
 【File->Open Scheme】将做好的配色主题文件导入（例如压缩包里自带的Borland.ueTheme），【File->Export Theme to UE】；
 运行UE，【View->Set Colors->Save】保存配色主题；
 关闭UE，打开UEdit32.ini，将默认的配色主题名字user scheme 1 改为自己定义的名字；</p>

<p>That&rsquo;s it.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/03/145318/">jEdit使用笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-03T14:53:18+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2010</span></span> <span class='time'>2:53 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>安装</h1>

<p>首先下载jar包，然后命令行执行：java -jar jeditInstall.jar</p>

<p>安装完毕后，在安装目录下执行：java -jar jedit.jar</p>

<h1>修改字体</h1>

<p>Options -> Global Options:</p>

<p> Text Area: Editor字体；</p>

<p> Appearence: 列表、工具栏等处的字体；</p>

<h1>Java开发相关插件</h1>

<ul>
<li><p>ProjectViewer, JavaSideKick, Console, JSwat或者JavaDebugger</p></li>
<li><p>Console: 修改字体：Options -> Plugin Options -> Console -> General -> Font;</p></li>
</ul>


<p>jEdit的问题与DrJava一样，就是不具备专用IDE（如Eclipse）的代码感知功能，例如动态检查语法错误，缺包（import语句解析失败）提示等，目前的解决方案是Eclipse + viPlugin；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/03/094208/">用Notepad++实现轻量级Java IDE</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-03T09:42:08+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2010</span></span> <span class='time'>9:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>打开Notepad++的命令窗口</p>

<p>主菜单【插件->NppExec->Show Console Dialog】</p>

<p>设置环境变量</p>

<p>设置JAVA_HOME为：f:\warez\Develop\Java\jdk1.5.0_16</p>

<p>验证：在npp命令窗口中输入javac并回车，如果输出javac的帮助信息说明环境变量设置成功；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/01/142409/">Eclipse插件安装方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-01T14:24:09+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2010</span></span> <span class='time'>2:24 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Eclipse SDK 3.7支持在dropins文件夹中安装插件，解压后的目录格式为：$ECLIPSE_DIR/dropins/<plugin_name>/plugins(features)，如下图所示：</p>

<p>$ECLIPSE_DIR/dropins</p>

<pre><code>|__IvyDE

| |__plugins

| |__features

|__Terracotta

  |__plugins
</code></pre>

<p>以上方法在Eclipse SDK 3.7下安装ivyde和terracotta两个插件成功。</p>

<p>下面是旧版Eclipse的安装方法，供参考。</p>

<p>Eclipse Galileo安装插件主要有3中方式：直接解压、菜单和外部插件。直接解压就是将插件中plugins和features目录中的文件解压到eclipse对应的目录中，这显然不是好办法，一旦插件要升级或者不想用了，卸载会变得及其困难。菜单方法就是用elipse菜单【Help->Install New Software】装插件，试了一下似乎不好用，插件管理确实是eclipse需要加强的地方（也或许是开发者认为做这个功能没必要？）。外部插件就是写link文件，比较而言这种方法是最好的，想卸载的时候只要去掉link文件就行了。</p>

<p>过程如下：</p>

<p>1、解压插件。确定插件解压目录，如f:\warez\IDEs\EclipsePlugins\，将插件解压到这个目录下，目录结构如下：</p>

<p> f:\warez\IDEs\EclipsePlugins\language\eclipse\plugins\</p>

<p>f:\warez\IDEs\EclipsePlugins\language\eclipse\features\</p>

<p>也就是保证每一个插件目录（这里是 language ）下是 eclipse，再下面是 plugins和features。</p>

<p> 2、在 eclipse解压目录 下新建文件夹   links（也就是links与eclipse.exe处在相同目录下），例如：</p>

<p> f:\warez\IDEs\Eclipse0901\eclipse.exe与f:\warez\IDEs\Eclipse0901\links\；</p>

<p> 3、在  links   下新建一个   link   文件，比如   language.start  ， 后缀名可以任意取，如   .link,.ini,.txt   等等   ,   只要 link 文件名和插件文件安装目录中的最后文件夹名一致即可， 在这里我的插件安装目录结构为  f:\warez\IDEs\EclipsePlugins\language\， 所以   link   文件名就命名为 language.start， 如果你的插件安装目录结构为 D:\eclipse\myPlugins\languagepack,   则 link   文件名应为 languagepack.start 。</p>

<p> 4、在 language.start 中写入如下一句话：path=F:/warez/IDEs/EclipsePlugins/language， 即 path= 你的插件安装目录（ 路径字符串中要用/代替\ ， language后面不要写“/” ）；</p>

<p> 5、启动 eclipse：在 f:\warez\IDEs\Eclipse0901下运行 eclipse -clean；</p>

<p> 如果发现查件没有安装成功，按下面的步骤debug：</p>

<p> 1、确认配置好插件启动eclipse时一定要用eclipse -clean的方法启动，这样eclipse会重新检查、加载一遍插件，之后再启动eclipse就不需要-clean参数了。  2、若还不行，删除 f:\warez\IDEs\Eclipse0901\configuration下的org.eclipse.update目录（这是一个记录插件更新情况的文件夹），删除掉这个文件夹后，   eclipse   会重新扫描所有的插件；</p>

<p> 3、若还不行，最有效的办法是分析工作目录下 .metadata目录下的.log文件（如 d:\workspace.metadata.log），如果插件未能正确加载，会在目录里给出加载插件失败的信息；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/01/094254/">设计原则</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-01T09:42:54+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2010</span></span> <span class='time'>9:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>依赖都定义在接口中（依赖倒置原则），接口的设计要符合“只有一个原因引起接口变化”（单一职责原则）。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/31/113536/">VBA语法概述</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-31T11:35:36+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2010</span></span> <span class='time'>11:35 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1，标识符 是一种标识变量、常量、过程、函数、类等语言构成单位的符号，利用它可以完成对变量、常量、过程、函数、类等的引用。命名规则如下： A, 字母打头，由字母、数字和下划线组成，如 A987b_23Abc B, 字符长度小于40，（Excel2002以上中文版等，可以用汉字且长度可达254个字符） C, 不能与VB保留字重名，如public, private, dim, goto, next, with, integer, single等   2,运算符 是代表VB某种运算功能的符号。 A, 赋值运算符 = B, 数学运算符 &amp;、+ (字符连接符)、+(加)、-（减）、Mod（取余）、\（整除）、*（乘）、/（除）、-（负号）、^（指数） C, 逻辑运算符Not（非）、And（与）、Or（或）、Xor（异或）、Eqv（相等）、Imp（隐含） D, 关系运算符 = （相同）、&lt;>（不等）、>（大于）、&lt;（小于）、>=（不小于）、&lt;=（不大于）、Like、Is E, 位运算符 Not（逻辑非）、And（逻辑与）、Or（逻辑或）、Xor（逻辑异或）、Eqv（逻辑等）、Imp（隐含）   3,数据类型 VBA共有12种数据类型，具体见下表，此外用户还可以根据以下类型用Type自定义数据类型。  数据类型 类型标识符 字节 字符串型 String $ 字符长度(0-65400) 字节型 Byte 无 1 布尔型 Boolean 无 2 整数型 Integer % 2 长整数型 Long &amp; 4 单精度型 Single ! 4 双精度型 Double # 8 日期型 Date 无 8 公元100/1/1-9999/12/31 货币型 Currency @ 8 小数点型 Decimal 无 14 变体型 Variant 无 以上任意类型，可变 对象型 Object 无 4    4, 变量与常量: 1）VBA允许使用未定义的变量，默认是变体变量Variant。 2）在模块通用说明部份，加入 Option Explicit 语句可以强迫用户进行变量定义。 3）变量定义语句及变量作用域 Dim 变量 as 类型 &lsquo;定义为局部变量，如 Dim xyz as integer
Private  变量 as 类型 '定义为私有变量，如 Private   xyz as byte
Public  变量 as 类型 '定义为公有变量，如 Public   xyz as single
Global   变量 as 类型 '定义为全局变量，如 Globlal   xyz as date
Static  变量 as 类型 '定义为静态变量，如 Static xyz as double 一般变量作用域的原则是，那部份定义就在那部份起作用，模块中定义则在该模块那作用。 4）常量为变量的一种特例，用Const定义，且定义时赋值，程序中不能改变值，作用域也如同变量作用域。如下定义：Const Pi=3.1415926 as single   5,数组 是包含相同数据类型的一组变量的集合，对数组中的单个变量引用通过数组索引下标进行。在内存中表现为一个连续的内存块，必须用Global或Dim语句来定义。定义规则如下： Dim 数组名([lower to ]upper [, [lower to ]upper, ….]) as type ;Lower缺省值为0。二维数组是按行列排列，如XYZ(行，列)。 除了以上固定数组外，VBA还有一种功能强大的动态数组，定义时无大小维数声明；在程序中再利用Redim语句来重新改变数组大小，原来数组内容可以通过加preserve关键字来保留。如下例： Dim array1() as double : Redim array1(5) : array1(3)=250 : Redim preserve array1(5,10)   6,注释和赋值语句 1）注释语句是用来说明程序中某些语句的功能和作用；VBA中有两种方法标识为注释语句。  单引号 ’ ;如：’定义全局变量；可以位于别的语句之尾，也可单独一行  Rem ;如：Rem定义全局变量；只能单独一行  2）赋值语句是进行对变量或对象属性赋值的语句，采用赋值号 =，如X=123：Form1.caption=”我的窗口”。对对象的赋值采用：set myobject=object 或 myobject:=object   7,书写规范: 1）VBA不区分标识符的字母大小写，一律认为是小写字母； 2）一行可以书写多条语句，各语句之间以冒号 : 分开； 3）一条语句可以多行书写，以空格加下划线 _ 来标识下行为续行； 4）标识符最好能简洁明了，不造成歧义。   8,判断语句 1）If…Then…Else语句 If condition Then [statements][Else elsestatements]
如1：If A>B And C<D Then A=B+2 Else A=C+2
如2：If x>250 Then x=x-100
或者，可以使用块形式的语法：
If condition Then
[statements]
[ElseIf condition-n Then
[elseifstatements] &hellip;
[Else
[elsestatements]]
End If
如1:
If Number &lt; 10 Then
Digits = 1
ElseIf Number &lt; 100 Then
Digits = 2
Else
Digits = 3
End If 2）Select Case…Case…End Case语句 如1：
Select Case Pid
Case “A101”
Price=200
Case “A102”
Price=300
……
Case Else
Price=900
End Case 3）Choose 函数： choose(index, choce-1,choice-2,…,choice-n)，可以用来选择自变量串列中的一个值，并将其返回，index 必要参数，数值表达式或字段，它的运算结果是一个数值，且界于 1 和可选择的项目数之间。choice 必要参数，Variant表达式，包含可选择项目的其中之一。如： GetChoice = Choose(Ind, &ldquo;Speedy&rdquo;, &ldquo;United&rdquo;, &ldquo;Federal&rdquo;) 4）Switch函数： Switch(expr-1, value-1[, expr-2, value-2 _ [, expr-n,value-n]]) switch函数和Choose函数类似，但它是以两个一组的方式返回所要的值，在串列中，最先为TRUE的值会被返回。 expr 必要参数，要加以计算的 Variant 表达式。value 必要参数。如果相关的表达式为 True，则返回此部分的数值或表达式，没有一个表达式为 True，Switch 会返回一个 Null值。   9,循环语句 1）For Next语句 以指定次数来重复执行一组语句 For counter = start To end [Step step]  &rsquo; step 缺省值为1
[statements]
[Exit For]
[statements]
Next [counter]
如1：
For Words = 10 To 1 Step -1    &lsquo; 建立 10 次循环
For Chars = 0 To 9     &rsquo; 建立 10 次循环
MyString = MyString &amp; Chars   &lsquo; 将数字添加到字符串中
Next Chars       &rsquo; Increment counter
MyString = MyString &amp; &ldquo; &rdquo;   &lsquo; 添加一个空格
Next Words 2）For Each…Next语句:主要功能是对一个数组或集合对象进行，让所有元素重复执行一次语句 For Each element In group
Statements
[Exit for]
Statements
Next [element]
如1：
For Each rang2 In range1
With range2.interior
.colorindex=6
.pattern=xlSolid
End with
Next
这上面一例中用到了 With…End With 语句，目的是省去对象多次调用，加快速度；语法为：
With object
[statements]
End With 3）Do…loop语句 在条件为true时，重复执行区块命令 Do {while |until} condition  &rsquo; while 为当型循环，until为直到型循环，顾名思义，不多说啦
Statements
Exit do
Statements
Loop
或者使用下面语法
Do        &lsquo; 先do 再判断，即不论如何先干一次再说
Statements
Exit do
Statements
Loop {while |until} condition   10,其他类语句和错误语句处理 A, 其他循环语句:结构化程序使用以上判断和循环语句已经足够，建议不要轻易使用下面的语句，虽然VBA还支持。 1)Goto line 该语句为跳转到line语句行 2)On expression gosub destinatioinlist 或者 on expression goto destinationlist 语句为根据 exprssion表达式值来跳转到所要的行号或行标记 3)Gosub line…line…Return语句， Return 返回到 Gosub line行，如下例： Sub gosubtry()
Dim num
Num=inputbox(“输入一个数字，此值将会被判断循环”)
If num>0 then Gosub Routine1 ：Debug.print num：Exit sub
Routine1:
Num=num/5
Return
End sub 4)while…wend语句，只要条件为TRUE，循环就执行，这是以前VB老语法保留下来的，如下例： while condition 'while I&lt;50 [statements] 'I=I+1 wend 'Wend B, 错误语句处理:执行阶段有时会有错误的情况发生，利用On Error语句来处理错误，启动一个错误的处理程序。语法如下： On Error Goto Line　　　'当错误发生时，会立刻转移到line行去
On Error Resume Next  '当错误发生时，会立刻转移到发生错误的下一行去
On Erro Goto 0    '当错误发生时，会立刻停止过程中任何错误处理过程   11,过程和函数 过程是构成程序的一个模块，往往用来完成一个相对独立的功能。过程可以使程序更清晰、更具结构性。VBA具有四种过程：Sub 过程、Function函数、Property属性过程和Event事件过程。 A, Sub过程:Sub 过程的参数有两种传递方式：按值传递(ByVal)和按地址传递(ByRef)。如下例：  B, Function函数:函数实际是实现一种映射，它通过一定的映射规则，完成运算并返回结果。参数传递也两种：按值传递(ByVal)和按地址传递(ByRef)。如下例： Function password(ByVal x as integer, byref y as integer) as boolean
If y=100 then y=x+y else y=x-y
x=x+100
if y=150 then password=true else password=false
End Function
Sub call_password ()
Dim x1 as integer
Dim y1 as integer
x1=12
y1=100
if password then ‘调用函数：1. 作为一个表达式放在=右端 ; 2. 作为参数使用
debug.print x1
end if
End sub C, Property属性过程和Event事件过程:这是VB在对象功能上添加的两个过程，与对象特征密切相关，也是VBA比较重要组成，技术比较复杂，可以参考相关书籍。   12,内部函数 在VBA程序语言中有许多内置函数，可以帮助程序代码设计和减少代码的编写工作。 A．测试函数
IsNumeric(x)         ‘是否为数字, 返回Boolean结果，True or False
IsDate(x)          ‘是否是日期, 返回Boolean结果，True or False
IsEmpty（x）         ‘是否为Empty, 返回Boolean结果，True or False
IsArray(x)           ‘指出变量是否为一个数组。
IsError(expression)        ‘指出表达式是否为一个错误值
IsNull(expression)        ‘指出表达式是否不包含任何有效数据 (Null)。
IsObject(identifier)        ‘指出标识符是否表示对象变量
B．数学函数
Sin(X)、Cos(X)、Tan(X)、Atan(x) 三角函数，单位为弧度
Log(x) 返回x的自然对数
Exp(x)返回 ex
Abs(x) 返回绝对值
Int(number)、Fix(number) 都返回参数的整数部分，区别：Int 将 -8.4 转换成 -9，而 Fix 将-8.4 转换成 -8
Sgn(number) 返回一个 Variant (Integer)，指出参数的正负号
Sqr(number) 返回一个 Double，指定参数的平方根
VarType(varname) 返回一个 Integer，指出变量的子类型
Rnd（x）返回0-1之间的单精度数据，x为随机种子
C．字符串函数
Trim(string)         去掉string左右两端空白
Ltrim(string)         去掉string左端空白
Rtrim(string)         去掉string右端空白
Len(string)         计算string长度
Left(string, x)       取string左段x个字符组成的字符串
Right(string, x)       取string右段x个字符组成的字符串
Mid(string, start,x)     取string从start位开始的x个字符组成的字符串
Ucase(string)         转换为大写
Lcase(string)         转换为小写
Space(x)         返回x个空白的字符串
Asc(string)         返回一个 integer，代表字符串中首字母的字符代码
Chr(charcode)        返回 string，其中包含有与指定的字符代码相关的字符
D．转换函数
CBool(expression)      转换为Boolean型
CByte(expression)       转换为Byte型
CCur(expression)       转换为Currency型
CDate(expression)       转换为Date型
CDbl(expression)       转换为Double型
CDec(expression)       转换为Decemal型
CInt(expression)       转换为Integer型
CLng(expression)       转换为Long型
CSng(expression)       转换为Single型
CStr(expression)       转换为String型
CVar(expression)       转换为Variant型
Val(string)         转换为数据型
Str(number)        转换为String
E．时间函数
Now     返回一个 Variant (Date)，根据计算机系统设置的日期和时间来指定日期和时间。
Date     返回包含系统日期的 Variant (Date)。
Time   返回一个指明当前系统时间的 Variant (Date)。
Timer     返回一个 Single，代表从午夜开始到现在经过的秒数。
TimeSerial(hour, minute, second) 返回一个 Variant (Date)，包含具有具体时、分、秒的时间。
DateDiff(interval, date1, date2[, firstdayofweek[, firstweekofyear]])
返回 Variant (Long) 的值，表示两个指定日期间的时间间隔数目
Second(time) 返回一个 Variant (Integer)，其值为 0 到 59 之间的整数，表示一分钟之中的某个秒
Minute(time) 返回一个 Variant (Integer)，其值为 0 到 59 之间的整数，表示一小时中的某分钟
Hour(time)   返回一个 Variant (Integer)，其值为 0 到 23 之间的整数，表示一天之中的某一钟点
Day(date)   返回一个 Variant (Integer)，其值为 1 到 31 之间的整数，表示一个月中的某一日
Month(date)   返回一个 Variant (Integer)，其值为 1 到 12 之间的整数，表示一年中的某月
Year(date)   返回 Variant (Integer)，包含表示年份的整数。
Weekday(date, [firstdayofweek]) 返回一个 Variant (Integer)，包含一个整数，代表某个日期是星期几   13, 文件操作 1）文件 Dir[(pathname[, attributes])] ；pathname 可选参数，用来指定文件名的字符串表达式，可能包含目录或文件夹、以及驱动器。如果没有找到 pathname，则会返回零长度字符串 (&ldquo;&rdquo;); attributes 可选参数。常数或数值表达式，其总和用来指定文件属性。如果省略，则会返回匹配 pathname 但不包含属性的文件。 2）删除 Kill pathname 从磁盘中删除文件, pathname 参数是用来指定一个文件名 RmDir pathname 从磁盘中删除删除目录，pathname 参数是用来指定一个文件夹 3）打开 Open pathname For mode [Access access] [lock] As [#]filenumber [Len=reclength] 能够对文件输入/输出 (I/O)。 pathname 必要。字符串表达式，指定文件名，该文件名可能还包括目录、文件夹及驱动器。 mode 必要。关键字，指定文件方式，有 Append、Binary、Input、Output、或 Random 方式。如果未指定方式，则以 Random 访问方式打开文件。 access 可选。关键字，说明打开的文件可以进行的操作，有 Read、Write、或 Read Write 操作。 lock 可选。关键字，说明限定于其它进程打开的文件的操作，有 Shared、Lock Read、Lock Write、和 Lock Read Write 操作。 filenumber 必要。一个有效的文件号，范围在 1 到 511 之间。使用 FreeFile 函数可得到下一个可用的文件号。 reclength 可选。小于或等于 32，767（字节）的一个数。对于用随机访问方式打开的文件，该值就是记录长度。对于顺序文件，该值就是缓冲字符数。说明 对文件做任何 I/O 操作之前都必须先打开文件。Open 语句分配一个缓冲区供文件进行 I/O 之用，并决定缓冲区所使用的访问方式。如果 pathname 指定的文件不存在，那么，在用 Append、Binary、Output、或 Random 方式打开文件时，可以建立这一文件。如果文件已由其它进程打开，而且不允许指定的访问类型，则 Open 操作失败，而且会有错误发生。如果 mode 是 Binary 方式，则 Len 子句会被忽略掉。 重要 在 Binary、Input 和 Random 方式下可以用不同的文件号打开同一文件，而不必先将该文件关闭。在 Append 和 Output 方式下，如果要用不同的文件号打开同一文件，则必须在打开文件之前先关闭该文件。 4）读入 Input #filenumber, varlist 从已打开的顺序文件中读出数据并将数据指定给变量 Get [#]filenumber, [recnumber], varname将一个已打开的磁盘文件读入一个变量之中。 5）写入 Write #filenumber, [outputlist] 将数据写入顺序文件 Print #filenumber, [outputlist] 将格式化显示的数据写入顺序文件中 Put [#]filenumber, [recnumber], varname 将一个变量的数据写入磁盘文件中。 6）关闭 Close [filenumberlist] 关闭 Open 语句所打开的输入/输出 (I/O) 文件 注意 如果今后想用 Input # 语句读出文件的数据，就要用 Write # 语句而不用 Print # 语句将数据写入文件。因为在使用 Write # 时，将数据域分界就可确保每个数据域的完整性，因此可用 Input # 再将数据读出来。使用 Write # 还能确保任何地区的数据都被正确读出。Write 与 Print # 语句不同，当要将数据写入文件时，Write # 语句会在项目和用来标记字符串的引号之间插入逗号。Write # 语句在将 outputlist 中的最后一个字符写入文件后会插入一个新行字符，即回车换行符，(Chr(13) + Chr(10))。 7）其他文件函数 LOF(filenumber) 返回一个 Long，表示用 Open 语句打开的文件的大小，该大小以字节为单位。 EOF(filenumber) 返回一个 Integer，它包含 Boolean 值 True，表明已经到达为 Random 或顺序 Input 打开的文件的结尾。 Loc(filenumber) 返回一个 Long，在已打开的文件中指定当前读/写位置 Seek(filenumber) 返回一个 Long，在 Open 语句打开的文件中指定当前的读/写位置</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/30/160444/">解析java源文件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-30T16:04:44+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>4:04 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>尝试从java源文件中解析出类、方法、属性等信息，但下面的代码没有完全实现。</p>

<p>Sub parseJava()
  Dim package_name as String
  &lsquo;read a file
  Documents.Open FileName:=&ldquo;f:\CommandCm.java&rdquo;, ConfirmConversions:=False, ReadOnly:=True
  paraNo = ActiveDocument.Paragraphs.Count
  For lineNo = 1 To paraNo
   Set curParaWords = ActiveDocument.Paragraphs(lineNo).Range.Words
   Dim strCurPara as String
   strCurPara = ActiveDocument.Paragraphs(lineNo).Range.Text
   If InStr(strCurPara, &ldquo;package&rdquo;)=1 Then
    '包名是package后、分号前的部分
    tmpStr = Right(strCurPara,Len(strCurPara)-Len(&ldquo;package&rdquo;)-1)
    package_name = Left(tmpStr, Len(tmpStr)-2)
   End If
   If InStr(strCurPara, &ldquo;public class&rdquo;)=1 Then
    '类名是这一行的第三个单词，且不含末尾空格
    class_name = RTrim(curParaWords(3).Text)
   End If
   If InStr(strCurPara, &ldquo;public interface&rdquo;)=1 Then
    '接口名是这一行的第三个单词，且不含末尾空格
    class_name = RTrim(curParaWords(3).Text)
   End If
   Select Case curParaWords(2).Text
   Case &ldquo;public&rdquo;</p>

<p>   Case &ldquo;private&rdquo;
   Case &ldquo;protected&rdquo;
   Case Else
   End Case
   If curParaWords(2)=&ldquo;public&rdquo; Then
    &lsquo;接口名是这一行的第三个单词，且不含末尾空格
    class_name = RTrim(ActiveDocument.Paragraphs(lineNo).Range.Words(3).Text)
   End If
  Next lineNo
  ActiveDocument.Close
End Sub</p>

<p> 下面是业务逻辑：</p>

<p>数据结构：</p>

<p> 类相关数据表ClassInfo（Map）</p>

<p> key: name, description, class_name, package, extends, interface;</p>

<p>属性数据表PropInfo（List<Map>）</p>

<p>方法数据表MethodInfo（List<Map>）</p>

<p>文本格式约定：</p>

<p>顶格、package起首代码行为package声明行；</p>

<p>顶格、public class起首的代码行是类声明行；</p>

<p> 顶格、 public  interface起首的代码行是接口声明行；</p>

<p> 一个tab后跟public、private、protected是方法或者属性</p>

<p> 有左括号的是方法， 左括号前单词是方法名，方法名前是返回值的数据类型；</p>

<p> 无左括号 的是 属性，等号左边单词是属性名，若无等号分号前单词是属性名，若都没有输出一条 “文件名：行号：异常属性/方法，手工提取” 提示；</p>

<p> 一个tab后跟其他字母 输出一条“文件名：行号：异常属性/方法，手工提取”提示；</p>

<p> 一个tab后跟非字母符号（如/*是注释，@是编译标志）略过；</p>

<p>流程：</p>

<p> 用户输入目标目录</p>

<p> 将文件名保存在ClassInfo.name和class_name中；</p>

<p> 加载该目录下所有java文件， 对于一个java文件：</p>

<p>第一次文本逐行读取：提取除方法/属性说明外所有信息；</p>

<p>第二次文本逐行读取：寻找以“* 方法名”开始的行，作为方法说明，放入对应的方法Map中；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/23/125605/">Java程序员的推荐阅读书籍</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-23T12:56:05+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2010</span></span> <span class='time'>12:56 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>作为Java程序员来说，最痛苦的事情莫过于可以选择的范围太广，可以读的书太多，往往容易无所适从。我想就我自己读过的技术书籍中挑选出来一些，按照学习的先后顺序，推荐给大家，特别是那些想不断提高自己技术水平的Java程序员们。</p>

<p>在这份推荐阅读书籍的名单中，我没有列举流行的软件框架类学习书籍，例如Struts，Hibernate，Spring之类，也没有列举AJAX方面的书籍。是因为这类书籍容易过时，而上述的大半书籍的生命周期都足够长，值得你去购买和收藏。</p>

<p>Java编程入门类
对于没有Java编程经验的程序员要入门，随便读什么入门书籍都一样，这个阶段需要你快速的掌握Java基础语法和基本用法，宗旨就是“囫囵吞枣不求甚解”，先对Java熟悉起来再说。用很短的时间快速过一遍Java语法，连懵带猜多写写代码，要“知其然”。</p>

<p>1、《Java编程思想》</p>

<p>在有了一定的Java编程经验之后，你需要“知其所以然”了。这个时候《Java编程思想》是一本让你知其所以然的好书，它对于基本的面向对象知识有比较清楚的交待，对Java基本语法，基本类库有比较清楚的讲解，可以帮你打一个良好的Java编程基础。这本书的缺点是实在太厚，也比较罗嗦，不适合现代人快节奏学习，因此看这本书要懂得取舍，不是每章每节都值得一看的，挑重点的深入看就可以了。</p>

<p>2、《Agile Java》中文版</p>

<p>这本书是出版社送给我的，我一拿到就束之高阁，放在书柜一页都没有翻过，但是前两天整理书柜的时候，拿出来一翻，竟然发现这绝对是一本好书！这本书一大特点是以单元测试和TDD来贯穿全书的，在教你Java各种重要的基础知识的过程中，潜移默化的影响你的编程思维走向敏捷，走向TDD。另外这本书成书很新，以JDK5.0的语法为基础讲解，要学习JDK5.0的新语法也不错。还有这本书对于内容取舍也非常得当，Java语言毕竟类库庞大，可以讲的内容太多，这本书选择的内容以及内容的多寡都很得当，可以让你以最少的时间掌握Java最重要的知识，顺便培养出来优秀的编程思路，真是一本不可多得的好书。</p>

<p>虽然作者自己把这本书定位在入门级别，但我不确定这本书用来入门是不是稍微深了点。
Java编程进阶类
打下一个良好的Java基础，还需要更多的实践经验积累，我想没有什么捷径。有两本书值得你在编程生涯的这个阶段阅读，培养良好的编程习惯，提高你的代码质量。</p>

<p>1、《重构 改善既有代码的设计》</p>

<p>这本书名气很大，不用多介绍，可以在闲暇的时候多翻翻，多和自己的实践相互印证。这本书对你产生影响是潜移默化的。</p>

<p>2、《测试驱动开发 by Example》</p>

<p>本书最大特点是很薄，看起来没有什么负担。你可以找一个周末的下午，一边看，一边照做，一个下午就把书看完，这本书的所有例子跑完了。这本书的作用是通过实战让你培养TDD的思路。
Java架构师之路
到这个阶段，你应该已经非常娴熟的运用Java编程，而且有了一个良好的编程思路和习惯了，但是你可能还缺乏对应用软件整体架构的把握，现在就是你迈向架构师的第一步。</p>

<p>1、《Expert One-on-One J2EE Design and Development》</p>

<p>这本书是Rod Johnson的成名著作，非常经典，从这本书中的代码诞生了springframework。但是好像这本书没有中译本。</p>

<p>2、《Expert One-on-One J2EE Development without EJB》</p>

<p>这本书由gigix组织翻译，多位业界专家参与，虽然署名译者是JavaEye，其实JavaEye出力不多，实在是忝居译者之名。</p>

<p>以上两本书都是Rod Johnson的经典名著，Java架构师的必读书籍。在我所推荐的这些书籍当中，是我看过的最仔细，最认真的书，我当时读这本书几乎是废寝忘食的一气读完的，有小时候挑灯夜读金庸武侠小说的劲头，书中所讲内容和自己的经验知识一一印证，又被无比精辟的总结出来，读完这本书以后，我有种被打通经脉，功力爆增的感觉。</p>

<p>但是后来我看过一些其他人的评价，似乎阅读体验并没有我那么high，也许是因为每个人的知识积累和经验不同导致的。我那个时候刚好是经验知识积累已经足够丰富，但是还没有系统的整理成型，让这本书一梳理，立刻形成完整的知识体系了。</p>

<p>3、《企业应用架构模式》</p>

<p>Martin的又一本名著，但这本书我只是泛泛的看了一遍，并没有仔细看。这本书似乎更适合做框架的人去看，例如如果你打算自己写一个ORM的话，这本书是一定要看的。但是做应用的人，不看貌似也无所谓，但是如果有空，我还是推荐认真看看，会让你知道框架为什么要这样设计，这样你的层次可以晋升到框架设计者的角度去思考问题。Martin的书我向来都是推崇，但是从来都没有像Rod Johnson的书那样非常认真去看。</p>

<p>4、《敏捷软件开发 原则、模式与实践》</p>

<p>Uncle Bob的名著，敏捷的经典名著，这本书比较特别，与其说是讲软件开发过程的书，不如说讲软件架构的书，本书用了很大篇幅讲各种面向对象软件开发的各种模式，个人以为看了这本书，就不必看GoF的《设计模式》了。</p>

<p>软件开发过程
了解软件开发过程不单纯是提高程序员个人的良好编程习惯，也是增强团队协作的基础。</p>

<p>1、《UML精粹》</p>

<p>UML其实和软件开发过程没有什么必然联系，却是软件团队协作沟通，撰写软件文档需要的工具。但是UML真正实用的图不多，看看这本书已经足够了，完全没有必要去啃《UML用户指南》之类的东西。要提醒大家的是，这本书的中译本翻译的非常之烂，建议有条件的看英文原版。</p>

<p>2、《解析极限编程 拥抱变化》XP</p>

<p>这是Kent Beck名著的第二版，中英文对照。没什么好说的，必读书籍。</p>

<p>3、《统一软件开发过程》UP</p>

<p>其实UP和敏捷并不一定冲突，UP也非常强调迭代，测试，但是UP强调的文档和过程驱动却是敏捷所不取的。不管怎么说，UP值得你去读，毕竟在中国真正接受敏捷的企业很少，你还是需要用UP来武装一下自己的，哪怕是披着UP的XP。</p>

<p>4、《敏捷建模》AM</p>

<p>Scott Ambler的名著，这本书非常的progmatic，告诉你怎么既敏捷又UP，把敏捷和UP统一起来了，又提出了很多progmatic的建议和做法。你可以把《解析极限编程 拥抱变化》、《统一软件开发过程》和《敏捷建模》这三本书放在一起读，看XP和UP的不同点，再看AM是怎么统一XP和UP的，把这三种理论融为一炉，形成自己的理论体系，那么你也可以去写书了。</p>

<p>软件项目管理
如果你突然被领导提拔为项目经理，而你完全没有项目管理经验，你肯定会心里没底；如果你觉得自己管理项目不善，很想改善你的项目管理能力，那么去考PMP肯定是远水不解近渴的。</p>

<p>1、《快速软件开发》</p>

<p>这也是一本名著。可以这样说，有本书在手，你就有了一个项目管理的高级参谋给你出谋划策，再也不必担心自己不能胜任的问题了。这本书不是讲管理的理论的，在实际的项目管理中，讲这些理论是不解决问题的，这本书有点类似于“软件项目点子大全”之类的东西，列举了种种软件项目当中面临的各种问题，以及应该如何解决问题的点子，你只需要稍加变通，找方抓药就行了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/22/155159/">TotalCommander的两款目录插件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-22T15:51:59+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2010</span></span> <span class='time'>3:51 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>CatalogMaker 与 DiskDir Extended 是两个用于生成文件夹目录的totalCmd插件。 将指定目录下所有文件、文件夹以指定格式存储在一个文本文件中，可作为EverCD+的轻量级替代品。
安装：
在TotalCmd中双击zip文件，tc会提示是否安装插件，确认后一路按默认安装即可。</p>

<p>使用：
选中要生成目录结构的文件夹，按alt+F5，【压缩格式】中在下拉框里选lst，然后点【配置】，设置输出格式后确认，在对面目录下生成一个lst文件，实际就是一个纯文本文件。</p>

<p>二者比较：</p>

<p>catalogmaker生成的目录更易读，但diskdirextended能够读出压缩包里的文件列表，二者各有优缺点。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/106">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/104">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/11/123934/">Share One Users Collection Between Multiple Meteor Apps</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/07/155721/">Autopubsh and Insecure Package in Meteor</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/05/125922/">Meteor实施案例</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/02/113417/">Meteor Development Collaboration</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/31/160627/">Chinese Characters Can't Be Displayed Correctly in Git Log</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
