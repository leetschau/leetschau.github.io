
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="$ hg init hgBranchTest // 新建一个名为hgBranchTest的repo，hg自动创建目录 $ cd hgBranchTest $ vi readme.txt $ cat readme.txt
this is the first version $ hg add &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/64/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A notes repository for Meteor.js, data mining, Linux, etc.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="leetschau.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/22/131818/">Hg单用户操作的分支合并</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-22T13:18:18+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2013</span></span> <span class='time'>1:18 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>$ hg init hgBranchTest // 新建一个名为hgBranchTest的repo，hg自动创建目录</p>

<p>$ cd hgBranchTest</p>

<p>$ vi readme.txt</p>

<p>$ cat readme.txt
this is the first version</p>

<p>$ hg add readme.txt
$ hg ci -m &ldquo;first time commit&rdquo; // or use &ldquo;hg ci -A -m &hellip;&rdquo; for add and commit
$ vi readme.txt
$ cat readme.txt
this is the first version
add a line
$ hg st
M readme.txt
$ hg log
修改集:  0:ffecf69346a5
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit
$ hg diff
diff -r ffecf69346a5 readme.txt
&mdash; a/readme.txt  Mon Apr 22 05:49:29 2013 +0100
+++ b/readme.txt  Mon Apr 22 05:51:03 2013 +0100
@@ -1,1 +1,2 @@
this is the first version
+add a line
$ hg ci -m &ldquo;第二次提交&rdquo;
$ hg log
修改集:  1:770a5cda1659
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
修改集:  0:ffecf69346a5
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit
$ hg branch
default
$ hg branches
default      1:770a5cda1659
$ hg branch red
marked working directory as branch red
(branches are permanent and global, did you want a bookmark?)
$ vi readme.txt
$ cat readme.txt
this is the first version
add a line
add the 3rd line
$ hg branches   // 没有提交（commit）之前分支不出现在branches列表中
default      1:770a5cda1659
$ hg branch   // 当前仍在red分支下
red
$ hg ci -m &ldquo;commit on branch red&rdquo;
$ hg branches
red       2:86e30b1564a9
default      1:770a5cda1659 (inactive)
$ hg log
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
修改集:  1:770a5cda1659
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
修改集:  0:ffecf69346a5
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit
$ hg log -b red // 只显示red分支上的changeset
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
$ hg tip  // tip是最近版本的意思
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
$ hg heads  // head表示各分支最近版本
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
修改集:  1:770a5cda1659
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
$ hg up default   // 切换当前分支为default
1 files updated, 0 files merged, 0 files removed, 0 files unresolved
$ cat readme.txt  // 分支合并前文件内容
this is the first version
add a line
$ hg merge red
1 files updated, 0 files merged, 0 files removed, 0 files unresolved
(branch merge, don&rsquo;t forget to commit)
$ cat readme.txt  // 合并后文件内容改变
this is the first version
add a line
add the 3rd line
$ hg st
M readme.txt
$ hg ci -m &ldquo;after merge with branch red&rdquo;
$ hg log
修改集:  3:9a5f0a2b7b9c
标签:  tip
父亲:  1:770a5cda1659 // 合并后提交的版本的特点是有两个parent
父亲:  2:86e30b1564a9
用户:  Li Chao
日期:  Mon Apr 22 06:00:31 2013 +0100
摘要:  after merge with branch red
修改集:  2:86e30b1564a9
分支:  red
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
修改集:  1:770a5cda1659
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
修改集:  0:ffecf69346a5
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/20/105251/">局域网聊天和文件传输工具</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-20T10:52:51+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>10:52 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>以前用飞秋在局域网内聊天、传文件，经常找不到目标，很难用，在网上找了一个开源、跨平台（Win, Linux &amp; Mac）的局域网聊天软件<a href="http://lanmsngr.sourceforge.net/">LAN Messenger</a>，以及<a href="http://portableapps.com/apps/internet/lan-messenger-portable">Portable版</a>，下载的文件是便携版LANMessengerPortable_1.2.35.paf.exe，聊天、传文件、群聊的功能都有，很方便。</p>

<p>LANMessenger在Mint上安装后无法正常运行，发现Linux上的iptux（apt-get install iptux）实际山就是Windows上的FeiQ（下载压缩包FeiQ.rar后解压运行），目前工作良好。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/17/111523/">基于ScheduledExecutorService的并发定时任务处理能力测试</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-17T11:15:23+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>11:15 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>测试代码</h1>

<h2>定时器类</h2>

<p> package business.util;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 import transfer.IUserParser;
 public class MyTimer {
  private static ScheduledExecutorService ses = Executors
    .newSingleThreadScheduledExecutor();</p>

<p>   // .newScheduledThreadPool(10);
  private MyTimer() {
  }
  /<strong>
   * 设置某一parser正在执行脚本的超时时间
   *
   * @param parser
   *   进行超时控制的解析器
   * @param timeout
   *   超时时间，单位：秒
   * @return
   */
  public static ScheduledFuture&lt;?> set(IUserParser parser, int timeout) {
   CloseRutine routine = new CloseRutine(parser);
   ScheduledFuture&lt;?> job = ses.schedule(routine, timeout,
     TimeUnit.SECONDS);
   return job;
  }
  /</strong>
   * 清除计时器
   *
   * @param unit
   * @return
   <em>/
  public static boolean cancel(ScheduledFuture&lt;?> job) {
   return job.cancel(true);
  }
  /**
   * 关闭此计时器（进程）
   </em>/
  public static void shutdown() {
   ses.shutdown();
  }
 }
 class CloseRutine implements Runnable {
  private final IUserParser parser;
  CloseRutine(IUserParser parser) {
   this.parser = parser;
  }
  @Override
  public void run() {
   parser.closePeer();
  }
 }</p>

<h1>#</h1>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/16/120452/">Java语言子类调用父类构造函数的规则</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-16T12:04:52+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:04 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>子类初始化时，调用父类构造函数的规则是：如果父类没有任何构造函数，系统会</p>

<ul>
<li><p>父类如果没有任何构造函数，系统会自动为父类生成一个无参构造函数，如果父类有带参构造函数，系统不会为父类生成无参构造函数；</p></li>
<li><p>如果父类和子类的构造函数都有参数且参数列表一样（包括参数的个数、类型、顺序），子类如果想调用父类的构造方法，必须在构造函数第一行用super(params)显式调用，否则子类的构造函数会去找父类的默认（无参）构造函数；</p></li>
<li><p>如果父类有无参构造函数，子类的构造函数除非显式用super(params)调用父类的带参构造函数，否则一定会执行父类的无参构造函数（不需要写super()）；</p></li>
</ul>


<p>参考：google &ldquo;java constructor&rdquo;, <a href="http://www.leepoint.net/notes-java/oop/constructors/constructor.html">http://www.leepoint.net/notes-java/oop/constructors/constructor.html</a></p>

<h1>父类有默认构造函数时</h1>

<p> class SuperClass {
  public SuperClass() {
   System.out.println(&ldquo;I am the super class.&rdquo;);
  }
  public SuperClass (String name) {
   System.out.println(&ldquo;I am the super class with a name: &rdquo; + name);
  }</p>

<p>  public SuperClass (int age) {
   System.out.println(&ldquo;I am sub class with age: &rdquo; + age);
  }</p>

<p> }
 public class TestedSubClass extends SuperClass {
  public TestedSubClass(){
   System.out.println(&ldquo;I am sub class&rdquo;);
  }
  public TestedSubClass(String name){
   super(name);
   System.out.println(&ldquo;I am sub class with a name: &rdquo; + name);
  }
  public TestedSubClass(int age) {
   System.out.println(&ldquo;I am sub class with age: &rdquo; + age);
  }</p>

<p>  public static void main(String[] args) {
   TestedSubClass tsc = new TestedSubClass();
   TestedSubClass tsc2 = new TestedSubClass(&ldquo;chad&rdquo;);
   TestedSubClass tsc3 = new TestedSubClass(33);
  }
 }</p>

<p>运行结果：</p>

<p> [java] I am the super class.
 [java] I am sub class
 [java] I am the super class with a name: chad
 [java] I am sub class with a name: chad
 [java] I am the super class.
 [java] I am sub class with age: 33</p>

<p>当父类有默认（无参数）构造函数情况下，子类初始化时，除非子类用super(param)显式调用其他构造函数，否则一定会执行父类的默认构造函数，不论子类初始化时有没有参数。</p>

<h1>父类无默认构造函数</h1>

<p>如果仅将父类的默认（无参）构造函数去掉重新运行，报找不到初始化方法错误，原因是当父类有带参构造函数时，系统不为父类生成构造函数，而第1次和第3次初始化子类对象时，会调用父类的无参构造方法，所以报错；</p>

<p>如果去掉父类中所有的构造函数，子类中保留无参和int参数两个构造函数，运行正常；</p>

<p>如果仅保留父类和子类的String参数构造方法，初始化运行正常；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/07/230132/">Sublime Text笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-07T23:01:32+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>11:01 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Sublime Text作为一款文本编辑器，最强大的是快速响应能力和"Goto Anything"功能，用Ctrl+Shift+P执行编辑器功能，用Ctrl+P+@进行文件间与文件内部的跳转，目前的编辑器还没有类似的，Vintage将vi的强大编辑能力吸收了进来，更是如虎添翼。</p>

<p>它不适合作为静态语言（如Java）的正式开发IDE，与“标准的”IDE（如Eclipse）比较，它不具备针对静态语言的代码重构功能；在代码自动补全方面，无法提供类库的类名/方法补全（能够提供语言关键字和变量的补全）；它无法提供调试环境，需要单独的代码调试器（如JSwat）。所以Sublime Text适合作为展现语言（如HTML，Latex等）或者动态语言（Python, PHP等）的开发工具。</p>

<p>但很多时候我们只是想浏览代码，或是写一些简单的试验程序，或是修改代码的一处细节，启动Eclipse太慢了，用Sublime text这样text editor处理正合适。</p>

<h1>借助Ant打造Java IDE</h1>

<p>项目目录结构：项目根目录（$PORJ_HOME）下存放源代码、编译后的class文件和需要引用的jar包（而不是分开放在src, bin, lib文件夹下，适合于技术验证式的小项目），以及sublime项目定义文件（ProjectName.sublime-project）和build.xml，通过Ant的javac和java指令编译和运行Java代码，源代码不论什么包名都放在$PORJ_HOME下（Ant的javac指令会根据源代码的包名创建class文件的目录结构）；</p>

<h2>准备工作</h2>

<ol>
<li><p>指定用Ant做构建工具：修改[Preferences -> Browse Packages]打开packages文件夹，修改Java/JavaC.sublime-build文件，将原来"cmd"后面的"javac"改为"ant.bat"，如果ant所在目录没有加到系统的$Path里，这里需要写文件完整路径，例如"D:/Apps/apache-ant-1.8.1/bin/ant.bat"，然后将工作目录设置为项目根目录（默认的就是项目文件所在目录，因此这句不写也行）："working_dir": &ldquo;$project_path"；</p></li>
<li><p>安装AdvancedNewFile插件：利用package control的install new package功能，装完后就可以用快捷键"Ctrl + Alt + N"在项目根目录下创建文件了；</p></li>
</ol>


<h2>创建Java项目</h2>

<ol>
<li><p>创建项目文件夹（TotalCMD），拷贝此文件夹的完整路径；</p></li>
<li><p>Sublime Text -> Project -> Add Folder: 将上一步创建的文件夹加入到Project中；</p></li>
<li><p>生成新的Sublime项目文件：Sublime Text -> Project -> Save Project As，这样项目文件就定义好了，如果希望隐藏不必要的文件和文件夹：[Project -> Save Project As]，用file_exclude_patterns和folder_exclude_patterns属性实现，例如：</p></li>
</ol>


<p> {
  &ldquo;folders&rdquo;:
  [
   {
    &ldquo;path&rdquo;: &ldquo;/e/workspace/PNProject&rdquo;,</p>

<pre><code>"file_exclude_patterns": 
[ 
  "*.sublime*" 
] 
</code></pre>

<p>   }</p>

<p>  ]
 }</p>

<p>注：还可以用"folder_exclude_patterns":[&ldquo;build&rdquo;]这样的方式去掉文件夹。</p>

<ol>
<li>在项目根目录下新建一个build.xml文件，主要内容是编译和运行java代码（注意每个项目的启动类是不同的（java命令的classname参数），拷贝这个模板时需要修改）：</li>
</ol>


<p> &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
 <project name="ExProj" basedir="./" default="run">
  <path id="lib.path">
   <fileset dir="${basedir}">
    <include name="**/*.jar"/>
   </fileset>
  </path>
  <target name="compile">
   <javac srcdir="${basedir}" destdir="${basedir}"
    classpathref="lib.path" encoding="UTF-8" debug="true"/>
  </target>
  <target name="run" depends="compile">
   <java classname="org.leechau.HelloWorld">
    <classpath>
     <pathelement path="${basedir}"/>
    </classpath>
   </java>
  </target>
 </project></p>

<ol>
<li>运行构建：[Tools -> Build]（快捷键Ctrl+B）；</li>
</ol>


<h1>打开Vintage模式</h1>

<p>Vintage是vi风格的操作方式，当然要打开啦，方法是：</p>

<ol>
<li><p>在user preference里加上："ignored_packages": []</p></li>
<li><p>如果希望打开文档时初始状态是命令模式而不是插入模式，再加上："vintage_start_in_command_mode": true</p></li>
</ol>


<h1>自定义代码模板</h1>

<ol>
<li><p>[Tools -> New Snippet&hellip;];</p></li>
<li><p>填写模板内容（content），触发器（写完触发器按tab键展开为content中定义的代码）和有效范围（定义那些文件中此模板有效）；</p></li>
<li><p>保存模板文件：文件名统一约定为“范围名-触发器 .sublime-snippet”；</p></li>
</ol>


<p>参考<a href="http://www.granneman.com/webdev/editors/sublime-text/top-features-of-sublime-text/quickly-insert-text-and-code-with-sublime-text-snippets/#test">http://www.granneman.com/webdev/editors/sublime-text/top-features-of-sublime-text/quickly-insert-text-and-code-with-sublime-text-snippets/#test</a></p>

<p>实例：Java代码中终端打印语句的代码模板（spl + <Tab> -> System.out.println(${1});）：</p>

<p> <snippet>
  <content>&lt;![CDATA[
 System.out.println(${1});
 ]]></content>
  <!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
  <tabTrigger>spl</tabTrigger>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <scope>source.java</scope>
 </snippet></p>

<p>如果设置后不生效，检查各个标签的大小写是否正确（snippet文件是大小写敏感的），例如CDATA要大写，tabTrigger中T大写。</p>

<h1>Best Practice</h1>

<ul>
<li>所有的个性化配置都写在"Settings - User"，不要修改"Settings -> Default"；</li>
</ul>


<h1>Trouble Shooting</h1>

<ul>
<li><p>&ldquo;Decode error - output not utf-8&rdquo; when build java files: this is caused by adding &ldquo;"shell&rdquo;: true" in JavaC.sublime-build. cmd.exe use GBK(cp936) for console output encoding, which is different with sublime&rsquo;s default output encoding utf-8. So adding &ldquo;"encoding&rdquo;: &ldquo;cp936&rdquo;&ldquo; in JavaC.sublime-build will resolve this problem. Reference: <a href="http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=1535&amp;start=0">http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=1535&amp;start=0</a></p></li>
<li><p>Run Java without Ant: reference <a href="http://stackoverflow.com/questions/12030865/sublime-text-2-wont-run-java.">http://stackoverflow.com/questions/12030865/sublime-text-2-wont-run-java.</a> But when your java codes have package names, it&rsquo;s really difficult to compile and run them because package names are hardly get by sublime. So always use Ant to build java codes in sublime.</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/06/004608/">基于goagent的翻墙方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-06T00:46:08+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:46 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>本机上使用</h1>

<p><a href="http://www.hiadmin.org/shares/goagent-switchyplus">为Chrome 安装GoAgent并配上SwitchyPlus畅游互联网</a></p>

<p>Goagent的使用方式如下：</p>

<p>1、 申请一个Google App engine并创建一个appid（在申请的时候需要发送验证码到手机上面、所以手机号码一定得是真实的）</p>

<p>2、 申请到appid后下载GoAgent最新的程序</p>

<p>3、 将程序解压到硬盘上面、然后双击Serveruploader.bat文件、在弹出的界面中按照提示输入appid和你的Gmail 账号和密码。然后上传到服务端（如果出错多试几次）</p>

<p>4、 接着我们修改$GOAGENT_ROOT/local/proxy.ini文件、在[gae]配置项下面将appid=修改为你的appid，将[listen]下面的visible的值改为0，这样启动后最小化到托盘区；</p>

<p>5、 配置完成后我们可以直接运行Goagent.exe程序启动代理。是一个黑框框运行着的不要关掉</p>

<p>6、 打开谷歌浏览器、配置代理服务器IP:127.0.0.1 端口：8087</p>

<h1>作为局域网代理服务器</h1>

<p>将goagent部署在一台服务器上，其他机器上网时借助于这台服务器上的goagent，方法是：</p>

<ol>
<li><p>修改上面proxy.ini文件[listen]下的ip的值为0.0.0.0，port保持8087不变；</p></li>
<li><p>其他机器要借助于此服务器上网，将proxy的ip设为服务器的IP地址，端口号设为8087即可；</p></li>
<li><p>Ubuntu系统下可以定义系统级的代理服务器，这样使用apt-get这样的命令行下载也不受限制了，在 [System settings -> network -> network proxy]中设置；</p></li>
</ol>


<h1>修复403错误</h1>

<p>如果用goagent连接时浏览器报403错误，将$GOAGENT_HOME/local/proxy.ini中[gae]下面的profile值从google_cn改为google_hk即可；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/06/000709/">自动将Evernote笔记发布到博客上</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-06T00:07:09+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:07 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Evernote笔记要自动分享到博客还真不那么容易，借鉴<a href="https://arjw.wordpress.com/2011/08/25/of-the-note/#">Using Evernote to Post to WordPress</a>，申请了一个Wordpress帐号，点击dashboard左边的“控制板” -> My Blogs -> Post by Email下面的"Enable"按钮，会出现一个email地址，向这个地址发送邮件就可以发布博客了，可以先将写好的笔记保存在一个文件里，然后通过python的email模块向这个地址发邮件的方法实现自动发布博客，然后用evernote的local api将这个文件变成一个新笔记保存在数据库中。</p>

<p>对于现有的笔记，只能在菜单“笔记->分享->通过电子邮件发送”，填上Email地址的方法，刚才试验成功，但如果修改这个笔记重新发送一次，wordpress上不会覆盖原来的笔记，而是发一条新博文，还有一个问题是wordpress官网的<a href="http://wordpress.com">免费博客</a>虽然很好，但被GFW屏蔽了。</p>

<p><a href="http://aaditya.info/blog/2012/08/clipboard-to-email-python-code/">Clipboard to Email – Python Code</a>演示了如果将剪贴板里的内容通过email发送出去，也是一种解决问题的方法。</p>

<p>python 2.7.3 doc: <a href="http://docs.python.org/2/library/email-examples.html">18.1.11. email: Examples</a>有发送html文档的完整例子；</p>

<p>126和163也支持邮件发博客，用自己的邮箱发送到blogmail@188.com，可以用python的smtplib，通过smtp.163.com发送；</p>

<p>下面这个发送text邮件的实例在163博客上成功发布（sendmail方法如果返回一个空字典，说明发送成功）：</p>

<p> import smtplib
 # Import the email modules we&rsquo;ll need
 from email.mime.text import MIMEText
 # Create a text/plain message
 msg = MIMEText(&lsquo;this is a test blog from email&rsquo;)
 me = &lsquo;<a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#x6c;&#101;&#x65;&#x5f;&#x63;&#x68;&#97;&#117;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#111;&#109;">&#x6c;&#x65;&#x65;&#x5f;&#99;&#x68;&#x61;&#x75;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#109;</a>&rsquo;
 you = &lsquo;<a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#98;&#x6c;&#111;&#103;&#x6d;&#97;&#105;&#x6c;&#x40;&#x31;&#x38;&#x38;&#x2e;&#99;&#111;&#x6d;">&#98;&#x6c;&#x6f;&#103;&#109;&#97;&#x69;&#108;&#64;&#49;&#x38;&#56;&#x2e;&#99;&#x6f;&#x6d;</a>&rsquo;
 msg[&lsquo;Subject&rsquo;] = &lsquo;A Test Blog from Email&rsquo;
 msg[&lsquo;From&rsquo;] = me
 msg[&lsquo;To&rsquo;] = you
 # Send the message via our own SMTP server, but don&rsquo;t include the
 # envelope header.
 s = smtplib.SMTP(&lsquo;smtp.163.com&rsquo;)
 s.login(&lsquo;lee_chau&rsquo;, &lsquo;abaqus67&rsquo;)
 s.sendmail(me, [you], msg.as_string())
 s.quit()</p>

<hr />

<p>2013-04-13更新：</p>

<p>参考<a href="http://fun.blog.ustc.edu.cn/?p=148">从Evernote自动发博客到WordPress</a>，可以用<a href="https://eatags.com/">eatags.com</a>将笔记发布到wordpress.com上，设置好共享之后，要发布的笔记只要加上标签“ eat.wordpress.post ”（参考<a href="https://eatags.com/features%EF%BC%89%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E5%88%B0wordpress.com%E4%B8%8A%EF%BC%8C%E4%BB%8A%E5%A4%A9%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BB%93%E6%9E%9C%E5%8F%AF%E4%BB%A5%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%EF%BC%8C%E6%98%AF%E7%9B%AE%E5%89%8D%E6%89%80%E7%9F%A5%E6%9C%80%E5%A5%BD%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%88%96%E8%80%85%E7%94%A8">https://eatags.com/features%EF%BC%89%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E5%88%B0wordpress.com%E4%B8%8A%EF%BC%8C%E4%BB%8A%E5%A4%A9%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BB%93%E6%9E%9C%E5%8F%AF%E4%BB%A5%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%EF%BC%8C%E6%98%AF%E7%9B%AE%E5%89%8D%E6%89%80%E7%9F%A5%E6%9C%80%E5%A5%BD%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%88%96%E8%80%85%E7%94%A8</a><a href="http://www.evreblog.us">everblog.us</a>也能将evernote笔记发布到everblog.us网站上，但不能显示图片，everblog选中一个笔记本后会将该笔记本下所有的笔记都发布到everblog网站上，适合批量发布；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/01/150952/">NoClassDefFoundError与ClassNotFoundException的区别</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-01T15:09:52+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2013</span></span> <span class='time'>3:09 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>NoClassDefFoundError是一个Error，严重级别高，它导致JVM加载失败，通常是由于class loader在classpath中找不到被引用的class文件引起；</p>

<p>ClassNotFoundException是一个异常，严重级别低（相比于Error），通常在利用反射机制加载类时找不到指定的类引起，由于是异常，是可以被catch语句扑捉然后在代码中进行处理的。</p>

<p>参考：<a href="http://stackoverflow.com/questions/1457863/what-is-the-difference-between-noclassdeffounderror-and-classnotfoundexception">http://stackoverflow.com/questions/1457863/what-is-the-difference-between-noclassdeffounderror-and-classnotfoundexception</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/31/231152/">能够进行多段文本匹配的NFA改良算法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-03-31T23:11:52+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2013</span></span> <span class='time'>11:11 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>下面的代码基于NFA算法实现了在多段字符串中匹配正则表达式，对比NFA算法可以看到它将pc由局部变量提升为类成员，以保存中间匹配状态，另外在匹配成功后将pc恢复到null状态。实际使用中，此类还应该增加一个"reset"方法，将pc值置为null，以便用户可以显式要求重新开始匹配。</p>

<p> public class MultiSegmentNFA {
  private final Digraph G; // digraph of epsilon transitions
  private final String regexp; // regular expression
  private final int M; // number of characters in regular expression
  private Bag<Integer> pc = null;
  public MultiSegmentNFA(String regexp) {
   &hellip; // same as NFA
  }
  public boolean recognizes(String target) {
   if (pc == null) {
    DirectedDFS dfs = new DirectedDFS(G, 0);
    pc = new Bag<Integer>();
    for (int v = 0; v &lt; G.V(); v++)
     if (dfs.marked(v))
      pc.add(v);
   }
   for (int i = 0; i &lt; target.length(); i++) {
    Bag<Integer> match = new Bag<Integer>();
    for (int v : pc) {
     if (v == M)
      continue;
     if ((regexp.charAt(v) == target.charAt(i))
       || regexp.charAt(v) == &lsquo;.&rsquo;)
      match.add(v + 1);
    }
    DirectedDFS dfs = new DirectedDFS(G, match);
    pc = new Bag<Integer>();
    for (int v = 0; v &lt; G.V(); v++)
     if (dfs.marked(v))
      pc.add(v);
    if (pc.size() == 0)
     return false;
   }
   for (int v : pc)
    if (v == M) {</p>

<pre><code> pc = null; 
 return true;

} 
</code></pre>

<p>   return false;
  }</p>

<p>  public static void main(String[] args) {
   LinkedList<String> msgs = new LinkedList<String>();
   msgs.offer(&ldquo;welcome lonely logoout&rdquo;);
   msgs.offer(&ldquo;to flog&rdquo;);
   msgs.offer(&ldquo;into a fog&rdquo;);
   String token = &ldquo;outto&rdquo;;  // 这个目标由第1和第2个字符串拼接而成
   String pat = &ldquo;(.<em>&rdquo; + token + &ldquo;.</em>)&rdquo;;
   MultiSegmentNFA mnfa = new MultiSegmentNFA(pat);
   String target = msgs.poll();
   while (target != null) {
    if (mnfa.recognizes(target)) {
     break;
    }
    target = msgs.poll();
   }
   if (target == null) {
    System.out.println(&ldquo;cannot find &rdquo; + token + &ldquo; in msgs.&rdquo;);
   } else {
    System.out.println(&ldquo;find pat in &lt;&rdquo; + target + &ldquo;>&rdquo;);
   }
  }
 }</p>

<p>Note: Java的Pattern类使用的就是基于NFA的搜索算法，见JDK 6文档java.util.regex.Pattern的"Comparison to Perl 5"一节。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/03/31/215259/">NFA算法笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-03-31T21:52:59+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2013</span></span> <span class='time'>9:52 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>NFA(Nondeterministic finite-state automata)是一种在字符串中寻找正则表达式匹配的算法，优点是查找文本的指针不回退，适用于在网络传输的报文中寻找正则表达式描述的目标（因为网络传输中报文是被分段接收的，且分段的方式不确定），在Robert的"Algorithms"第5.4节"Regular Expressions"中有详细介绍。</p>

<p>NFA算法可以分为定义和执行两部分，定义阶段和执行阶段。</p>

<p>定义阶段是将要查找的正则表达式（String类型）转换为一个有向图（Digraph类型），该图中的边是所有可以进行的空转换（见p795倒数第2行），定义阶段在书中"Building an NFA corresponding to an RE"一节，图示见p803，代码见p802），在代码表现为以一个正则表达式字符串为参数的NFA构造函数；</p>

<p>执行阶段就是判断待处理的文本中是否含有目标正则表达式（见"Simulating an NFA"一节，图示见p798），整个过程是一个循环过程，每次循环待处理文本指针前进一个字符，这次循环由两步组成，首先根据当前正则表达式指针所处位置（最初位置都是0）算出所有空转换可达位置（借助深度优先算法DirectedDFS，可达位置保存在变量pc中），然后将所有可达位置上的字符与待处理文本指针处的字符比较，如果一样则把正则表达式指针的后一位保存在变量match中。然后以match为初始位置重新构造DirectedDFS对象，进而得到可达位置集合pc，然后从中筛选匹配上的位置，如此循环，直到待处理文本指针到达文本尾部，如果pc中有正则表达式长度的那个元素（代表匹配成功的位置，书中代码用类成员M表示），说明匹配正则表达式成功，否则失败。</p>

<p>需要说明的是，从所有可达状态pc中筛选匹配上位置并放入match中之前，需要先将值为M的元素去掉，以用"(A<em>B|AC)D"匹配"AABDC"为例，当目标文本指针等于4时，即指向"AABDC"的最后一个字符C时，pc中已经包含了最终状态11（正则串"((A</em>B|AC)D)&ldquo;的长度），因为AABD符合&rdquo;(A<em>B|AC)D"，但最后的C导致整个文本不匹配"(A</em>B|AC)D"，所以结果仍然是匹配失败。</p>

<p>测试代码如下：</p>

<p> String token = &ldquo;(A<em>B|AC)D&rdquo;;
 String regexp = &ldquo;(&rdquo; + token + &ldquo;)&rdquo;;
 // when test if target string &ldquo;contains&rdquo; regex, regexp = &ldquo;(.</em>&rdquo; + token + &ldquo;.*)&rdquo;
 NFA nfa = new NFA(regexp);
 String target = &ldquo;AABDC&rdquo;;
 if (nfa.recognizes(target)) {
  System.out.println(&ldquo;match: &rdquo; + target);
 } else {
  System.out.println(&ldquo;not match: &rdquo; + target);
 }</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/65">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/63">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/20/104508/">Clear Chrome DNS Cache</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/19/103131/">Linux的图形化Git客户端</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/02/093547/">Move Window Between Multiple Screens via Tmux</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/31/011200/">Synchronize Data From MongoDB to Elasticsearch</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/30/131706/">Elasticsearch River for MongoDB</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
