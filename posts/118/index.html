
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="使用java.io.BufferedInputStream.read(byte[])方法读取Socket中传过来的数据时，如果需要超时退出判断机制，一定要注意B ufferedInputStream.available()的使用。下面的代码片段是一个很标准的读取过程，其中第5行的判断很重要， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/118/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>The technical blog of Li Chao in Beijing</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="leetschau.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/20/085649/">使用输入流读取数据时的阻塞问题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-20T08:56:49+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:56 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>使用java.io.BufferedInputStream.read(byte[])方法读取Socket中传过来的数据时，如果需要超时退出判断机制，一定要注意B ufferedInputStream.available()的使用。下面的代码片段是一个很标准的读取过程，其中第5行的判断很重要，因为read( byte[] )方法本身是阻塞的，如果自始至终is没有收到任何数据，就会一直阻塞在read()方法上（第6行），导致整个超时判断机制失去作用，而 available()方法的使用避免了这种可能性。</p>

<p> 示例程序代码：</p>

<p> 01      try {   02           long startTime = System.currentTimeMillis();   03           while (someCriteria) {   04                byte[] cache = new byte[1024];   05                if (is.available() > 0) {   06                     int count = is.read(cache);   07                     if (count &lt;= 0) {   08                          if (System.currentTimeMillis() - startTime >= timeout) {   09                               throw new GapiException(&ldquo;Connection Time Out!&rdquo;);   10                          }   11                          continue;   12                     }   13                     // 后续处理   14                }   15                if (System.currentTimeMillis() - startTime >= timeout) {   16                     throw new GapiException(&ldquo;Connection Time Out!&rdquo;);   17                }   18                Thread.sleep(10);   19           }   20      } catch (Exception e) {   21           logger.error(&ldquo;ERROR: &rdquo;, e);   22      }</p>

<p> 程序流程图：</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/19/210029/">将GnuCash界面语言设为英文</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-19T21:00:29+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>9:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>日期： 2008-01-01   作者： muzuiget</p>

<p> 在XP下用 GnuCash 一段时间后感觉不错，功能够用，跨平台，在Uuntu下继续用。 不过界面汉化不全，半中半英的，很不顺眼，反正英文都看得懂了，把它设为英文界面好了。
 Windows XP： 在Windows XP下是在安装目录下的bin文件夹，用文本编辑器打开“gnucash.bat“文件，加上这两行
 set LANGUAGE=en_EN set LANG=en_EN（ 注：GnuCash2.2.9 winXp版中的启动文件是 gnucash.cmd,处理方法相同 ）
 整个文件看起来像
 set PATH=C:\Program Files\gnucash\bin;C:\Program Files\gnucash\lib;C:\Program Files\gnucash\lib\gnucash;%PATH% set GUILE_WARN_DEPRECATED=no (&hellip;) set LTDL_LIBRARY_PATH=C:\Program Files\gnucash\lib set LANGUAGE=en_EN set LANG=en_EN start gnucash-bin
 Ubuntu： 在Ubuntu下，我打开HOME目录下的“.GnuCash“文件，看看有没有类似的文件，没有，去查文档，找到方法，比在Windows下更简单，用这条命令运行GnuCash就可以了
 env LANG=en_EN gnucash %f</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/16/135347/">剪贴板软件比较</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-16T13:53:47+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>1:53 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>剪贴板软件的功能要求包括：固定条目（favorite clips）、粘贴控制，强力粘贴（power paste）、条目排列（clips arrangements）、合并条目（merge clips）、条目组织（organize clips）、Clipboard Routing、快捷键定义、富文本控制（RichText）、条目数量设置等，
 固定条目 （favorite clips）
有一些东西经常用，又比较长，敲键盘太慢，希望有个软件能把这些东西记下来，需要用的时候能够很方便地调出来，比如GODU的登录用户名<aa><7001><administrator><autocmd>，也就是所谓的“固定条目”功能。</p>

<p>最先用的是Ditto，固定条目功能找不到，分组平时也用不到， 感觉不好用，用了一段时间后放弃了。</p>

<p>然后是CLCL，固定条目放在一个叫“Template”的地方，但奇怪的是选中条目后回车却不粘贴，不靠谱，放弃。</p>

<p>然后是 clipx ，要实现固定条目需要下一个叫stickies的插件，装好后在Configuration下 stickies中add，就可以实现固定条目功能了。将快捷键设置为Alt+P，然后字母键是固定条目，比CLCL少按一个键，且快捷键可自定义，数字是普通条目。</p>

<p> ClipCache设置固定条目（这里叫“favorite clips”）的方法是在clipcache主窗口里右键该条目，然后选“Add to favorite clips”为该条目设一个标签（label），然后为“Favorite Clips”设置快捷键（在Tools->Options->Hotkey->Show Favorites），以后需要使用该条目时，用设好的快捷键呼出favorite clips窗口，然后用label匹配想要的条目即可，支持简写，例如有个条目的标签是“gu”，只写“g”然后回车即可。</p>

<p> Ditto、Clipx和CLCL详细的功能对比参见善用佳软上的文章：“剪贴板增强软件综述:CLCL,ClipX,Ditto等”（ <a href="http://xbeta.info/clipx-clcl-ditto.htm">http://xbeta.info/clipx-clcl-ditto.htm</a> ），后面介绍了一个叫ArsClip的软件，功能很多，但我都用不上，不过它是开源的这一点很好。
 粘贴控制  Windows默认的粘贴快捷键是“Ctrl+v”，但有些程序有自己特殊的快捷键，例如SecureCRT是“SHIFT+INSERT”，“cmd.exe”是“Alt+space+e+p”应具备识别某一窗口然后定制特殊快捷键的能力。在Clipcache中是在 Tools->Options-> Pasting中定义。  强力粘贴（power paste）
 例如文件1里有20处文本需要放到文件2的20个地方，基本的方法是文件1里复制，切换到文件2，粘贴，在切回文件1，处理20条文本需要80次鼠标和键盘动作，借助power paste则只需要在文件1里连续复制20次，再切到文件2里连续粘贴20次即可，只需要41次动作。目前所有的开源/免费软件中仅Hamsin Clipboard（v 3.03）支持此功能，但此软件只能记录10条clip，它有单独的power paste模式，进入此模式后才能开始连续复制，之前的clip是不能连续粘贴的。clipcache对强力粘贴支持很好，可定义单独的快捷键，且有两种移动方向，结合它的条目排序功能（默认是按使用时间排序，还可以按名称、大小、加入时间等排序）和条目组织功能（将某组条目放入一个单独的文件夹中），能够极大简化大量条目的复制/粘贴劳动量。
 条目排列
 改变条目的排列顺序，例如按使用时间、名称、大小、加入时间等方式排列条目，只有软件具备强力粘贴、条目合并等功能时改变排列次序才有意义。
 合并条目
 将N个条目合并为一个条目，可以进行各种格式转换，例如每个条目一行、条目之间插入tab、删除条目起始/结尾空格、删除空行等等，目前只有clipcache具备此功能。
 条目组织
 可以将条目分类组织，例如放在不同的文件夹里，这项功能也是配合强力粘贴才有意义。
 Clipboard Routing
在网页/文件A里复制时，能够自动切到目标窗口粘贴，然后再切换回A里，目前仅clipcache支持此功能。
 快捷键定义
 似乎只有CLCL不支持快捷键定义，其他软件都支持，clipcache快捷键定义中不支持Win键。
 富文本控制
主要是是否能够粘贴富文本和图片，以及是否支持将富文本转换为普通文本（plain text），clipcache具备此功能，如果要clipcache直接将拷贝到的RichText粘贴为PlainText（而不需要专门“转换”），在clipcache主菜单【Tools->Options->Capture】中取消勾选【Capture HTML】。
 条目数量设置
 clipcache没有上限限制，支持3种限制策略：按条目数量限制、按数据库大小限制、按日期限制（如删除N天前的条目）。
 总结
整体而言开源/免费软件的功能远弱于商业软件，clipcache的条目组织能力目前只有Ditto可以相比，但Ditto其他方面远逊，</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/12/143709/">Log4j配置文件编码不同可能导致log4j日志运行异常</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-12T14:37:09+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>2:37 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>有时即使log4j的配置文件log4j.properties放在了正确的位置上，内容也没有错误，但运行程序时总报appender异常，无法生成日志文件。可能的原因是配置文件的编码与项目设定的编码不一致（例如项目设置的编码是GBK，配置文件的编码使用UTF-8），导致读配置文件失败。解决的办法是将配置文件转换为项目设置的编码格式，为保证转换成功，文件中（包括注释部分）最好不要使用中文。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/11/085442/">将队列转换为字符串</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-11T08:54:42+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:54 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>LinkedBlockingQueue<Byte> inputQ = new LinkedBlockingQueue<Byte>();</p>

<p> Byte[] destArr = inputQ.toArray( new Byte[0]);</p>

<p> byte [] resultArr = new  byte [destArr. length ];</p>

<p> for ( int i = 0; i &lt; resultArr. length ; i++) {</p>

<p>  resultArr[i] = destArr[i].byteValue();</p>

<p> }</p>

<p> strRes = new String(resultArr);</p>

<p> 转换过程是：队列==>Byte数组==>byte数组==>字符串。下面是应用了此一转换的完整的Result类实现。</p>

<p> /**</p>

<ul>
<li><p>通过字节队列创建一个新的返回结果实例</p></li>
<li></li>
<li><p>@param inputQ</p></li>
<li><p> 结果字节队列</p></li>
<li><p>@param cmdType</p></li>
<li><p> 命令返回类型</p></li>
</ul>


<p> */</p>

<p> public Result( final LinkedBlockingQueue<Byte> inputQ, final  int cmdType) {</p>

<p>  cmdReturnType = cmdType;</p>

<p>  Byte[] destArr = inputQ.toArray( new Byte[0]);</p>

<p>  byte [] resultArr = new  byte [destArr. length ];</p>

<p>  for ( int i = 0; i &lt; resultArr. length ; i ++) {</p>

<p>   resultArr[ i ] = destArr[ i ].byteValue();</p>

<p>  }</p>

<p>  strRes = new String(resultArr);</p>

<p> }</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/10/203539/">在队列中寻找字符串算法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-10T20:35:39+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:35 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在一个队列destQ中，从前向后搜索是否有字符串flag，下面是算法实现以及测试程序。回溯功能暂未实现。</p>

<p> private  int findFlag( final LinkedBlockingQueue<Byte> destQ,</p>

<p> final String flag) {</p>

<p> byte [] flagArr = flag.getBytes();</p>

<p> Byte[] destArr = destQ.toArray( new Byte[0]);</p>

<p> int matchCount = 0; // 已匹配的字节数</p>

<p> int flagPos = -1; // 标志末尾的编号</p>

<p> int i = 0;</p>

<p> int  backupIndex = 0; // 用于回溯的索引</p>

<p> while (i &lt;= destQ.size()) {</p>

<p> if (flag.length() &lt;= matchCount) {</p>

<p> flagPos = i;</p>

<p> break ;</p>

<p> } else {</p>

<p> if (destArr[i] == flagArr[matchCount]) {</p>

<p> matchCount++;</p>

<p> } else {</p>

<p> matchCount = 0;</p>

<p> // i = backupIndex;</p>

<p> }</p>

<p> }</p>

<p> i = i + 1;</p>

<p> if (matchCount == 1) {</p>

<p> backupIndex = i;</p>

<p> }</p>

<p> }</p>

<p> return flagPos;</p>

<p> }</p>

<p> @Test</p>

<p> public  void runFindFlag() {</p>

<p> LinkedBlockingQueue<Byte> analyzerBuffer = new LinkedBlockingQueue<Byte>();</p>

<p> for ( int i = 33; i &lt; 123; i++) {</p>

<p> analyzerBuffer.offer( new Byte(( byte ) i));</p>

<p> }</p>

<p> String endFlag = &ldquo;123&rdquo; ;</p>

<p> int endFlagPos = findFlag(analyzerBuffer, endFlag);</p>

<p> List<Byte> cmplXmlStr = new ArrayList<Byte>();</p>

<p> analyzerBuffer.drainTo(cmplXmlStr, endFlagPos);</p>

<p> System. out .println(cmplXmlStr);</p>

<p> }</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/10/190026/">为Eclipse配置绿色版JDK</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-10T19:00:26+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>7:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1、解压JDK，例如f:\warez\Develop\Java\jdk1.5.0_16；</p>

<p>2、修改环境变量，在Path中增加：f:\warez\Develop\Java\jdk1.5.0_16\bin；</p>

<p>3、解压Eclipse，例如f:\warez\IDEs\Eclipse0621目录下；启动Eclipse（f:\warez\IDEs\Eclipse0621\eclipse.exe），如果提示找不到jre，可以用 “f:\warez\IDEs\Eclipse0621\eclipse.exe -vm f:\warez\Develop\Java\jdk1.5.0_16\bin” 的方式启动；</p>

<p>4、在Eclipse的Window==>Preferences==>Java==>Installed JREs中添加：</p>

<p> F:\warez\Develop\Java\jdk1.5.0_16；</p>

<p>5、重启Eclipse，如果仍然提示找不到jre，在Installed JREs==>Execution Enviroments中选对应的JDK版本打勾；</p>

<p>6、重启Eclipse验证设置成功；</p>

<p>7、为eclipse.exe增加快捷键，例如在Hoekey里加一行：~@E = Run|&ldquo;f:\warez\IDEs\Eclipse0621\eclipse.exe&rdquo;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/10/162133/">LinkedBlockingQueue的drainTo方法示例代码</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-10T16:21:33+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>4:21 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>LinkedBlockingQueue<String> analyzerBuffer = new LinkedBlockingQueue<String>();</p>

<p> String abc = &ldquo;abc&rdquo; ;</p>

<p> analyzerBuffer.offer(abc);</p>

<p> List<String> tmp = new ArrayList<String>();</p>

<p> analyzerBuffer.drainTo(tmp);</p>

<p> System. out .println(tmp);</p>

<p> System. out .println(analyzerBuffer);</p>

<p> analyzerBuffer.offer(abc);</p>

<p> analyzerBuffer.offer(abc);</p>

<p> analyzerBuffer.drainTo(tmp);</p>

<p> System. out .println(tmp);</p>

<p> System. out .println(analyzerBuffer);</p>

<p> 输出：</p>

<p> [abc]</p>

<p> []</p>

<p> [abc, abc, abc]</p>

<p> []</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/10/140800/">Arraycopy将数组分为两部分时游标的设置方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-10T14:08:00+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>2:08 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>System.arraycopy是复制数组的一个常用工具，它在游标处如何分为两个是一个需要注意的问题，例如下面的示例代码：</p>

<p>  byte [] src = { 104, 101, 108, 108, 111 };</p>

<p> int endPos = 2;</p>

<p> byte [] dest = new  byte [endPos];</p>

<p> byte [] surplus = new  byte [src. length - endPos];</p>

<p> System. arraycopy (src, 0, dest, 0, dest. length );</p>

<p> System. arraycopy (src, endPos, surplus, 0, src. length - endPos);</p>

<p> 游标（变量endPos）位置为2时，dest数组是{104, 101}，surplus数组是{108, 108, 111}。</p>

<p> 也就是说，编号为游标的元素（从0开始编号）在原数组分割后变为后面数组的第一个元素。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/09/170059/">VIM的搜索模式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-09T17:00:59+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>5:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>用VIM当文本分析器分析log4j打出的日志时，有一个问题很棘手，那就是经常要搜索
[DEBUG] [2010-08-09 15:44:49,421] [com.boco.godu.GAPI.impl.DataReader]
这样的字符串，直接在/后面粘贴上字符串肯定不行，因为里面有大量的[、]、-、点号、冒号这样的特殊字符，要想能查到，就得在它们之前加反斜杠\，每次查都这么一下，实在太麻烦，解决方法是：告诉VIM所有字符都是普通字符，不用做正则符号，告诉的方法就是设置magic属性，VIM默认是magic状态，可以用:set nomagic的方法切换到普通搜索模式，但这样一来以后再想用正则搜索还得再写:set magic，比较麻烦，最简单的方法是在/和要查找的字符串中间加上\V（注意是大写V，小写代表完全相反的意思），例如
 bad.magic dam
dbm dcm aa dkm
 用/d.m搜，d.m、dam、dbm等等都符合，改为/\Vd.m，就只有d.m符合了（\V前后都没有空格）。
 关于\V详见:h magic。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/119">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/117">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/11/11/114228/">Ubuntu 14.04 Apt Update Failure</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/11/05/083438/">Use Matplotlib in Python 3 on Ubuntu</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/10/31/171345/">理解IP地址和CIDR</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/10/25/110137/">保证Docker的输入参数可执行</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/10/20/113258/">为vim增加undo功能</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
