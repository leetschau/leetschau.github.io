
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="原始文本： 2011年7月18日：修改密码的核心功能开发完毕；
2011年7月19日：上午换座位，下午提交了著作权文档的电子流程； 目标格式文本： 2011-7-18：修改密码的核心功能开发完毕；
2011-7-19：上午换座位，下午提交了著作权文档的电子流程； vim实现 :%s/\(\d\{4 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/78">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A note repository aims at Data Mining, Spark, Linux, Python.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:leetschau.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/19/164331/">日期格式转换的正则表达式实现</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-19T16:43:31+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>4:43 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原始文本：</p>

<blockquote><p>2011年7月18日：修改密码的核心功能开发完毕；
2011年7月19日：上午换座位，下午提交了著作权文档的电子流程；</p></blockquote>

<p>目标格式文本：</p>

<blockquote><p>2011-7-18：修改密码的核心功能开发完毕；
2011-7-19：上午换座位，下午提交了著作权文档的电子流程；</p></blockquote>

<h1>vim实现</h1>

<pre><code>:%s/\(\d\{4}\).\(\d\{1,2}\).\(\d\{1,2}\)./\1-\2-\3/g 
</code></pre>

<p>说明： 采用 :%s/old/new/g 命令进行替换，其中%表示对所有行进行替换操作，最后的g参数表明对一行中所有的new均替换为old。\d代表任意数字，old pattern中每个括号（即(&hellip;)）中的内容构成一个group member，new pattern中对group member的引用用\1、\2、\3&hellip;代表，即&#8221;BRE&#8221;, back references.</p>

<h1>Groovy实现</h1>

<pre><code>oriStr = '''2011年7月18日：修改密码的核心功能开发完毕； 
2011年7月19日：上午换座位，下午提交了著作权文档的电子流程；'''; 
pattern = /(\d{4})\W(\d{1,2})\W(\d{1,2})\W/; 
matcher = oriStr =~ pattern; 
matcher.each { all,y,m,d-&gt; 
    println 'Patten is: '+all; 
    println 'Replaced by: '+y+'-'+m+'-'+d; 
}; 
println '*****'; 
println oriStr.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d;}; 
</code></pre>

<p>运行结果：</p>

<pre><code>Patten is: 2011年7月18日 
Replaced by: 2011-7-18 
Patten is: 2011年7月19日 
Replaced by: 2011-7-19 
***** 
2011-7-18：修改密码的核心功能开发完毕； 
2011-7-19：上午换座位，下午提交了著作权文档的电子流程； 
</code></pre>

<p>说明： 跨行字符串用三引号括起来；匹配模式用“ /&hellip;/” 括起来；用模式匹配字符串时，每一次成功匹配构成了matcher的一个元素（代码中用matcher.each得到），如果模式当中包含group（可以matcher.hasGroup()判断），则这个元素本身也是一个List，其中第一个元素是符合模式的substring（代码中的all），各个group member可以用下标引用，也可以分别起名字（代码中分别为y、m、d）。这部分内容可参见《Groovy in Action》（2007版）第3.5节“Working with regular expressions”。Groovy的String.replaceAll方法包括两个参数，第一个是要被代替的pattern，第二个是用来代替pattern的closure，该closure的返回结果是最后一行代码的值。</p>

<p>例如：<code>println oriStr.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d;return 'Date'};</code> 的输出是：</p>

<pre><code>Date：修改密码的核心功能开发完毕； 
Date：上午换座位，下午提交了著作权文档的电子流程； 
</code></pre>

<h1>基于文件读写的Groovy实现</h1>

<pre><code>pattern = /(\d{4})\W(\d{1,2})\W(\d{1,2})\W/; 
convStr = ''; 
new File('f:/Edit3.txt').eachLine{ 
    convStr += (it.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d})+'\n' 
} 
new File('f:/conv.txt').write convStr; 
</code></pre>

<p>说明： 第4行的it表示此行文本（字符串）。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/18/112537/">Java Assert关键字的使用方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-18T11:25:37+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>11:25 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>assert后面的表达式为假时会抛出AssertionError类对象，此类继承自Throwable类，可以用try..catch(AssertionError e)&hellip;语句捕获并处理，如果不处理，将会向其他Exception一样向上层调用抛出，导致线程运行中断。</p>

<h2>使用assert的方法</h2>

<p>assert适用于定义服务器的能力边界，如最大负载等，不适于对外部条件（例如检验用户输入格式）进行判断（参考<a href="http://stackoverflow.com/questions/1276308/exception-vs-assertion%EF%BC%89%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A4%84%E7%90%86%E8%BF%99%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%8F%8D%E9%A6%88%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E3%80%82%E5%9F%BA%E4%BA%8E%E6%AD%A4%EF%BC%8C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%88%9D%E6%9C%9F%E5%8F%AF%E4%BB%A5%E7%94%A8assert%E5%B0%86%E6%B5%81%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6%E5%86%99%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%BD%86%E5%9C%A8%E4%BA%A7%E5%93%81%E5%8F%91%E5%B8%83%E5%89%8D%E5%BA%94%E5%B0%86%E8%BF%99%E4%BA%9B%E4%B8%B4%E6%97%B6assert%E6%94%B9%E6%88%90%E6%AD%A3%E5%BC%8F%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5%E3%80%82">http://stackoverflow.com/questions/1276308/exception-vs-assertion%EF%BC%89%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%A4%84%E7%90%86%E8%BF%99%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%8F%8D%E9%A6%88%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E3%80%82%E5%9F%BA%E4%BA%8E%E6%AD%A4%EF%BC%8C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%88%9D%E6%9C%9F%E5%8F%AF%E4%BB%A5%E7%94%A8assert%E5%B0%86%E6%B5%81%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6%E5%86%99%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%BD%86%E5%9C%A8%E4%BA%A7%E5%93%81%E5%8F%91%E5%B8%83%E5%89%8D%E5%BA%94%E5%B0%86%E8%BF%99%E4%BA%9B%E4%B8%B4%E6%97%B6assert%E6%94%B9%E6%88%90%E6%AD%A3%E5%BC%8F%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5%E3%80%82</a></p>

<p>JUnit的assert*提供了比内置assert更丰富的判断方法，但本质上仍然是抛出AssertionError，且增加了对JUnit的依赖，因此不建议用JUnit代替assert。</p>

<p>（2012-12-19更新）</p>

<hr />

<p>Java的assert关键字是从JAVA SE 1.4 引入的，为了和老版本兼容，Java在执行的时候默认是不启动断言检查的，这种情况下所有的assert语句都将被忽略。要开启断言检查，则需要在运行时加参数-enableassertions或-ea来开启，在Eclipse中，就是在要运行的类（或测试方法）的Run Configurations中的“Arguments”下的“VM arguments”部分写上：“-ea”。为了避免由于忘记加这个开关造成assert失效导致错误的测试结果，建议不要使用java的assert，而使用JUnit的org.junit.Assert.assertTrue(expr)方法。</p>

<h1>assert关键字的两种用法：</h1>

<ol>
<li>assert &lt;boolean表达式></li>
</ol>


<p>如果&lt;boolean表达式>为true，则程序继续执行。</p>

<p>如果为false，则抛出 java.lang.AssertionError；</p>

<ol>
<li>assert &lt;boolean表达式> : &lt;提示信息> （boolean表达式和提示信息之间用冒号分隔）</li>
</ol>


<p>如果&lt;boolean表达式>为true，则程序继续执行。</p>

<p>如果为false，则抛出java.lang.AssertionError，并输出提示信息。</p>

<p>另外assert后面可以指定对哪些类断言生效，详见<a href="http://www.ibm.com/developerworks/cn/java/l-javaassertion/index.html">深入解析Java的新特性assertion</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/07/113549/">Use `Resolve Dependency in Workspace` Feature of IvyDE to Resolve Project Dependency in Develop Stage</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-07T11:35:49+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>11:35 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/07/112831/">IoConnector和IoSession的关系以及上挂Filter的区别</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-07-07T11:28:31+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>11:28 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>IoConnector是Mina框架下的网络接收端，当它与服务端建立连接后返回一个代表连接的IoSession，具体过程如下：</p>

<p>  IoConnector connector = new NioSocketConnector(50);</p>

<p>  ConnectFuture connFuture = connector.connect(new InetSocketAddress(ip, port));</p>

<p>  boolean b = connFuture.awaitUninterruptibly(10000);</p>

<p>  if (b) {</p>

<p>   IoSession session = connFuture.getSession();</p>

<p>   &hellip;</p>

<p>  }</p>

<p>也就是用IoConnector的connect方法得到一个ConnectFuture，再用此ConnectFuture的getSession方法得到IoSession。</p>

<p>本质上Filter是与连接（也就是IoSession）相关联的，但由于下面的两个原因，导致需要在Connector上定义filter链。</p>

<p>首先是filter链需要在连接建立前就要定义好，这样才能实现“一建立连接就做某事”这种功能，在已经存在的Session（也就是连接）上挂filter显然无法达到这种效果；</p>

<p>其次是Connector每与服务端建立一个连接就会生成一个Session，且这些Session的行为具有很大的相似性，也就是上面的filter一般也是一样的，这样为多个session定义相同的一组filter显然是一种dirty work；</p>

<p>简而言之，就是Connector上挂filter链属于“配置”定义，而session上挂filter链属于“运行时”定义，当连接关闭（断开）后，这个filter链也就不存在了。</p>

<p>下面是二者挂filter链的具体方法。</p>

<p>对于Connector：</p>

<p>  DefaultIoFilterChainBuilder chain = IoConnector.getFilterChain();</p>

<p>  chain. addLast (String name, IoFilter filter);</p>

<p>对于session：</p>

<p>  IoFilterChain chain = session.getFilterChain();</p>

<p>  chain. addLast (String name, IoFilter filter);</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/28/145204/">更新ivy资源库的自动化脚本</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-06-28T14:52:04+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>2:52 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>为产品库添加一个新jar包需要下面几个步骤：</p>

<ol>
<li><p>根据jar包名字，从maven库里得到依赖定义字符串；</p></li>
<li><p>将该字符串加上配置说明和下载脚本（参见笔记“依赖管理常用vim脚本”）；</p></li>
<li><p>将已下载条目备份文件（installed.txt）另存为old.bpk；</p></li>
<li><p>将build.xml中的下载条目插入到installed.txt中（按字母顺序排列）；</p></li>
<li><p>用新的下载脚本替换build.xml中原有的下载脚本；</p></li>
<li><p>运行ant命令将jar包下载到产品库中；</p></li>
<li><p>在ivy.xml中加入依赖条目，解析之；</p></li>
</ol>


<p>以下是上面1~5步的自动化脚本。</p>

<p> #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p> # Purpose:  download jars to public repo</p>

<p> # Author:  Li Chao</p>

<p> # Created:  28-06-2011</p>

<p> #</p>

<p> # Demonstration:</p>

<p> # install Apache Log4j 1.2</p>

<p> #  1. from mvnrepository.com we got the dep string:</p>

<p> #   <dependency org="log4j" name="log4j" rev="1.2.16"/></p>

<p> #  2. modify dep_str in this file with above dep string:</p>

<p> #  3. run this file, copy modified dep string:</p>

<p> #   <dependency org="log4j" name="log4j" rev="1.2.16" conf="compile->master&#8221;/></p>

<p> #  4. open a shell and run ant cmd to download jars of log4j</p>

<p> #  5. paste modified dep string to ivy.xml and resolve it</p>

<p> #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p> #!/usr/bin/env python</p>

<p> import os, re</p>

<p> dep_str = &lsquo;<dependency org="log4j" name="log4j" rev="1.2.16"/>&rsquo;</p>

<p> cmd_pattern = &lsquo;&lt;ivy:install.+from=&ldquo;\${from.resolver}&rdquo; to=&ldquo;\${to.resolver}&rdquo;/>&rsquo;</p>

<p> script = &lsquo;build.xml&rsquo;</p>

<p> def conv_str():</p>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>   covert dep_str to custom_ivy_dep string and ivy_install string;</p>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>  custom_ivy_dep = dep_str.replace(&lsquo;/>&rsquo;,&lsquo; conf=&ldquo;compile->master&rdquo;/>&rsquo;)</p>

<p>  print &lsquo;Copy the following String:\n%s&rsquo; %custom_ivy_dep</p>

<p>  keys = re.findall(r&#8217;&ldquo;\S+&rdquo;&lsquo;, dep_str)</p>

<p>  if len(keys)!=3:</p>

<p>   raise Exception(&lsquo;Format wrong of input string!&rsquo;)</p>

<p>  global ivy_install</p>

<p>  ivy_install = &lsquo;&lt;ivy:install organisation=%s module=%s revision=%s &rsquo;\</p>

<pre><code>  'from="${from.resolver}" to="${to.resolver}"/&gt;' %tuple(keys) 
</code></pre>

<p> def do_bpk():</p>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>   create backup file(filename: installed.txt/old.bpk):</p>

<pre><code>1 extract old install string from build.xml; 

2 delete old.bpk if it exists; 

3 rename installed.txt to old.bpk; 

4 read old.bpk file, insert old install string and create installed.txt file; 
</code></pre>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>  installed = &lsquo;installed.txt&rsquo;</p>

<p>  old_bpk =&lsquo;old.bpk&rsquo;</p>

<p>  xml_file = open(script)</p>

<p>  global xml_str</p>

<p>  xml_str = xml_file.read()</p>

<p>  xml_file.close()</p>

<p>  old_install = re.findall(cmd_pattern, xml_str, re.M)[0]</p>

<p>  print &lsquo;old install string is:\n%s&rsquo; %old_install</p>

<p>  if os.path.exists(old_bpk): os.remove(old_bpk)</p>

<p>  if os.path.exists(installed):</p>

<p>   os.rename(installed, old_bpk)</p>

<p>  else:</p>

<p>   raise Exception(&lsquo;%s does not exist!&rsquo;%installed)</p>

<p>  installed_file = open(old_bpk)</p>

<p>  installed_items = installed_file.read()</p>

<p>  installed_file.close()</p>

<p>  all_items = installed_items.split(&lsquo;\n&rsquo;)</p>

<p>  all_items.append(old_install)</p>

<p>  all_items.sort()</p>

<p>  bpk_file = open(installed,&lsquo;w&rsquo;)</p>

<p>  bpk_file.write( &lsquo;\n&rsquo;.join(all_items) )</p>

<p>  bpk_file.close()</p>

<p> def build_script():</p>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>   modify install script(build.xml): replace old install string with new one</p>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>  xml_file = open(script,&lsquo;w&rsquo;)</p>

<p>  new_xml = re.sub(cmd_pattern, ivy_install, xml_str)</p>

<p>  xml_file.write(new_xml)</p>

<p>  xml_file.close()</p>

<p> def main():</p>

<p>  conv_str()</p>

<p>  do_bpk()</p>

<p>  build_script()</p>

<p> if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<p>  main()</p>

<p>代码中的技术点包括：</p>

<ol>
<li><p>格式化字符串的生成方法：%后面必须接一个tuple；</p></li>
<li><p>如何使用正则表达式进行文本的搜索（findall）和替换(sub)；</p></li>
<li><p>字符串的join方法进行list的组合，也可以用reduce方法： total_str = reduce(lambda x,y:x+y, str_list)</p></li>
</ol>


<p>  但用join方法更简洁。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/27/154047/">数码照片按拍摄时间分文件夹保存</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-06-27T15:40:47+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>3:40 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>拍摄的大量数码照片需要根据拍摄的时间分别放到不同的文件夹里，例如2011年6月27日拍摄的照片要放在名为“2011-6-27”的文件夹里。拍摄时间是根据文件的“最后修改时间”属性确定的，因为“创建时间”属性是会随着文件的拷贝而变化的，不能作为拍摄时间的根据。当然如果用画图或者photoshop修改了照片，那么 “最后修改时间”属性也不是拍摄时间了，但文件的【属性->摘要->照片拍照时间】项仍能显示出真实的拍照时间，但如何取这个属性尚不清楚，故本文不涉及。下面是源代码： </h2>

<p> #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p> # Author:  Li Chao</p>

<p> # Created:  27-06-2011</p>

<p> #</p>

<p> # Purpose: 将相机SD卡上的照片按照拍摄日期放入硬盘上当前目录下的不同的文件夹中。</p>

<p> #</p>

<p> # Usage:</p>

<p> # step 1: 将本文件拷贝到目标文件夹中；</p>

<p> # step 2: 在这个文件夹下新建一个run.bat，内容如下：</p>

<p> #   python arrangePhotos.py [photo_path] [last_backup_date]</p>

<p> #   第1个参数是SD卡里照片所在文件夹路径，第二个参数是已备份的最后日期；</p>

<p> # step 3: 运行run.bat</p>

<p> #</p>

<p> # Example: python arrangePhotos.py h:/transfer/pics 2011-06-10</p>

<p> #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p> #!/usr/bin/env python</p>

<p> import sys, os, time, shutil</p>

<p> from datetime import date</p>

<p> def main():</p>

<p>  photos_path = sys.argv[1]</p>

<p>  last_bp = time.strptime(sys.argv[2], &ldquo;%Y.%m.%d&rdquo;)</p>

<p>  last_bp_epoch = time. mktime (last_bp)</p>

<p>  for item in os.listdir(photos_path):</p>

<p>   modif_time = os.path. getmtime (os.path.join(photos_path,item))</p>

<p>   if modif_time - last_bp_epoch &lt;= 3600*24 :</p>

<pre><code>continue 
</code></pre>

<p>   cre_date_obj = date.fromtimestamp(modif_time)</p>

<p>   cre_date = cre_date_obj.strftime(&ldquo;%Y.%m.%d&rdquo;)</p>

<p>   if not os.path.exists(cre_date):</p>

<pre><code>os.mkdir(cre_date) 

print '\n%s' %cre_date 
</code></pre>

<p>   shutil.copy2(os.path.join(photos_path,item), cre_date)</p>

<pre><code>print '.', 
</code></pre>

<p> if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<p>  main()</p>

<hr />

<p> 对源代码的解释：</p>

<ol>
<li>时区问题：</li>
</ol>


<p>  由于time.mktime()方法和os.path.getmtime()都是以1970-1-1 08:00:00为起点，因此将这些时间数转换为日期、时间时，一定要用time.localtime()方法，如果用time.gmtime()，则会得到错误的值，下面这段代码演示了两种方法的区别：</p>

<p> import time</p>

<p> gm_sec = time.gmtime(0)</p>

<p> print gm_sec</p>

<p> gm = time.strftime(&lsquo;%Y-%m-%d, %X&rsquo;, gm_sec)</p>

<p> print &lsquo;UTC start point is %s&rsquo; %gm</p>

<p> lc_sec = time.localtime(0)</p>

<p> print lc_sec</p>

<p> lc = time.strftime(&lsquo;%Y-%m-%d, %X&rsquo;, lc_sec)</p>

<p> print &lsquo;local time start point is %s&rsquo; %lc</p>

<p> second_day = time.mktime(time.strptime(&lsquo;1970-1-2&rsquo;, &ldquo;%Y-%m-%d&rdquo;))</p>

<p> print &lsquo;second day is %s hours after first day&rsquo; %(second_day/3600)</p>

<p>输出为：</p>

<p> time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)</p>

<p> UTC start point is 1970-01-01, 00:00:00</p>

<p> time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=8, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)</p>

<p> local time start point is 1970-01-01, 08:00:00</p>

<p> second day is 16.0 hours after first day</p>

<p>加粗的部分表明东8区的时间起点是1970-1-1 08:00:00。</p>

<ol>
<li>为什么修改时间要比最后一次备份时间多一天（即24小时，3600*24秒）？</li>
</ol>


<p> 例如最后一次备份时间是2011年6月27日，last_bp_epoch的值对应于27日0点0分，当处理一张2011年6月27日晚11点拍摄的照片时，modif_time - last_bp_epoch = 23 hour，这张照片已经备份过了，不应该再次备份，因此modif_time - last_bp_epoch > 24hour时才需要备份；</p>

<ol>
<li>怎样让print语句的输出不换行？</li>
</ol>


<p> 在字符串后面加逗号即可。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/27/102352/">语音朗读软件使用小记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-06-27T10:23:52+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>10:23 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最先下的是“方正畅听2008”，但装上之后发现根本不能正常朗读，发出来的声音伴有巨大的杂音，完全听不清。</p>

<p>后来使用了小众软件推荐的“随读”，语音引擎选用了Neospeech的中文-Liang，输出设为“16kHz 16Bit Stereo”。没有导出为MP3功能（通过插件可以导出MP3），只能朗读txt文件。</p>

<p>再后来又试用了免费的eSpeak，以及NextUp出品的TextAloud，综合比较TextAloud是最优秀的，其中的批量转换MP3功能尤其值得称道。</p>

<p>语音引擎方面，通过使用发现，中文的Lily（女声）和Liang（男声）效果最好，Wang（男声）和Hui（女声）效果一般，英文的Bridget和Julie似乎都不错。
另：[NeoSpeech.TTS][女声].NeoSpeech.Chinese.Lily.zip安装后的破解方法如下（不破解的话会在每次朗读前加一小段说明）：
打开安装目录C:\Program Files\VW\VT\Lily\M16-SAPI5\data-common\verify下新建一个文本文件：verification.txt，写入：
License:effacee1e9a0c118ca2dd64bdf6a66c3cc3d82fbee5a11f7002cb600ec1900e8de006e8f00152800adc100f14a0115d5:*:VoiceText:0:1:Nextup:WindowsNT2KXP::;
&mdash; Label Print &mdash;
CODE: VoiceText-02FF-278E-8AE6
Site name: Nextup
Host ID: *
Expiration Date: unlimited
Maximum Channel: 1
Operating System: WindowsNT2KXP
保存后重新启动朗读软件即可，无需重启系统。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/23/114908/">Notepad++手工配色</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-06-23T11:49:08+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2011</span></span> <span class='time'>11:49 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Notepad++的手工配色相对比较智能，对于其内置的语言，在【设置->语言格式设置】中进行，【选择主题】中可以选择不同的配色主题，确定主题后，在【语言】中选择要修改的语言，在【格式名称】中选择修改那种元素，然后修改颜色和字体；对于非内置语言，则需要使用其内置的&#8221;User Defined Languages&#8221;对话框；对于一种新语言，首先从网上下载其语法高亮模板，然后再根据自己的要求使用这个对话框修改，直到满意为止。具体来说：</p>

<ol>
<li><p>下载语法高亮文件（xml文件），如果notepad++当前文件夹下没有 userDefineLang.xml 这个文件，将下载的文件放在此文件夹（与notepad++.exe同目录）下，并命名为userDefineLang.xml，如果已经有这个文件，则把下载内容追加到 userDefineLang.xml 末尾；</p></li>
<li><p>启动Notepad++，【视图->自定义语言对话框】打开&#8221;User Defined Languages&#8221;对话框，在【自定义语言】下应该有刚才添加的语言；</p></li>
<li><p>如果没有，用【Import】按钮导入下载的XML文件；</p></li>
<li><p>对不满意的配色和内容进行修改，然后用【Export】导出，以备将来再次导入；</p></li>
</ol>


<p>修改的方法参见帮助文档的&#8221;User Defined Languages&#8221;一节，简单地说，能够定制的特性有：普通文本的前/背景色，关键字集合的内容和前/背景色，代码折叠的开始、结束标志，注释的样式和颜色，数字的颜色，运算符的内容和颜色，以上所有内容的字体、字号，转义符号的定义（避免&#8221;aa\&ldquo;bb&#8221;被解析成一对半字符串）等；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/22/094253/">关于段落格式重排</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-06-22T09:42:53+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2011</span></span> <span class='time'>9:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>段落重排是指：指定左边界（left margin）和右边界（right margin），所有文本都从左边界开始，到右边界结束（换行），超出的插入换行符（折行），不足的删除换行符补足，在此基础上，还可以指定对齐方式（左对齐、右对齐、居中、填充），以及悬挂缩进（hanging indent）值，也就是从第二行开始的左边界，从而实现更为精细的段落格式控制。</p>

<p>在Ultraedit中，要做段落重排，首先要在【格式->段落格式化->段落设置/格式化】对话框中设定前述参数，然后选中要重排的文本，用【格式->段落格式重排】就可以实现重排。下面是实例演示（使用等宽字体才能保证右对齐的效果）：</p>

<p>原始文本：</p>

<p> The idea of supersymmetry was the key to the</p>

<p> creation of</p>

<p> supergravity, but the concept had actually originated years earlier with theorists</p>

<p>重排后：</p>

<p> 左边界0，右边界40：</p>

<p> The idea of supersymmetry was the key to</p>

<p> the creation of supergravity, but the</p>

<p> concept had actually originated years</p>

<p> earlier with theorists</p>

<p>左边界4，右边界45：</p>

<p>  The idea of supersymmetry was the key to</p>

<p>  the creation of supergravity, but the</p>

<p>  concept had actually originated years</p>

<p>  earlier with theorists</p>

<p> 左边界4，右边界45，悬挂缩进2：</p>

<p>  The idea of supersymmetry was the key to</p>

<p>  the creation of supergravity, but the</p>

<p>  concept had actually originated years</p>

<p>  earlier with theorists</p>

<p> 左边界0，右边界45，右对齐：</p>

<p> The idea of supersymmetry was the key to the</p>

<p> creation of supergravity, but the concept had</p>

<p>   actually originated years earlier with</p>

<p> theorists</p>

<p> Notepad++的 TextFX插件也有重排功能（TestFX->TextFX Edit->ReWrap），但只能指定右边界，重排功能与UE相比偏弱。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/21/095608/">删除源代码文件里的注释和空行</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-06-21T09:56:08+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2011</span></span> <span class='time'>9:56 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>有时需要对大量的源代码文件做删除空行和注释的操作，手工处理效率会很低，可以用cloc工具（ <a href="http://cloc.sourceforge.net">http://cloc.sourceforge.net</a> ）来完成。</p>

<p>例如要处理d:\godu21\GODU_Server\GODU_V2.1\src\下所有的源代码文件，将去掉空行和注释的新文件放在f:\Software\cloc-1.53下：</p>

<p>第一步：将cloc.exe文件拷贝到f:\Software\cloc-1.53下；</p>

<p>第二步：在f:\Software\cloc-1.53下启动命令行，并运行：cloc &ndash;strip-comments=nj d:\godu21\GODU_Server\GODU_V2.1\src</p>

<p>命令格式为：cloc [options] src_path，cloc将处理后的文件放在当前目录下。命令中“&ndash;strip-comments=”后面是新文件的扩展名，例如原文件是ConnectKeyFilter.java，则处理后的对应文件为f:\Software\cloc-1.53\ConnectKeyFilter.java.nj。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/79">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/77">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/10/02/005047/">Clojure Web Development</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/10/01/210506/">Dmenu Notes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/27/113819/">A Simple Ring Server</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/24/073009/">Xen on CentOS 6</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/20/105816/">Lightweight Web Browser Dwb</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
