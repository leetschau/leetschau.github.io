
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="gvim的文本比较功能很强，命令行用法：gvim -d file1 file2，hg自带的hg diff没有颜色标示，含义也不够清晰，所以需要用vim的diff代替它，实现方法是在全局配置文件中增加： [extensions] hgext.extdiff = [extdiff] cmd.vdiff &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/46">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A note repository aims at Data Mining, Spark, Linux, Python.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:leetschau.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/26/181254/">使用vimdiff做hg的版本比较工具</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-26T18:12:54+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>6:12 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>gvim的文本比较功能很强，命令行用法：gvim -d file1 file2，hg自带的hg diff没有颜色标示，含义也不够清晰，所以需要用vim的diff代替它，实现方法是在全局配置文件中增加：</p>

<p> [extensions]
 hgext.extdiff =
 [extdiff]
 cmd.vdiff = D:\Apps\Vim\vim73\gvim.exe
 opts.vdiff = -d</p>

<p>使用时首先用hg st定位哪些文件有变化，然后hg vdiff filename查看文件的变动，例如：</p>

<p> E:\workspace\JDK6UTF8\GoduServerGD>hg st
 M conf\logback.xml
 M &hellip;
 E:\workspace\JDK6UTF8\GoduServerGD>hg vdiff conf/logback.xml</p>

<p>文件路径和文件名在唯一的情况下可以使用通配符，例如上面的指令可以简写为&#8221;hg vdiff conf/log*&ldquo;；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/25/124302/">基于hg的多用户单分支协同开发试验</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-25T12:43:02+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:43 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>协同方法</h1>

<p>在所有开发人员中指定一个Server，类似于svn repo。其他人（Client）的代码是server的副本，修改、测试稳定后立即合并回server（最好通过server的pull方法实现，比client push更保险），server将client提交的更新与自己的更新合并（merge）后立即push回client，要注意的是server在pull之前要确保working directory中没有未提交的更改（未完成功能，用&#8221;hg st&#8221;命令的输出是否为空来检验，为空说明没有未完成功能），因为merge后必须提交一个“合并版本”到版本库，如果有未完成功能，也会被提交到版本库中。</p>

<p>A和B在同步过代码后，如果A提交了新changeset，而此期间B没有提交过，则A可以把变化push给B，这时B不需要merge，只update即可，update后可以用hg log -l 1 -v查看哪些文件发生了变化，以及A的提交说明；</p>

<p>整个协同过程中不需要新建branch或者bookmark，估计是最简单的分布式版本控制系统的协同模型。</p>

<h1>试验过程</h1>

<p>Server（username: Li Chao）新建一个repo，添加文件，提交changeset，Client（username: chadOnPC）clone此repo，修改其中一个文件，与此同时Li Chao修改了另一个文件，chadOnPC将修改push回笔记本，Li Chao合并两部分修改，再修改这两个文件，push到Client，由于这期间Client没有修改，所以只要update就把Server push的内容更新到了working directory中。</p>

<p>========== Server ================</p>

<p>c:\tmp\HgRepo>hg init
// 新建两个文件：forChadLaptop.txt和forChadPC.txt并写一些内容在文件里
c:\tmp\HgRepo>hg add <em>.txt
c:\tmp\HgRepo>hg stat
A forChadLaptop.txt
A forChadPC.txt
c:\tmp\HgRepo>hg ci -m &ldquo;first checkin&rdquo;
c:\tmp\HgRepo>hg log
changeset: 0:fd200857b086
tag:   tip
user:  Li Chao
date:  Thu Apr 25 11:32:24 2013 +0800
summary:  first checkin
c:\tmp\HgRepo>hg heads
changeset: 0:fd200857b086
tag:   tip
user:  Li Chao
date:  Thu Apr 25 11:32:24 2013 +0800
summary:  first checkin
c:\tmp\HgRepo>hg serve
listening at <a href="http://chadlaptop:8000/">http://chadlaptop:8000/</a> (bound to </em>:8000)
=========== Client ==============
E:\lc\clonedRepo>hg clone <a href="http://chadlaptop:8000/">http://chadlaptop:8000/</a>
&hellip;
E:\lc\clonedRepo>hg log
changeset: 0:fd200857b086
tag:   tip
user:  Li Chao
date:  Thu Apr 25 11:32:24 2013 +0800
files:  forChadLaptop.txt forChadPC.txt
description:
first checkin
E:\lc\clonedRepo>hg st
// edit file &ldquo;forChadPC.txt&rdquo;
E:\lc\clonedRepo>hg st
M forChadPC.txt
E:\lc\clonedRepo>hg ci -m &ldquo;first on pc&rdquo;
forChadPC.txt
committed changeset 1:2c5fbbb6645b
E:\lc\clonedRepo>hg log
changeset: 1:2c5fbbb6645b
tag:   tip
user:  chadOnPC
date:  Thu Apr 25 11:42:09 2013 +0800
files:  forChadPC.txt
description:
first on pc
changeset: 0:fd200857b086
user:  Li Chao
date:  Thu Apr 25 11:32:24 2013 +0800
files:  forChadLaptop.txt forChadPC.txt
description:
first checkin
/<strong> 需要在被push的repo的.hg/hgrc文件中增加如下内容（如果文件不存在新建之）：
 * [web]
 * push_ssl = false
 * allow_push = *
</strong>/
E:\lc\clonedRepo>hg push <a href="http://chadlaptop:8000/">http://chadlaptop:8000/</a>
pushing to <a href="http://chadlaptop:8000/">http://chadlaptop:8000/</a>
searching for changes
1 changesets found
remote: adding changesets
remote: adding manifests
remote: adding file changes
remote: added 1 changesets with 1 changes to 1 files
============= Server ==================
// 修改forChadLaptop.txt文件
c:\tmp\HgRepo>hg st
M forChadLaptop.txt // 修改被感知到
c:\tmp\HgRepo>hg heads
changeset: 1:2c5fbbb6645b
tag:   tip
user:  chadOnPC
date:  Thu Apr 25 11:42:09 2013 +0800
summary:  first on pc // 与push之前笔记本上&#8221;hg heads&#8221;命令相比，head变成了push过来的那个changeset
c:\tmp\HgRepo>hg st
M forChadLaptop.txt // push不改变working dirctory中的文件
c:\tmp\HgRepo>hg ci -m &ldquo;second commit on laptop&rdquo;
created new head
c:\tmp\HgRepo>hg heads
changeset: 2:42809e7d6c58
tag:   tip
parent:  0:fd200857b086
user:  Li Chao
date:  Thu Apr 25 11:54:05 2013 +0800
summary:  second commit on laptop
changeset: 1:2c5fbbb6645b
user:  chadOnPC
date:  Thu Apr 25 11:42:09 2013 +0800
summary:  first on pc  // head变成了两个
c:\tmp\HgRepo>hg branch
default   // branch始终只有default一个
c:\tmp\HgRepo>hg merge
1 files updated, 0 files merged, 0 files removed, 0 files unresolved
(branch merge, don&rsquo;t forget to commit)
c:\tmp\HgRepo>hg st
M forChadPC.txt  // merge命令改变了working directory中文件的内容
c:\tmp\HgRepo>hg ci -m &ldquo;merge from pc&rdquo;
c:\tmp\HgRepo>hg log
changeset: 3:ba028970a1d0
tag:   tip
parent:  2:42809e7d6c58
parent:  1:2c5fbbb6645b
user:  Li Chao
date:  Thu Apr 25 11:57:17 2013 +0800
summary:  merge from pc
changeset: 2:42809e7d6c58
parent:  0:fd200857b086
user:  Li Chao
date:  Thu Apr 25 11:54:05 2013 +0800
summary:  second commit on laptop
changeset: 1:2c5fbbb6645b
user:  chadOnPC
date:  Thu Apr 25 11:42:09 2013 +0800
summary:  first on pc
changeset: 0:fd200857b086
user:  Li Chao
date:  Thu Apr 25 11:32:24 2013 +0800
summary:  first checkin
=========== Client =====================</p>

<p>E:\lc\clonedRepo>hg serve</p>

<p>=========== Server ===================</p>

<p>c:\tmp\HgRepo>hg push <a href="http://china-a9598ee91:8000/">http://china-a9598ee91:8000/</a></p>

<p>&hellip;</p>

<p>=========== Client ===============</p>

<p>E:\lc\clonedRepo>hg update // 由于Client没有同时修改代码，所以不需要merge，update即可</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/23/110349/">运行时动态指定文件名的日志工具实现方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-23T11:03:49+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>11:03 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>网元日志的特点是：每个网元的日志要写在单独的文件中，文件名要能够唯一地确定一组“用户-网元”连接，因此不可能预先指定或者写在配置文件里，只能在运行时根据登录的用户名和连接网元的ID动态生成。</p>

<p>使用JDK原生的java.io.FileOutputStream等类可以达到上述目的，但文件的关闭比较麻烦，由于JVM垃圾回收的特点，日志包装类被回收的时间是不确定的，如果它被回收的比较慢，文件句柄就不会被关闭，导致系统资源消耗变大。</p>

<p>下面的代码基于Logback实现了运行时动态指定日志文件名的日志工具，并发500个线程写日志文件，大约耗时3s左右。</p>

<p> import ch.qos.logback.classic.Logger;
 import ch.qos.logback.classic.LoggerContext;
 import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
 import ch.qos.logback.classic.spi.ILoggingEvent;
 import ch.qos.logback.core.FileAppender;
 public class DynamicLogWriter {
  private String loggerName = null;
  private final Logger logbackLogger;
  public DynamicLogWriter(String logfileName) {
   loggerName = logfileName;
   LoggerContext loggerContext = new LoggerContext();
   FileAppender<ILoggingEvent> fileAppender = new FileAppender<ILoggingEvent>();
   fileAppender.setContext(loggerContext);
   fileAppender.setName(&ldquo;logfile&rdquo;);
   fileAppender.setFile(&ldquo;log/&rdquo; + loggerName + &ldquo;.log&rdquo;);
   PatternLayoutEncoder encoder = new PatternLayoutEncoder();
   encoder.setContext(loggerContext);
   encoder.setPattern(&ldquo;%msg&rdquo;);
   encoder.start();
   fileAppender.setEncoder(encoder);
   fileAppender.start();
   logbackLogger = loggerContext.getLogger(&ldquo;nelogger&rdquo;);
   logbackLogger.addAppender(fileAppender);
   // OPTIONAL: print logback internal status messages
   // StatusPrinter.print(loggerContext);
  }
  public void writeNeLog(String msg) {
   logbackLogger.debug(msg);
  }
  public static void main(String[] args) {
   for (int i = 0; i &lt; 500; i++) {
    new Thread(new ThreadWrapper(i)).start();
   }
  }
 }
 class ThreadWrapper implements Runnable {
  private final int id;
  public ThreadWrapper(int i) {
   id = i;
  }
  @Override
  public void run() {
   DynamicLogWriter logWriter = new DynamicLogWriter(&ldquo;192.168.0.2.&rdquo; + id);
   logWriter.writeNeLog(&ldquo;Welcome t&rdquo;);
   logWriter.writeNeLog(&ldquo;o Ubuntu 11.4\r\nlogi&rdquo;);
   logWriter.writeNeLog(&ldquo;n:user\r\npasswor&rdquo;);
   logWriter.writeNeLog(&ldquo;d:\r\nlast login&hellip;&rdquo;);
  }
 }</p>

<p>参考： <a href="http://stackoverflow.com/questions/7824620/logback-set-log-file-name-programatically">http://stackoverflow.com/questions/7824620/logback-set-log-file-name-programatically</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/22/131818/">Hg单用户操作的分支合并</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-22T13:18:18+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2013</span></span> <span class='time'>1:18 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>$ hg init hgBranchTest // 新建一个名为hgBranchTest的repo，hg自动创建目录</p>

<p>$ cd hgBranchTest</p>

<p>$ vi readme.txt</p>

<p>$ cat readme.txt
this is the first version</p>

<p>$ hg add readme.txt
$ hg ci -m &ldquo;first time commit&rdquo; // or use &ldquo;hg ci -A -m &hellip;&rdquo; for add and commit
$ vi readme.txt
$ cat readme.txt
this is the first version
add a line
$ hg st
M readme.txt
$ hg log
修改集:  0:ffecf69346a5
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit
$ hg diff
diff -r ffecf69346a5 readme.txt
&mdash; a/readme.txt  Mon Apr 22 05:49:29 2013 +0100
+++ b/readme.txt  Mon Apr 22 05:51:03 2013 +0100
@@ -1,1 +1,2 @@
this is the first version
+add a line
$ hg ci -m &ldquo;第二次提交&rdquo;
$ hg log
修改集:  1:770a5cda1659
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
修改集:  0:ffecf69346a5
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit
$ hg branch
default
$ hg branches
default      1:770a5cda1659
$ hg branch red
marked working directory as branch red
(branches are permanent and global, did you want a bookmark?)
$ vi readme.txt
$ cat readme.txt
this is the first version
add a line
add the 3rd line
$ hg branches   // 没有提交（commit）之前分支不出现在branches列表中
default      1:770a5cda1659
$ hg branch   // 当前仍在red分支下
red
$ hg ci -m &ldquo;commit on branch red&rdquo;
$ hg branches
red       2:86e30b1564a9
default      1:770a5cda1659 (inactive)
$ hg log
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
修改集:  1:770a5cda1659
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
修改集:  0:ffecf69346a5
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit
$ hg log -b red // 只显示red分支上的changeset
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
$ hg tip  // tip是最近版本的意思
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
$ hg heads  // head表示各分支最近版本
修改集:  2:86e30b1564a9
分支:  red
标签:  tip
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
修改集:  1:770a5cda1659
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
$ hg up default   // 切换当前分支为default
1 files updated, 0 files merged, 0 files removed, 0 files unresolved
$ cat readme.txt  // 分支合并前文件内容
this is the first version
add a line
$ hg merge red
1 files updated, 0 files merged, 0 files removed, 0 files unresolved
(branch merge, don&rsquo;t forget to commit)
$ cat readme.txt  // 合并后文件内容改变
this is the first version
add a line
add the 3rd line
$ hg st
M readme.txt
$ hg ci -m &ldquo;after merge with branch red&rdquo;
$ hg log
修改集:  3:9a5f0a2b7b9c
标签:  tip
父亲:  1:770a5cda1659 // 合并后提交的版本的特点是有两个parent
父亲:  2:86e30b1564a9
用户:  Li Chao
日期:  Mon Apr 22 06:00:31 2013 +0100
摘要:  after merge with branch red
修改集:  2:86e30b1564a9
分支:  red
用户:  Li Chao
日期:  Mon Apr 22 05:57:07 2013 +0100
摘要:  commit on branch red
修改集:  1:770a5cda1659
用户:  Li Chao
日期:  Mon Apr 22 05:51:42 2013 +0100
摘要:  第二次提交
修改集:  0:ffecf69346a5
用户:  Li Chao
日期:  Mon Apr 22 05:49:29 2013 +0100
摘要:  first time commit</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/20/105251/">局域网聊天和文件传输工具</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-20T10:52:51+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>10:52 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>以前用飞秋在局域网内聊天、传文件，经常找不到目标，很难用，在网上找了一个开源、跨平台（Win, Linux &amp; Mac）的局域网聊天软件<a href="http://lanmsngr.sourceforge.net/">LAN Messenger</a>，以及<a href="http://portableapps.com/apps/internet/lan-messenger-portable">Portable版</a>，下载的文件是便携版LANMessengerPortable_1.2.35.paf.exe，聊天、传文件、群聊的功能都有，很方便。</p>

<p>LANMessenger在Mint上安装后无法正常运行，发现Linux上的iptux（apt-get install iptux）实际山就是Windows上的FeiQ（下载压缩包FeiQ.rar后解压运行），目前工作良好。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/17/111523/">基于ScheduledExecutorService的并发定时任务处理能力测试</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-17T11:15:23+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>11:15 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>测试代码</h1>

<h2>定时器类</h2>

<p> package business.util;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 import transfer.IUserParser;
 public class MyTimer {
  private static ScheduledExecutorService ses = Executors
    .newSingleThreadScheduledExecutor();</p>

<p>   // .newScheduledThreadPool(10);
  private MyTimer() {
  }
  /<strong>
   * 设置某一parser正在执行脚本的超时时间
   *
   * @param parser
   *   进行超时控制的解析器
   * @param timeout
   *   超时时间，单位：秒
   * @return
   */
  public static ScheduledFuture&lt;?> set(IUserParser parser, int timeout) {
   CloseRutine routine = new CloseRutine(parser);
   ScheduledFuture&lt;?> job = ses.schedule(routine, timeout,
     TimeUnit.SECONDS);
   return job;
  }
  /</strong>
   * 清除计时器
   *
   * @param unit
   * @return
   <em>/
  public static boolean cancel(ScheduledFuture&lt;?> job) {
   return job.cancel(true);
  }
  /**
   * 关闭此计时器（进程）
   </em>/
  public static void shutdown() {
   ses.shutdown();
  }
 }
 class CloseRutine implements Runnable {
  private final IUserParser parser;
  CloseRutine(IUserParser parser) {
   this.parser = parser;
  }
  @Override
  public void run() {
   parser.closePeer();
  }
 }</p>

<h1>#</h1>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/16/120452/">Java语言子类调用父类构造函数的规则</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-16T12:04:52+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:04 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>子类初始化时，调用父类构造函数的规则是：如果父类没有任何构造函数，系统会</p>

<ul>
<li><p>父类如果没有任何构造函数，系统会自动为父类生成一个无参构造函数，如果父类有带参构造函数，系统不会为父类生成无参构造函数；</p></li>
<li><p>如果父类和子类的构造函数都有参数且参数列表一样（包括参数的个数、类型、顺序），子类如果想调用父类的构造方法，必须在构造函数第一行用super(params)显式调用，否则子类的构造函数会去找父类的默认（无参）构造函数；</p></li>
<li><p>如果父类有无参构造函数，子类的构造函数除非显式用super(params)调用父类的带参构造函数，否则一定会执行父类的无参构造函数（不需要写super()）；</p></li>
</ul>


<p>参考：google &ldquo;java constructor&rdquo;, <a href="http://www.leepoint.net/notes-java/oop/constructors/constructor.html">http://www.leepoint.net/notes-java/oop/constructors/constructor.html</a></p>

<h1>父类有默认构造函数时</h1>

<p> class SuperClass {
  public SuperClass() {
   System.out.println(&ldquo;I am the super class.&rdquo;);
  }
  public SuperClass (String name) {
   System.out.println(&ldquo;I am the super class with a name: &rdquo; + name);
  }</p>

<p>  public SuperClass (int age) {
   System.out.println(&ldquo;I am sub class with age: &rdquo; + age);
  }</p>

<p> }
 public class TestedSubClass extends SuperClass {
  public TestedSubClass(){
   System.out.println(&ldquo;I am sub class&rdquo;);
  }
  public TestedSubClass(String name){
   super(name);
   System.out.println(&ldquo;I am sub class with a name: &rdquo; + name);
  }
  public TestedSubClass(int age) {
   System.out.println(&ldquo;I am sub class with age: &rdquo; + age);
  }</p>

<p>  public static void main(String[] args) {
   TestedSubClass tsc = new TestedSubClass();
   TestedSubClass tsc2 = new TestedSubClass(&ldquo;chad&rdquo;);
   TestedSubClass tsc3 = new TestedSubClass(33);
  }
 }</p>

<p>运行结果：</p>

<p> [java] I am the super class.
 [java] I am sub class
 [java] I am the super class with a name: chad
 [java] I am sub class with a name: chad
 [java] I am the super class.
 [java] I am sub class with age: 33</p>

<p>当父类有默认（无参数）构造函数情况下，子类初始化时，除非子类用super(param)显式调用其他构造函数，否则一定会执行父类的默认构造函数，不论子类初始化时有没有参数。</p>

<h1>父类无默认构造函数</h1>

<p>如果仅将父类的默认（无参）构造函数去掉重新运行，报找不到初始化方法错误，原因是当父类有带参构造函数时，系统不为父类生成构造函数，而第1次和第3次初始化子类对象时，会调用父类的无参构造方法，所以报错；</p>

<p>如果去掉父类中所有的构造函数，子类中保留无参和int参数两个构造函数，运行正常；</p>

<p>如果仅保留父类和子类的String参数构造方法，初始化运行正常；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/07/230132/">Sublime Text笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-07T23:01:32+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>11:01 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Sublime Text作为一款文本编辑器，最强大的是快速响应能力和&#8221;Goto Anything&#8221;功能，用Ctrl+Shift+P执行编辑器功能，用Ctrl+P+@进行文件间与文件内部的跳转，目前的编辑器还没有类似的，Vintage将vi的强大编辑能力吸收了进来，更是如虎添翼。</p>

<p>它不适合作为静态语言（如Java）的正式开发IDE，与“标准的”IDE（如Eclipse）比较，它不具备针对静态语言的代码重构功能；在代码自动补全方面，无法提供类库的类名/方法补全（能够提供语言关键字和变量的补全）；它无法提供调试环境，需要单独的代码调试器（如JSwat）。所以Sublime Text适合作为展现语言（如HTML，Latex等）或者动态语言（Python, PHP等）的开发工具。</p>

<p>但很多时候我们只是想浏览代码，或是写一些简单的试验程序，或是修改代码的一处细节，启动Eclipse太慢了，用Sublime text这样text editor处理正合适。</p>

<h1>借助Ant打造Java IDE</h1>

<p>项目目录结构：项目根目录（$PORJ_HOME）下存放源代码、编译后的class文件和需要引用的jar包（而不是分开放在src, bin, lib文件夹下，适合于技术验证式的小项目），以及sublime项目定义文件（ProjectName.sublime-project）和build.xml，通过Ant的javac和java指令编译和运行Java代码，源代码不论什么包名都放在$PORJ_HOME下（Ant的javac指令会根据源代码的包名创建class文件的目录结构）；</p>

<h2>准备工作</h2>

<ol>
<li><p>指定用Ant做构建工具：修改[Preferences -> Browse Packages]打开packages文件夹，修改Java/JavaC.sublime-build文件，将原来&#8221;cmd&#8221;后面的&#8221;javac&#8221;改为&#8221;ant.bat&#8221;，如果ant所在目录没有加到系统的$Path里，这里需要写文件完整路径，例如&#8221;D:/Apps/apache-ant-1.8.1/bin/ant.bat&#8221;，然后将工作目录设置为项目根目录（默认的就是项目文件所在目录，因此这句不写也行）：&#8221;working_dir&#8221;: &ldquo;$project_path&#8221;；</p></li>
<li><p>安装AdvancedNewFile插件：利用package control的install new package功能，装完后就可以用快捷键&#8221;Ctrl + Alt + N&#8221;在项目根目录下创建文件了；</p></li>
</ol>


<h2>创建Java项目</h2>

<ol>
<li><p>创建项目文件夹（TotalCMD），拷贝此文件夹的完整路径；</p></li>
<li><p>Sublime Text -> Project -> Add Folder: 将上一步创建的文件夹加入到Project中；</p></li>
<li><p>生成新的Sublime项目文件：Sublime Text -> Project -> Save Project As，这样项目文件就定义好了，如果希望隐藏不必要的文件和文件夹：[Project -> Save Project As]，用file_exclude_patterns和folder_exclude_patterns属性实现，例如：</p></li>
</ol>


<p> {
  &ldquo;folders&rdquo;:
  [
   {
    &ldquo;path&rdquo;: &ldquo;/e/workspace/PNProject&rdquo;,</p>

<pre><code>"file_exclude_patterns": 
[ 
  "*.sublime*" 
] 
</code></pre>

<p>   }</p>

<p>  ]
 }</p>

<p>注：还可以用&#8221;folder_exclude_patterns&#8221;:[&ldquo;build&rdquo;]这样的方式去掉文件夹。</p>

<ol>
<li>在项目根目录下新建一个build.xml文件，主要内容是编译和运行java代码（注意每个项目的启动类是不同的（java命令的classname参数），拷贝这个模板时需要修改）：</li>
</ol>


<p> &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
 <project name="ExProj" basedir="./" default="run">
  <path id="lib.path">
   <fileset dir="${basedir}">
    <include name="**/*.jar"/>
   </fileset>
  </path>
  <target name="compile">
   <javac srcdir="${basedir}" destdir="${basedir}"
    classpathref="lib.path" encoding="UTF-8" debug="true"/>
  </target>
  <target name="run" depends="compile">
   <java classname="org.leechau.HelloWorld">
    <classpath>
     <pathelement path="${basedir}"/>
    </classpath>
   </java>
  </target>
 </project></p>

<ol>
<li>运行构建：[Tools -> Build]（快捷键Ctrl+B）；</li>
</ol>


<h1>打开Vintage模式</h1>

<p>Vintage是vi风格的操作方式，当然要打开啦，方法是：</p>

<ol>
<li><p>在user preference里加上：&#8221;ignored_packages&#8221;: []</p></li>
<li><p>如果希望打开文档时初始状态是命令模式而不是插入模式，再加上：&#8221;vintage_start_in_command_mode&#8221;: true</p></li>
</ol>


<h1>自定义代码模板</h1>

<ol>
<li><p>[Tools -> New Snippet&hellip;];</p></li>
<li><p>填写模板内容（content），触发器（写完触发器按tab键展开为content中定义的代码）和有效范围（定义那些文件中此模板有效）；</p></li>
<li><p>保存模板文件：文件名统一约定为“范围名-触发器 .sublime-snippet”；</p></li>
</ol>


<p>参考<a href="http://www.granneman.com/webdev/editors/sublime-text/top-features-of-sublime-text/quickly-insert-text-and-code-with-sublime-text-snippets/#test">http://www.granneman.com/webdev/editors/sublime-text/top-features-of-sublime-text/quickly-insert-text-and-code-with-sublime-text-snippets/#test</a></p>

<p>实例：Java代码中终端打印语句的代码模板（spl + <Tab> -> System.out.println(${1});）：</p>

<p> <snippet>
  <content>&lt;![CDATA[
 System.out.println(${1});
 ]]></content>
  <!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
  <tabTrigger>spl</tabTrigger>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <scope>source.java</scope>
 </snippet></p>

<p>如果设置后不生效，检查各个标签的大小写是否正确（snippet文件是大小写敏感的），例如CDATA要大写，tabTrigger中T大写。</p>

<h1>Best Practice</h1>

<ul>
<li>所有的个性化配置都写在&#8221;Settings - User&#8221;，不要修改&#8221;Settings -> Default&#8221;；</li>
</ul>


<h1>Trouble Shooting</h1>

<ul>
<li><p>&ldquo;Decode error - output not utf-8&rdquo; when build java files: this is caused by adding &ldquo;&#8221;shell&rdquo;: true&#8221; in JavaC.sublime-build. cmd.exe use GBK(cp936) for console output encoding, which is different with sublime&rsquo;s default output encoding utf-8. So adding &ldquo;&#8221;encoding&rdquo;: &ldquo;cp936&rdquo;&ldquo; in JavaC.sublime-build will resolve this problem. Reference: <a href="http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=1535&amp;start=0">http://www.sublimetext.com/forum/viewtopic.php?f=3&amp;t=1535&amp;start=0</a></p></li>
<li><p>Run Java without Ant: reference <a href="http://stackoverflow.com/questions/12030865/sublime-text-2-wont-run-java.">http://stackoverflow.com/questions/12030865/sublime-text-2-wont-run-java.</a> But when your java codes have package names, it&rsquo;s really difficult to compile and run them because package names are hardly get by sublime. So always use Ant to build java codes in sublime.</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/06/004608/">基于goagent的翻墙方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-06T00:46:08+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:46 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>本机上使用</h1>

<p><a href="http://www.hiadmin.org/shares/goagent-switchyplus">为Chrome 安装GoAgent并配上SwitchyPlus畅游互联网</a></p>

<p>Goagent的使用方式如下：</p>

<p>1、 申请一个Google App engine并创建一个appid（在申请的时候需要发送验证码到手机上面、所以手机号码一定得是真实的）</p>

<p>2、 申请到appid后下载GoAgent最新的程序</p>

<p>3、 将程序解压到硬盘上面、然后双击Serveruploader.bat文件、在弹出的界面中按照提示输入appid和你的Gmail 账号和密码。然后上传到服务端（如果出错多试几次）</p>

<p>4、 接着我们修改$GOAGENT_ROOT/local/proxy.ini文件、在[gae]配置项下面将appid=修改为你的appid，将[listen]下面的visible的值改为0，这样启动后最小化到托盘区；</p>

<p>5、 配置完成后我们可以直接运行Goagent.exe程序启动代理。是一个黑框框运行着的不要关掉</p>

<p>6、 打开谷歌浏览器、配置代理服务器IP:127.0.0.1 端口：8087</p>

<h1>作为局域网代理服务器</h1>

<p>将goagent部署在一台服务器上，其他机器上网时借助于这台服务器上的goagent，方法是：</p>

<ol>
<li><p>修改上面proxy.ini文件[listen]下的ip的值为0.0.0.0，port保持8087不变；</p></li>
<li><p>其他机器要借助于此服务器上网，将proxy的ip设为服务器的IP地址，端口号设为8087即可；</p></li>
<li><p>Ubuntu系统下可以定义系统级的代理服务器，这样使用apt-get这样的命令行下载也不受限制了，在 [System settings -> network -> network proxy]中设置；</p></li>
</ol>


<h1>修复403错误</h1>

<p>如果用goagent连接时浏览器报403错误，将$GOAGENT_HOME/local/proxy.ini中[gae]下面的profile值从google_cn改为google_hk即可；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/04/06/000709/">自动将Evernote笔记发布到博客上</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-04-06T00:07:09+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:07 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Evernote笔记要自动分享到博客还真不那么容易，借鉴<a href="https://arjw.wordpress.com/2011/08/25/of-the-note/#">Using Evernote to Post to WordPress</a>，申请了一个Wordpress帐号，点击dashboard左边的“控制板” -> My Blogs -> Post by Email下面的&#8221;Enable&#8221;按钮，会出现一个email地址，向这个地址发送邮件就可以发布博客了，可以先将写好的笔记保存在一个文件里，然后通过python的email模块向这个地址发邮件的方法实现自动发布博客，然后用evernote的local api将这个文件变成一个新笔记保存在数据库中。</p>

<p>对于现有的笔记，只能在菜单“笔记->分享->通过电子邮件发送”，填上Email地址的方法，刚才试验成功，但如果修改这个笔记重新发送一次，wordpress上不会覆盖原来的笔记，而是发一条新博文，还有一个问题是wordpress官网的<a href="http://wordpress.com">免费博客</a>虽然很好，但被GFW屏蔽了。</p>

<p><a href="http://aaditya.info/blog/2012/08/clipboard-to-email-python-code/">Clipboard to Email – Python Code</a>演示了如果将剪贴板里的内容通过email发送出去，也是一种解决问题的方法。</p>

<p>python 2.7.3 doc: <a href="http://docs.python.org/2/library/email-examples.html">18.1.11. email: Examples</a>有发送html文档的完整例子；</p>

<p>126和163也支持邮件发博客，用自己的邮箱发送到blogmail@188.com，可以用python的smtplib，通过smtp.163.com发送；</p>

<p>下面这个发送text邮件的实例在163博客上成功发布（sendmail方法如果返回一个空字典，说明发送成功）：</p>

<p> import smtplib
 # Import the email modules we&rsquo;ll need
 from email.mime.text import MIMEText
 # Create a text/plain message
 msg = MIMEText(&lsquo;this is a test blog from email&rsquo;)
 me = &lsquo;<a href="&#x6d;&#97;&#x69;&#108;&#116;&#x6f;&#58;&#108;&#x65;&#101;&#95;&#99;&#x68;&#x61;&#x75;&#x40;&#x31;&#54;&#51;&#x2e;&#x63;&#111;&#x6d;">&#108;&#101;&#101;&#95;&#x63;&#104;&#97;&#117;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#x6d;</a>&rsquo;
 you = &lsquo;<a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#98;&#108;&#x6f;&#103;&#x6d;&#97;&#105;&#x6c;&#x40;&#49;&#x38;&#x38;&#x2e;&#x63;&#x6f;&#109;">&#x62;&#108;&#x6f;&#103;&#109;&#97;&#105;&#x6c;&#64;&#x31;&#x38;&#x38;&#46;&#99;&#111;&#x6d;</a>&rsquo;
 msg[&lsquo;Subject&rsquo;] = &lsquo;A Test Blog from Email&rsquo;
 msg[&lsquo;From&rsquo;] = me
 msg[&lsquo;To&rsquo;] = you
 # Send the message via our own SMTP server, but don&rsquo;t include the
 # envelope header.
 s = smtplib.SMTP(&lsquo;smtp.163.com&rsquo;)
 s.login(&lsquo;lee_chau&rsquo;, &lsquo;abaqus67&rsquo;)
 s.sendmail(me, [you], msg.as_string())
 s.quit()</p>

<hr />

<p>2013-04-13更新：</p>

<p>参考<a href="http://fun.blog.ustc.edu.cn/?p=148">从Evernote自动发博客到WordPress</a>，可以用<a href="https://eatags.com/">eatags.com</a>将笔记发布到wordpress.com上，设置好共享之后，要发布的笔记只要加上标签“ eat.wordpress.post ”（参考<a href="https://eatags.com/features%EF%BC%89%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E5%88%B0wordpress.com%E4%B8%8A%EF%BC%8C%E4%BB%8A%E5%A4%A9%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BB%93%E6%9E%9C%E5%8F%AF%E4%BB%A5%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%EF%BC%8C%E6%98%AF%E7%9B%AE%E5%89%8D%E6%89%80%E7%9F%A5%E6%9C%80%E5%A5%BD%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%88%96%E8%80%85%E7%94%A8">https://eatags.com/features%EF%BC%89%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E5%88%B0wordpress.com%E4%B8%8A%EF%BC%8C%E4%BB%8A%E5%A4%A9%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BB%93%E6%9E%9C%E5%8F%AF%E4%BB%A5%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%EF%BC%8C%E6%98%AF%E7%9B%AE%E5%89%8D%E6%89%80%E7%9F%A5%E6%9C%80%E5%A5%BD%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%88%96%E8%80%85%E7%94%A8</a><a href="http://www.evreblog.us">everblog.us</a>也能将evernote笔记发布到everblog.us网站上，但不能显示图片，everblog选中一个笔记本后会将该笔记本下所有的笔记都发布到everblog网站上，适合批量发布；</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/47">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/45">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/10/01/210506/">Dmenu Notes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/27/113819/">A Simple Ring Server</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/24/073009/">Xen on CentOS 6</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/20/105816/">Lightweight Web Browser Dwb</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/20/103138/">Set Time Synchronization on ArchLinux</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
