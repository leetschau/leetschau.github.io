
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="系统：Windows Server 2008 过程：参考How to configure a Telnet Server with Windows Server 2008 注意：Server Manager -> Configuration -> Local Users and &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/71/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A notes repository for Meteor.js, data mining, Linux, etc.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="leetschau.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/30/181506/">在Windows上部署Telnet Server</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-10-30T18:15:06+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>6:15 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>系统：Windows Server 2008</p>

<p>过程：参考<a href="http://www.windowsnetworking.com/articles_tutorials/configure-telnet-Server-Windows-Server-2008.html">How to configure a Telnet Server with Windows Server 2008</a></p>

<p>注意：Server Manager -> Configuration -> Local Users and Groups中添加Telnet Client用户；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/30/113230/">用反射机制在运行时创建对象并执行方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-10-30T11:32:30+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>11:32 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>根据类名创建对象</h1>

<p>要求：根据运行时得到的类名（字符串）创建对象。</p>

<h2>创建的对象没有参数</h2>

<p> Class&lt;?> clazz = Class.forName(&ldquo;com.foo.BarClass&rdquo;);
 Object date = clazz.newInstance();</p>

<h2>创建对象需要参数</h2>

<p> Class&lt;?> clazz = Class.forName(&ldquo;com.foo.MyClass&rdquo;);
 Constructor&lt;?> constructor = clazz.getConstructor(String.class, Integer.class);
 Object instance = constructor.newInstance(&ldquo;stringparam&rdquo;, 42);</p>

<p>参考：<a href="http://stackoverflow.com/questions/9886266/is-there-a-way-to-instantiate-a-class-by-name-in-java">is there a way to instantiate a class by name in java?</a></p>

<h1>执行方法调用</h1>

<p>对于实例方法，也就是非static方法，用"obj.method()&ldquo;方式调用，获得对象后可以按普通对象执行；对于静态（static）方法，需要用"ClassName.method()"方式调用，需要用到Java反射机制中的Method类，调用方法如下：</p>

<p> String className = &ldquo;edu.princeton.cs.algs4.Selection&rdquo;;
 Class&lt;?> clazz = Class.forName(className);
 System.out.println(&ldquo;Loaded class: &rdquo; + clazz);
 Method m = clazz.getDeclaredMethod(&ldquo;meth&rdquo;, new Class[] { int.class, int.class });
 System.out.println(&ldquo;Got method: &rdquo; + m);
 Object returnValue = m.invoke(null, 1, 5); // equals to &ldquo;Selection.meth(1,5);&rdquo;
 System.out.println(&ldquo;Return value of this method: &rdquo; + returnValue);</p>

<p>被调用的Selection.meth()方法：</p>

<p> public static int meth(int i, int j) {
  System.out.println(&ldquo;result=&rdquo; + (i + j + 10));
  return i + j + 10;
 }</p>

<p>这里要注意的是：</p>

<ol>
<li><p>className必须是包含包名的full name，</p></li>
<li><p>对于静态方法，m.invoke的第一个参数是null，如果是实例方法，第一个参数是执行这个方法的对象obj；</p></li>
</ol>


<h2>如何调用参数是数组的方法</h2>

<p>例如有下面一个方法：</p>

<p> public static void sort(Comparable[] a) {
  int N = a.length;
  for (int i = 0; i &lt; N; i++) {
   for (int j = i; j > 0 &amp;&amp; less(a[j], a[j-1]); j&ndash;) {
    exch(a, j, j-1);
   }
   assert isSorted(a, 0, i);
  }
  assert isSorted(a);
 }</p>

<p>用反射调用这个方法要注意参数列表的写法：</p>

<p> Double[] a = new Double{1000];</p>

<p> Class&lt;?> clazz = Class.forName(className);
 Method sortMethod = clazz.getDeclaredMethod(&ldquo;sort&rdquo;, Comparable[].class);
 Object[] param = { a };
 sortMethod.invoke(null, param);</p>

<p>最后一行如果写为invoke(null, a)会报"wrong number of arguments error"，原因是第3行的声明表明sort方法的参数只有一个，但Method.invoke方法的声明是：</p>

<p> Object invoke(Object obj, Object&hellip; args)</p>

<p>实际上就是invoke(Object obj, Object[] args)，这样invoke(null, a)方法会给sort方法注入1000个参数（而不是a这个数组本身），解决方法就是专门声明param={a}，然后invoke(null, param)。</p>

<p>参考：<a href="http://stackoverflow.com/questions/8189782/wrong-number-of-arguments-error-when-invoking-a-method">http://stackoverflow.com/questions/8189782/wrong-number-of-arguments-error-when-invoking-a-method</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/23/145637/">使用scp命令实现自动部署</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-10-23T14:56:37+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2012</span></span> <span class='time'>2:56 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>scp指令通过服务器上的SSH账号上传/下载文件，相当于基于SSH的FTP。下面ant脚本将打包好的目录上传到测试服务器上，省去了手工上传、解压、配置的麻烦：</p>

<p> <property name="deploy_host" value="10.0.2.75" />
 <property name="deploy_user" value="user" />
 <property name="deploy_pwd" value="pwd" />
 <property name="deploy_dir" value="/home/godu/godu2.3" />
 <target name="deploy" depends="create_zip">
  <scp todir="${deploy_user}:${deploy_pwd}@${deploy_host}:${deploy_dir}" trust="true">
   <fileset dir="${build.dir}">
    <exclude name="**/*.zip"/>
   </fileset>
  </scp>
 </target></p>

<p>注：</p>

<ul>
<li><p>Ant的classpath中要包含jsch-0.1.31.jar，否则scp指令会运行失败；</p></li>
<li><p>其中的trust=&ldquo;true"不可省略，否则报“reject HostKey”错误；</p></li>
<li><p>scp指令将fileset中的所有目录和文件（不包含fileset目录自身）拷贝到todir目录下，todir必须已经存在，其中重名的目录和文件将被覆盖；</p></li>
<li><p>不要忘写主机地址和目录之间的冒号；</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/18/194258/">Install Ubuntu Server on PC With USB Disk</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-10-18T19:42:58+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>7:42 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>使用的工具：</h1>

<ul>
<li><p><a href="http://www.pendrivelinux.com/downloads/Universal-USB-Installer/Universal-USB-Installer-1.9.1.2.exe">Universal-USB-Installer-1.9.1.2.exe</a>；</p></li>
<li><p>4G容量的U盘一个；</p></li>
<li><p>ubuntu-12.04.1-server-amd64.iso；</p></li>
</ul>


<h1>安装过程</h1>

<ol>
<li><p>用Universal-USB-Installer-1.9.1.2.exe制作一个ubuntu server 12.04的安装盘；</p></li>
<li><p>安装类型选"Ubuntu Server 12.04 Installer"；</p></li>
<li><p>用制作好的U盘启动计算机，按照屏幕提示安装即可。</p></li>
</ol>


<h1>注意事项</h1>

<ul>
<li><p>安装过程中需要拔掉网线（刚才未拔网线情况下安装grub这一步报"The &lsquo;grub-pc&rsquo; package failed to install into /target/ &hellip;&ldquo;错误，安装过程停止，拔掉网线，返回安装"base system"这一步重新安装一遍，grub安装成功。）</p></li>
<li><p>安装完毕后启动系统时需要插上网线，否则启动过程会停在"config network"这一步；</p></li>
</ul>


<h1>验证</h1>

<ul>
<li><p>可以用"ssh <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#58;&#99;&#x68;&#97;&#x64;&#x40;&#x31;&#x30;&#x2e;&#x33;&#49;&#x2e;&#49;&#46;&#51;&#x34;">&#x63;&#104;&#97;&#x64;&#x40;&#x31;&#x30;&#46;&#51;&#x31;&#46;&#x31;&#x2e;&#x33;&#52;</a>"连接Ubuntu Server；</p></li>
<li><p>用sudo passwd创建root用户密码，这次设置的密码是root；</p></li>
<li><p>安装组件时选择OpenSSH和Tomcat Server，安装完后可看到Java版本是1.6.22，Python版本是2.7.3；</p></li>
</ul>


<h1>关闭计算机</h1>

<p>以root用户执行：shutdown -P now</p>

<h1>其他</h1>

<p>刚才安装时硬盘上已有3个NTFS分区，在"Partition Policy"中选"Use Entire Partition"，可以保留NTFS分区，如果选"Entire Disk"，则整个磁盘会被格式化。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/17/173006/">Google & Chrome Notes</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-10-17T17:30:06+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>5:30 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li><p>Page zoom in/out: Ctrl -/=</p></li>
<li><p>Use chrome without IE proxy: add &ldquo;-no-proxy-server&rdquo; argument after chrome.exe(Windows)/chromium-browser(Ubuntu)</p></li>
<li><p>Focus between page, adress bar &amp; bookmark bar: F6 (frequently used to input a new url in a tab)</p></li>
<li><p>Search tips</p></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/15/160339/">安装Linux系统时的磁盘空间分配方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-10-15T16:03:39+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>4:03 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>主分区50GB（使用ext4格式），一个swap分区，大小为（内存+2）GB，但当内存小于2GB时，swap分区设为（内存*2）GB。</p>

<p>ext4是ext3的升级版。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/10/08/093202/">SVN服务搭建笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-10-08T09:32:02+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>9:32 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Windows平台</h1>

<p><a href="http://subversion.apache.org/">SVN官网</a>只提供源代码，不提供binary安装包，但<a href="http://alagazam.net/">Subversion Windows Installer</a>是一个不错的windows安装包站点，从上面下载zip版（svn-win32-1.7.6.zip），里面的svn.exe是客户端，要图形界面则可以使用TortoiseSVN-1.7.9.23248-win32-svn-1.7.6.msi（来自<a href="http://tortoisesvn.tigris.org/">TortoiseSVN</a>），安装过程如下：</p>

<ol>
<li><p>解压服务端包；</p></li>
<li><p>用"svnadmin create e:\svnRepo"在svnRepo下创建一个代码仓库；</p></li>
<li><p>修改e:\svnRepo\conf中的svnserve.conf: 取消注释"password-db = passwd"这一行</p></li>
<li><p>在e:\svnRepo\conf\passwd文件中添加用户和对应密码；</p></li>
<li><p>用"svnserve -d -r e:\svnRepo"启动svn服务器，或者用"start /min cmd /c svnserve -d -r e:\svnRepo"将其以单独窗口的方式启动；</p></li>
</ol>


<h2>验证</h2>

<p>运行<code>svn ls svn://localhost</code>查看库中代码目录和文件，
或者加-R，列出所有子目录，
或者安装tortoiseSVN，启动tortoiseSVN浏览器，在地址里写"svn://10.31.1.189"；</p>

<p>用<code>svn ls</code>选择好目录后，用<code>svn co</code>检出一个目录，在目录中添加一个测试文件"test"，
然后<code>svn add test</code>，<code>svn ci -m "test commit"</code>，客户端提示输入用户名和密码，
输入在$SVN_REPO/conf/passwd中配置的用户名密码，完成提交。</p>

<h2>说明</h2>

<ul>
<li><p>不需要安装apache httpd，svn服务的默认监听端口是3690，可以用netstat指令验证启动是否成功；</p></li>
<li><p>&ldquo;svnserve -d"服务由于系统重启或者其他原因停止后，可以用该指令重启SVN服务，库中的记录在重启后保持有效；</p></li>
<li><p>参考<a href="http://www.subversion.org.cn/?action-viewnews-itemid-1">Subversion快速入门教程</a>。</p></li>
</ul>


<p>另外下载了<a href="http://www.sliksvn.com">silk Svn</a>，发现只有客户端，放弃。</p>

<hr />

<p>2014-4-24更新</p>

<p>在Windows Server 2003上Apache + Subversion服务中添加一个新库：</p>

<ol>
<li><p>K:\svn>&ldquo;c:\Program Files\Subversion\bin\svnadmin.exe&rdquo; create GFrame</p></li>
<li><p>Add the following lines in &ldquo;c:\Program Files\Apache Group\Apache2\svnaccessfile&rdquo;:</p>

<p> gframe-dev=&hellip;</p>

<p> [gframe:/ ]
 @gframe-dev = rw
 @QA = rw
 @Manager = r
 bvt_common = r</p>

<ul>
<li>=</li>
</ul>
</li>
</ol>


<p>Note that group definition &ldquo;gframe-dev=&hellip;&rdquo; MUST before ALL the repo definitions, or the whole Subversion service will down because of the parse error of this access file. When you modify the access file to right format, you can access svn service at once without restart Apache service.</p>

<ol>
<li>Now you can access the new repo with URL &ldquo;<a href="http://10.0.2.59:8118/svn/gframe">http://10.0.2.59:8118/svn/gframe</a>&rdquo; in TortoiseSVN, add some basic folders, such as &ldquo;Development-Area&rdquo;, &ldquo;Test-Area&rdquo;, etc.</li>
</ol>


<h1>Ubuntu</h1>

<ol>
<li><p>sudo apt-get install subversion</p></li>
<li><p>sudo svnadmin create {repo_path}</p></li>
<li><p>nohup svnserve -d -r {repo_path} 1>{log_path} 2>{log_path} &amp;</p></li>
</ol>


<h1>CentOS</h1>

<p>安装后连接不上，且机器可以ping其他机器，但无法连接internet，放弃。</p>

<ol>
<li><p>安装subversion-1.7.4-0.1.el6.rfx.i686.rpm（来自<a href="http://subversion.apache.org/">Apache Subversion官网</a>）；</p></li>
<li><p>创建代码仓库：svnadmin /home/chad/Documents/svnRepo</p></li>
<li><p>修改/home/chad/Documents/svnRepo/conf中的svnserve.conf和passwd两个文件；</p></li>
<li><p>更改用户仓库的写权限以便用户提交代码：chown -R chad:chad /home/chad/Documents/svnRepo</p></li>
<li><p>客户端：在当前目录下检出代码仓库：新建一个目录作为working dir，在下面执行：svn co svn://localhost</p></li>
<li><p>新建一个文件aa；</p></li>
<li><p>svn add aa</p></li>
<li><p>svn ci -m &ldquo;comments for this check in&rdquo;</p></li>
</ol>


<p>遗留问题：只能在本机使用，由于虚拟机NAT方式，无法通过外部svn客户端连接；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/29/095503/">Linux系统CPU信息查询方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-29T09:55:03+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>9:55 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>lscpu</h1>

<p>运行<code>lscpu</code>命令，输出中，"CPU(s)&ldquo;是逻辑CPU数，"Socket(s)"是物理插槽数，"Core(s) per socket"是每颗CPU的核数，"Thread(s) per core"是每个核的线程数，一般是1或者2，后者叫做“超线程”。
逻辑CPU数是物理插槽数、核数和每核线程数3者的乘积。
平常所说的“CPU个数”，就是指逻辑CPU数，也就是"CPU(s)"的值。</p>

<h1>cat /proc/cpuinfo</h1>

<p>下面是一个实例：</p>

<pre><code>processor  : 0 
vendor_id  : GenuineIntel 
cpu family  : 6 
model   : 26 
model name  : Intel(R) Xeon(R) CPU   X5550 @ 2.67GHz 
stepping  : 5 
cpu MHz   : 2666.851 
cache size  : 8192 KB 
physical id  : 0 
siblings  : 8 
core id   : 0 cpu cores  : 4 
apicid   : 0 
fpu   : yes 
fpu_exception  : yes 
cpuid level  : 11 
wp   : yes 
flags   : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm syscall nx rdtscp lm constant_tsc ida nonstop_tsc pni monitor ds_cpl vmx est tm2 cx16 xtpr popcnt lahf_lm 
bogomips  : 5333.70 
clflush size  : 64 
cache_alignment  : 64 
address sizes  : 40 bits physical, 48 bits virtual 
power management: [8] 
processor  : 1 
... 
cpu cores  : 4 
... 
</code></pre>

<p>processor  : n &hellip; cpu cores  : 4 &hellip; processor  : 15 &hellip; cpu cores  : 4 &hellip;</p>

<p>【所以CPU(processor)的数量是最后一个cpu标号加1，每颗CPU的核数是其中"cpu cores"的值，这是一个有16颗4核CPU的服务器】</p>

<p>上面的结论错误，阅读cpuinfo的正确方法是：</p>

<ol>
<li><p>通过physical id确定有多少个物理CPU（即多少个CPU插槽socket，或者叫物理封装）；</p></li>
<li><p>通过cpu cores确定某一个物理CPU有多少核；</p></li>
<li><p>如果siblings数量与cpu core一致，说明没有超线程。反之如果siblings的值大于cpu cores，说明开启了超线程（hyperthreading），开启超线程的另一个证据是不同的processor拥有同样的core id，这一点可以用"cat /proc/cpuinfo|grep &ldquo;core id"确认；</p></li>
<li><p>processor的数量应该等于物理CPU的数量与siblings的乘积；</p></li>
</ol>


<p>根据以上方法分析，上面的服务器有两颗4核CPU（即两个CPU插槽，每个插槽上的CPU有4个核），开启了超线程，共有16个逻辑CPU。</p>

<p>参考<a href="http://www.richweb.com/cpu_info">Understanding Linux /proc/cpuinfo</a></p>

<h1>相关资料</h1>

<ul>
<li><p>查看CPU是32位还是64的方法是：cpuinfo的flags参数中是否有"lm"这一项，lm表示long mode，可以用"cat /proc/cpuinfo|grep &ldquo;\&lt;lm>"查询；</p></li>
<li><p>CPU超线程技术可以参考<a href="https://en.wikipedia.org/wiki/Hyper-threading">Hyper-threading</a>。</p></li>
</ul>


<h1>另：用free指令查看系统内存大小</h1>

<p>用free -g以GB为单位显示内存大小，另外可以通过查看cat /proc/meminfo指令结果第一行的方法确定物理内存大小；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/28/165932/">Linux中网络相关的配置文件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-28T16:59:32+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>4:59 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>/etc/hosts</h1>

<pre><code>10.31.1.71 servername1
10.31.1.52 servername2
</code></pre>

<p>当本机连接servername1时，通过这个文件将主机名映射为ip地址，相当于本机本部的DNS服务，对该文件的详细说明见Richard Petersen &ldquo;Linux: The Complete Reference&rdquo; p723: Identifying Hostnames: /etc/hosts。</p>

<h1>/etc/sysconfig/network</h1>

<p>用于定义主机的整体网络配置。</p>

<p> # /etc/sysconfig/network-scripts/ifcfg-eth0</p>

<p>专门定义eth0的属性，如果有多个网卡， network-scripts下可能还有ifcfg-eth1,ifcfg-eth2等几个文件。</p>

<h1>设置网卡eth0的IP地址</h1>

<pre><code>ifconfig &lt;eth0&gt; 10.31.1.251 netmask 255.255.255.0 up 
</code></pre>

<p>其中eth0是网卡名称，要根据ifconfig中列出的具体的网卡名字确定。</p>

<h1>修改主机名</h1>

<pre><code>hostname newHostname 
</code></pre>

<p>查询当前主机名：hostname</p>

<p>参见<a href="http://serverfault.com/questions/260034/what-is-the-difference-between-these-two-network-configuration-files">What is the difference between these two network configuration files?</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/09/27/201234/">源代码版本管理策略</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2012-09-27T20:12:34+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2012</span></span> <span class='time'>8:12 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文使用的方法基于Vincent Driessen的
<a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a>。</p>

<h1>分布式版本控制策略</h1>

<h2>总体架构</h2>

<p>主仓库（origin）中有两个<strong>永久</strong>分支：master和develop。</p>

<p>master上只保存生产环境可用版本，发布包只从这个分支上打；</p>

<p>develop用来收集可用的开发特性，BVT系统是从这个分支上获取代码做nightly builds。</p>

<p>每个开发者可能发起3种<strong>临时</strong>分支：feature, release和hotfix，
临时的意思是这3中分支最终都要被合并到某个永久分支（master/develop）中。</p>

<p>下面是详细说明。</p>

<ul>
<li><p>feature: 用来开发新产品特性的分支。</p>

<ul>
<li><p>from: develop; back into: develop.</p></li>
<li><p>命名规范：feature/&lt;特征名></p></li>
<li><p>生命周期：需要开发某个特征时，创建一个feature分支，当此特性开发完毕并通过测试，合并回develop后，分支消失，
或者此特征被放弃，分支被删除（或搁置）。</p></li>
<li><p>习惯上特征分支只由一个开发者完成，所以只存在于该开发者的本地仓库中。</p></li>
</ul>
</li>
<li><p>release: 用来完成发布的分支。</p>

<ul>
<li><p>from: develop; back into: master and develop.</p></li>
<li><p>命名规范：release/x.y.z</p></li>
<li><p>生命周期：当develop中的代码已经达到“发布一个版本”的状态时，创建一个release分支；
创建分支前，确定发布版本号，例如之前是1.1.5，这次是1.2，还是2.0？
根据版本号创建分支，修改对应文件（例如node应用中，package.json的version值）。
一些简单的bug修改也可以在这个分支上完成。
完成所有发布准备后，将此分支合并到develop和master上，然后删除此分支。</p></li>
<li><p>合并到master分支后，在master上用版本号打tag，别忘了把tag也push到origin上；</p></li>
</ul>
</li>
<li><p>hotfix: 用来修改线上版本bug的分支。</p>

<ul>
<li><p>from: master; back into: master and develop.</p></li>
<li><p>命名规范：hotfix/x.y.z</p></li>
<li><p>生命周期：开始修复bug时创建分支，修复后将分支合并到master和develop上，删除分支。</p></li>
<li><p>代码修改完成后，在版本信息文件中修改版本号第3组数字，例如将1.1.5改为1.1.6，然后合并分支。</p></li>
</ul>
</li>
</ul>


<p>各分支间的关系见Vincent Driessen的文章。</p>

<p><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.html">git-flow cheatsheet</a> by Daniel Kummer
给出了详细的图示说明已经各操作如何使用git-flow实现。</p>

<h2>版本号命名规则</h2>

<p>x.y.z格式的版本号中，x代表大版本，当无法保证API兼容时，大版本号加1；
y代表小版本，同一个大版本的各个小版本应互相兼容，每增加一个新功能，小版本号加1；
z代表修复bug或者其他未新增功能，但仍需记录的变化。</p>

<p>参考：<a href="http://semver.org/">Semantic Versioning</a>.</p>

<h2>评价</h2>

<p>这个分布式的版本系统结构清晰，易于理解和使用。</p>

<p>并且能解决不同现场的特殊需求问题：</p>

<p>如果某个A现场使用v1.0，B现场使用v2.0，现在A报了bug，则只能给A使用高版本（v2.1），
而不能通过在v1.0上打patch的方法解决，因为如果从master的tag v1.0处签出代码，修改bug，得到v1.0p1，还得将修改再合并到v2.0上，
而且v1.0p1将变成一个无法合并的分支，但如果采用升级版本的方式改bug，就要求版本间功能具备连续性，
如果为A现场的v1.0开发了一个特殊的功能X，又不能合并到master里去（因为其他现场不需要这个功能），
升级将导致A无法使用X。所以怎样将各现场的特殊需求与版本控制结合起来仍然是一个未解决的问题。</p>

<h2>后续工作</h2>

<ul>
<li><p>在分支上打tag的方法：<code>git tag -a &lt;tag-name&gt;</code>;</p></li>
<li><p>在Hg上重现上面的流程；</p></li>
</ul>


<h1>Hg的工作流程</h1>

<ol>
<li><p>在中心服务器origin上建立一个branch name为develop的分支；</p></li>
<li><p>假设开发者chad负责在现有版本上增加一个“使用正则表达式的预期-发送”功能，则chad先从origin上clone一份代码到"f:\ghost\tmpFiles\myProj"文件夹中；</p></li>
<li><p>将这份代码导入到Eclipse中，项目路径为d:\workspace\myProj，注意".hg"文件夹也要导入；</p></li>
<li><p>删除"f:\ghost\tmpFiles\myProj"中的仓库，打开新的d:\workspace\myProj仓库，新建一个branch命名为"exp-send-regex"；</p></li>
<li><p>Eclipse中开发功能，提交本地版本；</p></li>
<li><p>当功能稳定后由origin将chad的代码pull到自己的代码库中：</p>

<ol type="a">
<li><p>启动chad的hg web server；</p></li>
<li><p>在origin上用"pull selected changes from selected URL"，将chad上面测试稳定的“使用正则表达式的预期-发送”功能分支拉过来；</p></li>
<li><p>合并到develop分支中：在exp-send-regex分支顶端的changeset上右键->merge with local；</p></li>
</ol>
</li>
</ol>


<h1>其他资料</h1>

<p><a href="http://www.51testing.com/?uid-300987-action-viewspace-itemid-823031">版本控制的分支策略及初步实践</a></p>

<p><a href="http://juvenshun.iteye.com/blog/376422">Maven最佳实践：版本管理</a></p>

<p><a href="http://www.infoq.com/articles/agile-version-control">Version Control for Multiple Agile Teams</a></p>

<p><a href="http://stackoverflow.com/questions/597707/best-branching-strategy-when-doing-continuous-integration">Best branching strategy when doing continuous integration</a></p>

<p><a href="http://www.hillside.net/plop/plop98/final_submissions/P37.doc">Streamed Lines: Branching Patterns for Parallel Software Development</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/72">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/70">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/07/10/065540/">Manage Nodejs App With Forever</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/07/103347/">Transport JavaScript Objects Between Meteor Pages via URI</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/04/190036/">Learning Resources for Programming Language Theory</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/30/101243/">Trace File Change History in Git Repository</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/27/085109/">Control Linux Server With Tmux on Windows Client</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
