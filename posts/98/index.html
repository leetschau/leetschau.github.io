
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="// 使用方法：首先在一个空文本文件总写上需要做和的数字，每个数一行，选中所有数字，然后运行本脚本
var lineTerminator = &ldquo;\r\n&rdquo;;
var str = UltraEdit.activeDocument.selection;
var &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/98">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A note repository aims at Data Mining, Spark, Linux, Python.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:leetschau.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/18/141748/">计算总值的Ultraedit脚本</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-18T14:17:48+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>2:17 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>// 使用方法：首先在一个空文本文件总写上需要做和的数字，每个数一行，选中所有数字，然后运行本脚本
var lineTerminator = &ldquo;\r\n&rdquo;;
var str = UltraEdit.activeDocument.selection;
var resultArr = new Array();
resultArr = str.split(lineTerminator);
var itemCnt = resultArr.length;
var total = 0;
for (var i = 0; i &lt; itemCnt; i++) {
 total = total+parseFloat(resultArr[i]);
}
UltraEdit.activeDocument.bottom();
UltraEdit.activeDocument.write(&ldquo;\r\n======================\r\n&rdquo;);
UltraEdit.activeDocument.write(&ldquo;Total value is: &rdquo; + total + &ldquo; Yuan.\r\n&rdquo;);
UltraEdit.activeDocument.write(&ldquo;Totally &rdquo;+itemCnt+&ldquo; items in the list.&rdquo;);
//UltraEdit.outputWindow.write(&ldquo;Total value is: &rdquo; + total + &ldquo; Yuan.&rdquo;);
//UltraEdit.outputWindow.write(&ldquo;Totally &rdquo;+itemCnt+&ldquo; items in the list.&rdquo;);</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/18/082950/">怎样获取计算机上次启动时间</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-18T08:29:50+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:29 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>有时候需要知道最近一次电脑的启动时间（或者关闭时间），在Windows XP下，有两种方法可以得到这个信息。</p>

<p> 事件查看器方法</p>

<p>【控制面板->管理工具->事件查看器->系统（ 在左边的窗口中，Win7下是在“Windows日志”下 ）->右键->属性】，在打开的【系统属性】窗口中选择【筛选器】，在【事件类型】下面 仅 选中【信息】复选项，并在【事件来源】列表中选择【eventlog】项，【确定】返回事件查看器。右边的窗口中，【事件】下面为6005的表示开机，6006表示关机。基本上可以查看最近3个月以来计算机的开/关机记录。</p>

<p> 日志文件方法</p>

<p>【开始->运行】里输入“schedlgu.txt”，在打开的文件里搜索“任务计划程序服务”，下面的一行就是计算机 开/关机记录。下面是一个样例：</p>

<p> ……</p>

<p> “任务计划程序服务”</p>

<p>  已退出于 2010-10-12 18:21:45</p>

<p> “任务计划程序服务”</p>

<p>  已启动于 2010-10-13 8:11:11
……</p>

<p>注：Notepad++ v5.6/5.7的中文搜索好像有问题，经常出现搜不到的情况，如果搜不到 “任务计划程序服务”这个字符串，可以用其他文本编辑器（如Vim、UE等）试试。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/13/134904/">Javadoc中插入超链接</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-13T13:49:04+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>1:49 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Javadoc中插入的超链接可分为两类，一类是在@see 标记后面写上class_qualified_name#method_name，编译后的效果是“另请参见……”，例如 @see  com.boco.godu.gapi.IResult#getByteArray() 编译后得到：</p>

<p> 另请参见：</p>

<p>   IResult.getByteArray()</p>

<p> 另一类是使用html的语法插入超链接，例如超链接是 <a href ="IConnection.html#admin_port_demo">样例  </a> ，被指向的地方是 <h3 id=admin_port_demo>场景一：查看网元磁盘空间（数据端口的同步场景）  </h3> ，这样就可以实现指向一个html文件的某一小节。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/13/095716/">字符编解码的故事</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-13T09:57:16+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>9:57 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文为转载，有少许修订，原文出处不详。 很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们认为8个开关状态作为原子单位很好，于是他们把这称为&#8221;字节&#8221;。 再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出更多的状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为&#8221;计算机&#8221;。 开始计算机只在美国用。八位的字节一共可以组合出256（2的8次方）种不同的状态。 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端设备或者打印机遇上这些约定好的字节时，就要做一些约定的动作。遇上 00x10, 终端就换行，遇上0x07, 终端就向人们嘟嘟叫，例好遇上0x1b, 打印机就打印反白的字，对于终端就用彩色显示字母。他们看到这样很好，于是就把这些0x20（十进制32）以下的字节状态称为&#8221;控制码&#8221;。 他们又把所有的空格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的 文字了。大家看到这样，都感觉很好，于是大家都把这个方案叫做 ANSI 的&#8221;Ascii&#8221;编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的ASCII方案来保存英文文字。 后来，就像建造巴比伦塔一样，世界各地的都开始使用计算机，但是很多国家用的不是英文，他们用到的许多字母在ASCII中根本没有，为了也可以在计算机中保存他们的文字，他们决定采用127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128到255这一页的字符集被称&#8221;扩展字符集&#8221;。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！ 等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉，并且规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的&#8221;全角&#8221;字符，而原来在127号以下的那些就叫&#8221;半角&#8221;字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做&#8221;GB2312&#8221;。GB2312 是对 ASCII 的中文扩展。 但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人（如朱镕基的“镕”字）。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准（<a href="https://en.wikipedia.org/wiki/Windows-936%EF%BC%89%EF%BC%8CGBK">https://en.wikipedia.org/wiki/Windows-936%EF%BC%89%EF%BC%8CGBK</a> 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 &ldquo;DBCS&#8221;（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： &#8220;一个汉字算两个英文字符！一个汉字算两个英文字符……&rdquo; 因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个&#8221;汉字系统&#8221;，专门用来处理汉字的显示、输入的问题，但是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么&#8221;倚天汉字系统&#8221;才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！ 正在这时，大天使加百列及时出现了 —— 一个叫ISO（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它&#8221;Universal Multiple-Octet Coded Character Set&#8221;，简称 UCS, 俗称 &ldquo;UNICODE&#8221;。 UNICODE 开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ascii里的那些&#8221;半角&#8221;字符，UNICODE 包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于&#8221;半角&#8221;英文符号只需要用到低8位，所以其高 8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。 这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的strlen函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是 的，从 UNICODE 开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的&#8221;一个字符&#8221;！同时，也都是统一的&#8221;两个字节&#8221;，请注意&#8221;字符&#8221;和&#8221;字节&#8221;两个术语的不同， &#8220;字节&#8221;是一个8位的物理存贮单元，而&#8221;字符&#8221;则是一个文化相关的符号。在UNICODE 中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。 从前多种字符集存在时，那些做多语言软件的公司遇上过很大麻烦，他们为了在不同的国家销售同一套软件，就不得不在区域化软件时也加持那个双字节字符集咒语，不仅要处处小心不要搞错，还要把软件中的文字在不同的字符集中转来转去。UNICODE 对于他们来说是一个很好的一揽子解决方案，于是从 Windows NT 开始，MS 趁机把它们的操作系统改了一遍，把所有的核心代码都改成了用 UNICODE 方式工作的版本，从这时开始，WINDOWS 系统终于无需要加装各种本土语言系统，就可以显示全世界上所有文化的字符了。 但是，UNICODE 在制订时没有考虑与任何一种现有的编码方案保持兼容，这使得 GBK 与UNICODE 在汉字的内码编排上完全是不一样的，没有一种简单的算术方法可以把文本内容从UNICODE编码和另一种编码进行转换，这种转换必须通过查表来进行。 如前所述，UNICODE 是用两个字节来表示为一个字符，他总共可以组合出65535不同的字符，这大概已经可以覆盖世界上所有文化的符号。如果还不够也没有关系，ISO已经准备了UCS-4方案，说简单了就是四个字节来表示一个字符，这样我们就可以组合出21亿个不同的字符出来（最高位有其他用途），这大概可以用到银河联邦成立那一天吧！ UNICODE 来到时，一起到来的还有计算机网络的兴起，UNICODE 如何在网络上传输也是一个必须考虑的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8就是每次8个位传输数据，而UTF16就是每次16个位，只不过为了传输时的可靠性，从UNICODE到 UTF时并不是直接的对应，而是要过一些算法和规则来转换。 受到过网络编程加持的计算机僧侣们都知道，在网络里传递信息时有一个很重要的问题，就是对于数据高低位的解读方式，一些计算机是采用低位先发送的方法，例如我们PC机采用的 INTEL 架构；而另一些是采用高位先发送的方式。在网络中交换数据时，为了核对双方对于高低位的认识是否是一致的，采用了一种很简便的方法，就是在文本流的开始时向对方发送一个标志符——如果之后的文本是高位在位，那就发送&#8221;FEFF&#8221;，反之，则发送&#8221;FFFE&#8221;。不信你可以用二进制方式打开一个UTF-X格式的文件，看看开头两个字节是不是这两个字节？  从UNICODE到UTF8的转换规则（见<a href="http://www.zehnet.de/2005/02/12/unicode-utf-8-tutorial/">  Unicode, UTF-8 tutorial </a>） ：   Unicode  UTF-8   0000 - 007F  0xxxxxxx   0080 - 07FF  110xxxxx 10xxxxxx   0800 - FFFF  1110xxxx 10xxxxxx 10xxxxxx<br/>
 例如&#8221;汉&#8221;字的Unicode编码是6C49。6C49在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。这个过程的代码实现见笔记 Unicode到UTF-8编码转换的Java实现 。
 讲到这里，我们再顺便说说一个很著名的奇怪现象：当你在 windows 的记事本里新建一个文件，输入&#8221;联通&#8221;两个字之后，保存，关闭，然后再次打开，你会发现这两个字已经消失了，代之的是几个乱码！呵呵，有人说这就是联通之所以拼不过移动的原因。 其实这是因为GB2312编码与UTF8编码产生了编码冲撞的原因。 当一个软件打开一个文本时，它要做的第一件事是决定这个文本究竟是使用哪种字符集的哪种编码保存的。软件一般采用三种方式来决定文本的字符集和编码： 检测文件头标识，提示用户选择，根据一定的规则猜测 最标准的途径是检测文本最开头的几个字节，开头字节 Charset/encoding,如下表： EF BB BF UTF-8 FE FF UTF-16/UCS-2, little endian FF FE UTF-16/UCS-2, big endian FF FE 00 00 UTF-32/UCS-4, little endian. 00 00 FE FF UTF-32/UCS-4, big-endian. 当你新建一个文本文件时，记事本的编码默认是ANSI（代表系统默认编码，在中文系统中一般是GB系列编码）, 如果你在ANSI的编码输入汉字，那么他实际就是GB系列的编码方式，在这种编码下，&#8221;联通&#8221;的内码是： c1 1100 0001 aa 1010 1010 cd 1100 1101 a8 1010 1000 注意到了吗？第一二个字节、第三四个字节的起始部分的都是&#8221;110&#8221;和&#8221;10&#8221;，正好与UTF8规则里的两字节模板是一致的， 于是当我们再次打开记事本时，记事本就误认为这是一个UTF8编码的文件，让我们把第一个字节的110和第二个字节的10去掉，我们就得到了&#8221;00001 101010&#8221;，再把各位对齐，补上前导的0，就得到了&#8221;0000 0000 0110 1010&#8221;，不好意思，这是UNICODE的006A，也就是小写的字母&#8221;j&#8221;，而之后的两字节用UTF8解码之后是0368，这个字符什么也不是。这就是只有&#8221;联通&#8221;两个字的文件没有办法在记事本里正常显示的原因。</p>

<p>而如果你在&#8221;联通&#8221;之后多输入几个字，其他的字的编码不见得又恰好是110和10开始的字节，这样再次打开时，记事本就不会坚持这是一个utf8编码的文件，而会用ANSI的方式解读之，这时乱码又不出现了。</p>

<p>2012-8-9补充：汉字基本都在Unicode区间的4E00~9FA5，所以所以UTF-8编码后一定是3个字节，不可能是2个字节。</p>

<p>完整的Unicode字符编码表见Unicode官网的 Code Charts 。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/12/135950/">文字的编码问题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-12T13:59:50+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>1:59 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我们需要将文字保存在磁盘上，但磁盘上只能存储0和1（实际上是存储介质的两种状态），不能存储文字，这就出现了一个问题，如何将文字转换为二进制数字串？</p>

<p>文件的编码/解码就是解决文字&lt;=>二进制串这一环节如何相互转换的问题。</p>

<p> 简单地说，GBK和Unicode分别是一种码表，也就是为每一个字符指定一个两个字节组成的代码，例如 “汉”字的Unicode编码为0x6C49，GBK编码为0xBABA（0x是一个字头，表示后面的是16进制字串）。</p>

<p> Unicode编码 Unicode由ISO（国际标谁化组织）制定，它虽然解决了各种语言之间转换的难题，但也有问题，首先是不论什么字符都2个字节表示，网络上英文信息占大部分，由此造成的空间浪费很可观，其次是 Unicode不兼容ASCII编码方案，为了解决这些问题，出现了 UTF-8方案。</p>

<p> Unicode到UTF-8的转换方法详见 字符编解码的故事 。</p>

<p> GBK编码 GBK编码规则：《汉字内码扩展规范(GBK)》（ 全国信息技术标准化技术委员会 ）：
 01-09区为特殊符号；16-55区为一级汉字，按拼音排序；56-87区为二级汉字，按部首/笔画排序。
每个汉字及符号以两个字节来表示。第一个字节称为“高位字节”，第二个字节称为“低位字节”，用这个字的区、位号加上0xA0就得到了对应的字节码。例如“啊”字是 第16区第1个字，所以 区位码是 1601 ， 编码方法：0xA0+ 16 = 0x B0 ， 0xA0+ 1 = 0x A1 ，所以得到“啊”的 字节码  B0A1 ，可以用UltraEdit查看字符的字节码验证。</p>

<p> GB2312是GBK的早期版本，能表示6000个汉字，由于容量较小，现已被GBK取代。</p>

<p> 解码过程</p>

<p> 在Windows系统中打开文件时，使用猜的方式选择解码方案。如果文件开头使用了FEFF或FFFE，就认为是Unicode/UTF-8编码，否则为ANSI编码，在中文系统下，就是用GBK解码。GBK解码时，如果一个字节大于 0x7F（ 127），就证明这个字节与后面的字节组成了一个汉字，由于汉字的字节码总大于0xA0，英文字节码总小于 0x7F ，因此二者泾渭分明，不会混淆。</p>

<p> 用猜的方式确定文件的编码方案绝大多数情况下没有问题，但凡事总有特例，详见 字符编解码的故事 对“联通”编码/解码过程的说明。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/11/173852/">用Python做不同进制间的数字转换</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-11T17:38:52+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>5:38 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>将其他进制数字转换为10进制数字</p>

<p> 调用Python内置int()函数把该字串转为数字。以下为在Python解释器编程环境下的操作示范：
把十六进制的字串转为十进制数字：</p>

<blockquote><blockquote><blockquote><p>int(&lsquo;ff&rsquo;, 16)
255
 把十进制数字转换为以十六进制表示之字串</p></blockquote></blockquote></blockquote>

<p>调用内置的hex()函数：</p>

<blockquote><blockquote><blockquote><p>hex(255)</p></blockquote></blockquote></blockquote>

<p>&lsquo;0xff &rsquo;</p>

<p> 文字和十六进制数字的互相转换</p>

<p>调用BinAscii模块其中的b2a_hex()函数，可把以ASCII编码的文字以十六进制表示：</p>

<blockquote><blockquote><blockquote><p>import binascii</p>

<p>print binascii.b2a_hex(&lsquo;联通&rsquo;)
c1aacda8</p></blockquote></blockquote></blockquote>

<p>反之也可把以十六进制表示的文字，换成以ASCII编码的文字：</p>

<blockquote><blockquote><blockquote><p>print binascii.a2b_hex(&lsquo;baba&rsquo;)
汉</p></blockquote></blockquote></blockquote>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/11/165327/">UNIX文件的编码问题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-11T16:53:27+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>4:53 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>根据目前的实验结果，在Windows下生成的ANSI编码文件转为Unix格式后，Unix脚本（例如用awk命令取该文件某一行的某一段数据）可以正确读取； Windows下生成的UTF-8编码文件转为Unix格式后， Unix脚本不能正确读取，因此日志文件在Notepad++中打开后，应为Unix, ANSI格式，在Ultraedit中应为Unix格式，而不是U8-UNIX格式。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/11/083523/">技术类书籍读书笔记撰写内容</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-11T08:35:23+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:35 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1 这本书的主要内容是什么？
1.1 概括这本书主要内容的关键字；
1.2 用尽量简短的句子说明这本书在说什么；
1.3 列出这本书的大纲，以及各部分之间的关系；
1.4 确定作者想要解决的问题；</p>

<p>2 我从这本书中得到了什么？
2.1 我希望通过这本书解决什么（哪些）问题？
2.2 针对这个（这些）问题此书是怎么论述的？（读书笔记的主体部分）
2.3 此书的论述与我的问题相关度如何？还有哪些地方本书没有涉及？</p>

<p>2.4 简要叙述此书还有哪些有价值的信息？</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/09/170608/">网络通信框架选型</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-09T17:06:08+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>5:06 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>事件驱动的异步IO通信框架
 Apache Mina , JBoss Netty , Grizzly (Java), Twisted , gevent (python), eventmachine (Ruby), POE (Perl), Node.js (JavaScript), libevent &copy;</p>

<p>各框架实现的Echo Server</p>

<p> Twisted , libevent (不是echo server，但讲了很多基础知识), gevent , eventmachine , Node.js , Netty , Grizzly , POE ，按先后顺序进行学习。</p>

<p>选型的依据：</p>

<p> 功能： 截取模式：
 Mina: Filter-Handler;
Netty/Grizzly: Handler only</p>

<p> 支持的Filter/Handler：</p>

<p>Mina: blacklist filters, compression filters, connection throttling filters, SSL filters, logging filters, protocol codecs such as delimiter based, and HTTP. Grizzly provides support for SSL, custom protocol codecs, logging, and HTTP;</p>

<p>Netty: Base64 encoding/decoding, delimiter based codecs, fixed length codecs, HTTP handlers, logging handlers, Java object serialization/deserialization codecs, Google Protocol Buffer codecs, SSL handlers, simple string codecs, and handlers used to control bandwidth, traffic shaping, etc. There are also several utility handlers that may be used to build custom handlers such as a replay handler, timeout handler , frame decoder, etc;（Netty在支持基于已有的Handler构建用户Handler方面更灵活）</p>

<p> 高级缓存</p>

<p>Netty: ChannelBuffer中封装了多个ByteBuffer实例的引用（而非拷贝），支持zero copy，支持标记与重设“读指针”(Reader)索引，支持搜索、切片、读写不同类型数据；</p>

<p>Mina: 与Netty基本类似，但不支持zero copy（在Mina 3中实现）；</p>

<p> Socket and Protocol Independence</p>

<p>三者均支持，使通信框架底层技术变化（例如从NIO向AIO过渡）时，无需更新业务逻辑代码；</p>

<p> 可定制的协议与POJO</p>

<p>三者均支持，POJO在网络传输中的作用是什么？</p>

<p> 线程模型</p>

<p>三者均使用线程池模型，应付高并发能力良好；</p>

<p> 性能：</p>

<p>速度：MINA能够满足要求（并发800+），Netty=Grizzly>MINA；</p>

<p>内存占用量：Netty=Mina&lt;Grizzly
 扩展性：采用此框架的项目代码是否易于修改，易于在已有功能基础上拓展新功能； 易用性：框架的简洁程度，API Docs是否完善，Tutorials是否丰富，论坛是否活跃； 与GODU的整合能力/迁移成本；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/09/100259/">用WinHTTrack下载博客</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-10-09T10:02:59+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>10:02 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>创建一个存放博客的总目录，例如： “E:\MyDoc\WinHTTrackFiles\Blogs”；
 启动WinHTTrack；
 【下一步】之后在【工程名】里写“李四”，【总保存路径】里写“E:\MyDoc\WinHTTrackFiles\Blogs”，这样所有网站内容就会被下一步；
 【操作】选【下载网站】（如果是更新，则双击李四.whtt文件即可）；
 【Web地址】填博客地址；
 【选项->限制->最大深度】设为2，【最大外部链接深度】设为0。 勾选【 选项->链接->首先保存html文件 】；
 开始下载进程后，【已扫描链接】后面的数据由三部分组成，例如：248/251(+5)，其中251表示需要下载的所有链接数量，248表示已下载的链接数量，+5含义尚不清楚。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/99">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/97">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/03/30/181242/">Convert MS Word File to PDF Files</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/30/175224/">Scrapy Notes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/27/173224/">优化网站加载速度的方法</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/26/203002/">Deploy Meteor Application Manually</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/25/195307/">Deploy Meteor App With MUP</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
