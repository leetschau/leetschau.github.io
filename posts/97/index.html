
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="设计产品的类结构时，有些类的作用是与产品的其他部分交互，因此必须是public类型的，但又不希望暴露给用户，因此打产品包的javadoc时，这些类是不生成javadoc的。假设某个包里共有10个接口，其中有一个是不生成javadoc的，写出另外9个接口名显然是很dirty的方法， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/97/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A notes repository for Meteor.js, data mining, Linux, etc.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="leetschau.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/13/111815/">Javadoc动作中排除某些类</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-06-13T11:18:15+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>11:18 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>设计产品的类结构时，有些类的作用是与产品的其他部分交互，因此必须是public类型的，但又不希望暴露给用户，因此打产品包的javadoc时，这些类是不生成javadoc的。假设某个包里共有10个接口，其中有一个是不生成javadoc的，写出另外9个接口名显然是很dirty的方法，比较好的方法是定义一个exclude，例如：</p>

<p><target name="javadoc" depends="compile"></p>

<pre><code>&lt;javadoc sourcepath="${src.dir}" destdir="${build.javadoc.dir}"

    encoding = "GBK" docencoding = "GBK"

    packagenames ="com.boco.godu.gapi.exception" &gt;

    &lt; sourcefiles &gt;

       &lt; fileset dir="${src.dir}/com/boco/godu/gapi"&gt;

           &lt;include name="*.java"/&gt;

           &lt; exclude name="IConnPool.java"/&gt;

       &lt;/fileset&gt;

    &lt;/ sourcefiles &gt;

&lt;/javadoc&gt;
</code></pre>

<p></target></p>

<p>上面的例子表明，对于整个包（package）统一生成javadoc的，采用的内嵌的packagenames定义（可以用逗号隔开多个包名），对于需要exclude的包，用<sourcefiels>+<fileset>定义，可以非常方便的使用exclude功能。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/10/164558/">Job Control of Unix</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-06-10T16:45:58+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>4:45 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>主要参考书籍：Unix For Dummies: Chapter 13: Job Control.</p>

<p>一个Job有前台（foreground）和后台（background）两种运行方式；</p>

<p>前后程序的转换：</p>

<p> 直接（启动时）作为后台程序运行：当一个命令后面加上" &amp;&ldquo;时（&amp;前有一个空格），就进入了后台运行模式；</p>

<p> 中途前台=>后台：一个正在前台运行的命令用快捷键 Ctrl+Z 将其挂起（不消耗CPU时间），然后用 bg 命令使其进入后台运行状态；</p>

<p> 后台=>前台：所有后台运行的job可以用 jobs 命令列出，其中带+号的是当前job，其余是非当前job。用 fg %n 的方法将一个后台job转换到前台，其中n是jobs命令中给出的序号；</p>

<p>如果需要终止某个job，先用 jobs 列出，然后用 kill %n 的方法停止；</p>

<p>后台程序需要用户输入时，将进入停止状态；当用户使用 stty tostop 命令打开免输出打扰时，后台程序的要输出时将进入停止状态；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/02/173819/">如何获得Java文件的当前目录</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-06-02T17:38:19+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2011</span></span> <span class='time'>5:38 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>测试用例所在工程目录为： D:/workspace/EasyMockDemo，若想获得当前类所在路径：
 package org.leechau.groovyEmbedded;</p>

<p> import org.junit.Test;</p>

<p> public class HelloWorld {</p>

<p>  @Test</p>

<p>  public void HelloTest() throws Exception {</p>

<p>   String path = this.getClass(). getResource(&ldquo;&rdquo;) .getPath();</p>

<p>   System.out.println(path);</p>

<p>  }</p>

<p> }</p>

<p>输出：
 /D:/workspace/EasyMockDemo/bin/org/leechau/groovyEmbedded/
 如果将 getResource(&ldquo;&rdquo;)改为getResource(&ldquo;/&rdquo;)，则输出为：
  /D:/workspace/EasyMockDemo/bin/</p>

<p> 如果希望获得项目目录，则用：
 System.out.println(System.getProperty(&ldquo;user.dir&rdquo;));
 输出为：
 D:\workspace\EasyMockDemo</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/31/172859/">Groovy文件与类的关系</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-31T17:28:59+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2011</span></span> <span class='time'>5:28 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Python中，文件是一个模块，可以包含多个类、函数或者普通语句，但Groovy采用了与Java一样的机制，即一个文件对应一个类，</p>

<p>具体的实现机制如下：（主要参考了 Groovy in Action : page:190）</p>

<p>在Groovy中类和文件的对应关系并不像Java中那么固定(Java中一个文件只能有一个声明为public的类和其他一些非公共的类和内嵌类) 。在同一个groovy文件中可以包含多个public的类定义。具体规则如下：</p>

<ol>
<li><p>纯脚本：如果在一个groovy文件中没有任何类定义，它将被当做script来处理，也就意味着这个文件将被透明的转换为一个Script类型的类，这个类的类名是脚本的文件名（不含扩展名和包名，在default包中）。groovy文件的内容被打包进run方法，另外在新产生的类中被加入一个main方法使外部代码可以执行该脚本；</p></li>
<li><p>纯类（类名是文件名）：如果在groovy文件正好有一个类的定义，并且该类的名字与文件名称相同，那么这就和java中的类与文件的一一对应关系相同。在一个groovy文件中可以包含多个不同可见性的类定义，并且没有强制性的要求其中有一个类的类名与文件名相同。groovyc编译器会很乐于把该文件中定义的所有的类都编译成*.class文件。如果你希望能够直接调用这个groovy script，比如说在使用groovy命令行或者在某个IDE中执行，那么你应该在该文件中的第一个类中定义一个main方法；</p></li>
<li><p>脚本/类混合：在一个groovy文件中可以混合类的定义和脚本定义。在这种情况下，那些脚本代码将会放入默认存在的主类（文件名类）的run方法，所以在这种情况下你不应该再定义一个和文件同名的类，否则会出现“类重复定义”错误。反过来说，如果显式地定义了主类，则主类之外，除了定义其他类，不能有任何其他脚本代码（包括语句和函数）；</p></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/31/172555/">如何进行Groovy的单元测试</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-31T17:25:55+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2011</span></span> <span class='time'>5:25 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Groovy的单元测试可以通过两种方法进行，一是用JUnit框架，二是用Groovy自己的TestSuite测试。JUnit测试代码是Java代码，GroovyTestSuite的测试代码是groovy代码，且只能一次运行测试类中所有的TestCase，灵活性较JUnit方法稍差。下面是一个实例：</p>

<p>被测试类（Song.groovy文件内容）：
 package  org.leechau.ut;</p>

<p> class  Song {
    def  name
    def  artist
    def  genre
  String toString(){
     &ldquo;${ name }, ${  artist }, ${ genre  }&rdquo;
  }
    def  getGenre(){
     genre ?. toUpperCase ()
  }
 }</p>

<p> class  Song2 {
    def  name2
    def  ex(){
     println  name2
  }</p>

<h2> } </h2>

<p> JUnit测试文件（SongTest.java）：
  package  org.leechau.ut;</p>

<p> import  org.junit.Assert;
 import  org.junit.Test;</p>

<p> public  class  SongTest {</p>

<p>   @Test
    public  void  testToString() {
    Song sng =  new  Song();
    sng.setArtist(  &ldquo;Lee&rdquo; );
    Assert. assertEquals ( &ldquo;Lee&rdquo; , sng.getArtist());
  }
 }</p>

<hr />

<p> Groovy测试文件（TestSong2.groovy）：
  package  org.leechau.ut2;</p>

<p> import  groovy.util.GroovyTestCase</p>

<p> import  org.leechau.ut.Song
 import  org.leechau.ut.Song2</p>

<p> class  SongTest2  extends  GroovyTestCase{</p>

<pre><code>void  testGetGenre() { 
 def  sng =  new  Song() 
sng.setGenre  "Pop" 
 assertEquals (sng.getGenre(),  "POP" ) 
</code></pre>

<p>  }</p>

<pre><code>void  testSong2(){ 
 def  sng2 =  new  Song2() 
sng2.setName2  "Song2" 
 assertEquals (sng2.getName2(),  "Song2" ) 
</code></pre>

<p>  }
 }</p>

<hr />

<p> 且需要进行运行设置：
 1. 在Java Application中新建一个run configuration；</p>

<ol>
<li><p>Main标签下的Main Class写：groovy.util.GroovyTestSuite，且勾选“Include System Libraries when searching for a main class”；</p></li>
<li><p>Arguments标签下program arguments下写上测试脚本的相对路径，如：src\org\leechau\ut2\SongTest2.groovy；</p></li>
<li><p>运行该配置；</p></li>
</ol>


<p> 结果如下：</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/26/092619/">在48服务器上安装并使用PyScripter编辑的方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-26T09:26:19+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>9:26 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>类似于BVT这样的脚本一般都运行在服务器上，在本机调试好再移动到服务器上比较麻烦，理想方法是在服务器上直接调试python源代码，这就需要有IDE支持，下面说明了在48服务器上使用绿色版PyScripter的完整过程。</p>

<ol>
<li><p>以用户名 ser2 登录48服务器（地址：10.0.2.48）；</p></li>
<li><p>将PyScripter_confs_on48.zip解压到C:\Documents and Settings\ serv2 \Application Data下，即PyScripter.ini的绝对路径为：</p></li>
</ol>


<p> C:\Documents and Settings\serv2\Application Data\PyScripter\PyScripter.ini</p>

<ol>
<li><p>解压PyScripter-v2.4.1.zip到任意位置，运行其中的PyScripter.exe启动PyScripter；</p></li>
<li><p>从SVN上下载源代码；</p></li>
</ol>


<hr />

<p>注1：第2步的目的是将PyScripter常用的设置（如字号大小，背景颜色，快捷键等）一次性设置好，这些设置都保存在前述的</p>

<p>&ldquo; C:\Documents and Settings\serv2\Application Data\PyScripter\PyScripter.ini "文件中。</p>

<p>注2：第1步中的登录用户名要与第2步中的路径名一致（这里都是serv2），否则当前用户没有其他用户目录的写权限，不可能解压文件；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/25/123121/">Ivy可以在ant中直接使用的变量</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-25T12:31:21+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>12:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在 ant 文件中使用&lt;ivy:resolve/>进行解析后，可以使用如下变量：</p>

<p>ivy.organisation</p>

<p>ivy.module</p>

<p>ivy.revision</p>

<p>ivy.resolved.configurations</p>

<p>例如如下代码：
   <target  name= "UT_junit"  depends=  "cleanForZip" >
   <mkdir dir="${junit.test.result}"/>
     <javac  srcdir= "${test.src.dir}"  destdir= "${test.class.dir}"  encoding= "GBK" >
      <classpath>
       <pathelement  location= "${build.dist.dir}/${ ivy.module }-${ ivy.revision }.jar" />
       <path  refid= "lib.path" />
       <path  refid= "test.lib.path" />
      </classpath>
     </javac>
 需要注意的是由于这些变量仅在 &lt;ivy:resolve/>后才生成，因此不要用<property name="..." value="${ivy.module}" />将它们的赋给一个变量，因为所有的变量赋值都是在任务（target）之前进行的（不论赋值的位置是否在包含&lt;ivy:resolve/>的target之后），因此变量肯定是得不到上述变量的值的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/19/094133/">射手网字幕编码修改笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-19T09:41:33+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>9:41 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>用射手播放器自动下载的视频用文本编辑器打开后经常是乱码，实验后发现主要是由于这些文件使用Big5编码格式，用Notepad2就可以进行编码转换，但Notepad2没有中文繁简体转换的功能，用Word进行转换是一种比较完整的解决方案，下面是详细操作过程：</p>

<p>用Word打开这个srt文件，Word会自动侦测其编码格式；</p>

<p>打开文件后，选中所有文本后用【审阅->繁转简】转为简体并保存：在【是否保存为这种格式】对话框里选“否”，然后在保存对话框中将【保存类型】选为【纯文本(*.txt)】，文件名框中将扩展名改为srt，在随后出现的编码对话框里【文本编码】选【其他编码】，在编码列表里选【Unicode (UTF-8)】，确定即可。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/16/162950/">CD管理和检索软件比较</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-16T16:29:50+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>4:29 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>之前一直用EverCD+，考虑到鸡蛋不能放在一个篮子里，又找了几款功能类似的进行了比较，主要考察一下几个功能：</p>

<p> 多个镜像：一个数据文件可以包含多个目录的镜像，便于数据管理和搜索； 目录更新：目录内容发生变化后，更新其在管理软件中的镜像（对于一次性写光盘不存在更新问题）； 多种搜索类型：除了按名称搜索，还能按大小、日期等搜索； 导出、导入为通用数据文件：如csv、xml文件等；</p>

<p> 备选软件
 WhereIsIt：商业软件，暂未找到破解版； VVV (Virtual Volumes View)：开源软件（C++写成），无需安装，支持多个镜像，支持更新和搜索，不能导入，能够导出为CSV文件；有源代码下载，体积小巧（Windows压缩包4MB，源代码2MB）； Visual CD：免费软件，需安装， 间接支持多个镜像（ 一个vcc文件只能对应一个目录镜像，但可以在多个vcc文件内搜索 ）， 支持更新和搜索，不能导入csv和xml，导出功能强（能够导出为html、txt、rtf和txt格式）； Offline CD Browser：免费软件，数据文件放在了默认的安装文件内，安全性差，界面老土，支持更新和搜索，多种搜索类型，无导入和导出功能； Blue Mirror DVD/CD Indexer：安装过程需要联网，间接支持多个镜像（一个数据文件只包含一个镜像，但可以用“Merge with File”合并多个数据文件），似乎没有更新功能和搜索功能，可以导出为CSV文件； EverCD+：支持导出为xml文件； GCstar：安装文件很大，似乎是一个个人文档管理软件，严格来说不属于光盘管理软件； 总结</p>

<p>VVV无需安装，体积小，功能完善，开源，是EverCD+比较好的替代品；</p>

<p>这类软件都没有从csv、xml文件导入的功能，所以目前的EverCD+数据文件可能无法导入到其他软件中。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/13/163122/">Haskell Notes</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-13T16:31:22+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>4:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Installation</h1>

<pre><code>sudo apt-get install aptitude
sudo aptitude install haskell-platform
</code></pre>

<p>verified on Linux Mint 14 Xfce.</p>

<p>Install hoogle (offline documentation of Haskell):</p>

<pre><code>cabal update
cabal install alex happy &amp;&amp; cabal install hoogle
</code></pre>

<p>Ref: <a href="http://stackoverflow.com/questions/11753979/cabal-install-hoogle-error">http://stackoverflow.com/questions/11753979/cabal-install-hoogle-error</a></p>

<p>Very slow, you can use <a href="http://www.haskell.org/hoogle/">the online version</a>;</p>

<p>modify ~/.cabal/conifg:</p>

<pre><code>remote-repo: old.hackage.haskell.org:http://old.hackage.haskell.org
</code></pre>

<p>Ref:</p>

<p><a href="http://hackage.haskell.org/">http://hackage.haskell.org/</a></p>

<p><a href="http://www.haskell.org/haskellwiki/Hoogle">http://www.haskell.org/haskellwiki/Hoogle</a></p>

<pre><code>$ cabal update
$ cabal install hoogle
$ ~/.cabal/bin/hoogle data # create database
$ ~/.cabal/bin/hoogle map # search "map"
</code></pre>

<p>Save the following lines to ~/.ghci to enable you use &ldquo;:hoogle&rdquo; or &ldquo;:doc&rdquo; to get doc info in ghci:</p>

<pre><code>:def hoogle \x -&gt; return $ ":!hoogle \"" ++ x ++ "\""       
:def doc \x -&gt; return $ ":!hoogle --info \"" ++ x ++ "\""
</code></pre>

<h1>Sample Project</h1>

<p>Based on <a href="http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program;">http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program;</a></p>

<ol>
<li><p>create home folder: <code>take haq</code>;</p></li>
<li><p>create source file &ldquo;Haq.hs&rdquo;;</p></li>
<li><p>stick it in version control:</p>

<pre><code> git init
 git add Haq.hs
 git commit -m "add first source"
</code></pre></li>
<li><p>add a build system: <code>cabal init</code>;</p></li>
<li><p>modify .cabal file: add &ldquo;Haq.hs&rdquo; after &ldquo;&ndash; main-is:&rdquo; and uncomment this line(delete &ldquo;&ndash;&rdquo;); If you donot specify the license type, comment out the line &ldquo;license-file&rdquo;;</p></li>
<li><p>cabal update</p></li>
<li><p>cabal install &ndash;prefix=<dst_folder> &ndash;user</p></li>
<li><p>run app: <code>bin/haq me</code> under <dst_folder>, or run app in-place (under current directory): dist/build/haq/haq me</p></li>
</ol>


<p>verified on Haskell Platform 7.4.2, Linux Mint 14:</p>

<p>$ ghc &ndash;version</p>

<p>The Glorious Glasgow Haskell Compilation System, version 7.4.2</p>

<h1>Miscellaneous</h1>

<ul>
<li><p>ghc: compiler</p></li>
<li><p>ghci: interactive shell;</p></li>
<li><p>runghc: run haskell script without compile</p></li>
<li><p>Compile haskell source file to executable:</p>

<pre><code>  $ ghc --make &lt;FileName&gt;.hs -o &lt;ExeFileName&gt;
</code></pre></li>
</ul>


<p>for example:</p>

<pre><code>$ ghc --make Test.hs -o test
</code></pre>

<h1>GHCi usage</h1>

<ul>
<li><p>get current working directory: :!pwd (you can use :!<shell_cmd> to run any shell command);</p></li>
<li><p>turn on/off type declaration: :set +t, :unset +t</p></li>
<li><p>get type information of a object: :t</p></li>
<li><p>define local variable and show bindings:</p>

<pre><code>  let x = 3, 
  :show bindings
</code></pre></li>
<li><p>load module: :m +Data.Ratio</p></li>
<li><p>change cwd: :cd <path_name></p></li>
<li><p>load file: :l <file_name></p></li>
<li><p>quit ghci shell: :q</p></li>
<li><p>get function doc: :i <func_name></p></li>
</ul>


<h1>Syntax</h1>

<ul>
<li><p>comments: &ndash;</p></li>
<li><p>comparison: /=, >, &lt;</p></li>
<li><p>boolean operation: not, || , &amp;&amp;</p></li>
<li><p>Haskell requires type names to start with an uppercase letter, and variable names must start with a lowercase letter.</p></li>
<li><p>To construct a rational number: 11 % 29 (after &ldquo;:m +Data.Ratio&rdquo;)</p></li>
<li><p>values in &ldquo;where&rdquo;, &ldquo;case&rdquo; and &ldquo;let&rdquo; clause must keep the SAME indentions;</p></li>
</ul>


<h1>Shell Interaction Library</h1>

<p>shqq, shelly</p>

<p>Ref: <a href="http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts">Shelly: Write your shell scripts in Haskell</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/98">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/96">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/11/20/104508/">Clear Chrome DNS Cache</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/19/103131/">Linux的图形化Git客户端</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/02/093547/">Move Window Between Multiple Screens via Tmux</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/31/011200/">Synchronize Data From MongoDB to Elasticsearch</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/30/131706/">Elasticsearch River for MongoDB</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
