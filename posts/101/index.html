
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="Integrating CMMI and Agile Development: Case Studies and Proven Techniques for Faster Performance Improvement http://www.sei.cmu.edu/library/ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/101">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A note repository aims at Data Mining, Spark, Linux, Python.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:leetschau.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/08/160726/">CMMI相关图书</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-08T16:07:26+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>4:07 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Integrating CMMI and Agile Development: Case Studies and Proven Techniques for Faster Performance Improvement</p>

<p> <a href="http://www.sei.cmu.edu/library/abstracts/books/9780321714107.cfm">http://www.sei.cmu.edu/library/abstracts/books/9780321714107.cfm</a></p>

<p>CMMI Survival Guide: Just Enough Process Improvement</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/06/103753/">Java的classpath与package</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-06T10:37:53+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>6</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>10:37 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>按：这是一篇来自chinaitlab的讨论Java中classpath与package关系的文章，写的非常通俗易懂，尤其是篇末的红字段落，描述了package与classpath配合确定类文件位置的过程，很有用，平时用eclipse时这些设置都由eclipse自动完成了，但手工编译时不懂这些机制就无法正确设置每个类文件的package和import声明，从而无法正确的编译和运行，因此了解这一机制非常重要。
  Java 很诱人，但对于刚跨入Java门槛的初学者来说，编译并运行一个无比简单的Java程序简直就是一个恶梦。明明程序没错，但各种各样让人摸不着头脑的错误信息真的让你百思不得其解，许多在Java门口徘徊了很久的初学者就这样放弃了学习Java的机会，很是可惜。笔者也经历过这个无比痛苦的阶段，感觉到编译难的问题就出在classpath的设置及对package的理解之上。本文以实例的方式，逐一解决在编译过程中所出现的各种classpath的设置问题。本文实例运行的环境是在Windows XP + JDK 1.5.0。对其他的环境，读者应该很容易进行相应的转换。</p>

<ol>
<li><p>下载并安装JDK1.5.0，并按默认路径，安装到C:\Program Files\Java\jdk1.5.0中。</p></li>
<li><p>用鼠标单击WindowsXP的“开始”->“运行”，在弹出的运行窗口中输入cmd，按确定或回车，打开一个命令行窗口。</p></li>
<li><p>在命令行中输入：</p></li>
</ol>


<p>java</p>

<p> 有一列长长的洋文滚了出来，这是JDK告诉我们java这个命令的使用方法。其中隐含了一个重要信息，即JDK安装成功，可以在命令行中使用java此命令了。</p>

<ol>
<li>在命令行中输入</li>
</ol>


<p>javac
 屏幕显示：</p>

<p>&lsquo;javac&rsquo; 不是内部或外部命令，也不是可运行的程序或批处理文件。</p>

<p> 这是由于windows找不到javac这个命令的原因。这就不明白了，java与javac都是JDK在同一个子目录里面的两个文件，为什么可以直接运行java而不能直接运行javac呢？原来，Sun公司为了方便大家在安装完JDK后马上就可以运行Java类文件，在后台悄悄地将java命令加入了Path的搜索路径中，因此我们可以直接运行java命令(但我们是看不到它到底是在哪设置的，无论是在用户的Path或系统的Path设置中均找不到这个java存放的路径)。但Sun所做的到此为止，其他JDK的命令，一概不管，需要由用户自己添加到搜索路径中。</p>

<ol>
<li>既然如此，那我们自己添加Path的搜索路径吧。对“我的电脑”按右键，选“属性”，在“系统属性”窗口中选“高级”标签，再按“环境变量”按钮，弹出一个“环境变量”的窗口，在用户变量中新建一个变量，变量名为“Path”，变量值为&#8221;C:\Program Files\Java\jdk1.5.0\bin;%PATH%&ldquo;。最后的%PATH%的意思是说，保留原有的Path设置，且将目前的Path设置新加到其前面。一路按“确定”退出(共有3次)。关掉原来的命令行窗口，依照第2步，重新打开一个新的命令行窗口。在此窗口中输入</li>
</ol>


<p>javac</p>

<p>长长的洋文又出现了，这回是介绍javac的用法。设置成功。</p>

<ol>
<li>So far so good. 到目前为止，我们已经可以编程了。但是，这不是一个好办法。因为随着以后我们深入学习Java，我们就会用到JUnit、Ant或NetBeans等应用工具，这些工具在安装时，都需要一个名为指向JDK路径的“JAVA_HOME”的环境变量，否则就安装不了。因此，我们需要改进第5步，为以后作好准备。依照第5步，弹出“环境变量”的窗口，在用户变量中新建一个变量，变量名为“JAVA_HOME”，变量值为&#8221;C:\Program Files\Java\jdk1.5.0&#8221;。注意，这里的变量值只到jdk1.5.0，不能延伸到bin中。确定后，返回“环境变量”的窗口，双击我们原先设定的Path变量，将其值修改为“%JAVA_HOME%\bin;%PATH%”。这种效果与第5步是完全一样的，只不过多了一个JAVA_HOME的变量。这样，以后当我们需要指向JDK的路径时，只需要加入“%JAVA_HOME%”就行了。至此，Path路径全部设置完毕。一路确定退出，打开新的命令行窗口，输入</li>
</ol>


<p>javac</p>

<p>如果长长的洋文出现，Path已经设置正确，一切正常。如果不是，请仔细检查本步骤是否完全设置正确。</p>

<ol>
<li>开始编程。在C盘的根目录中新建一个子目录，名为“JavaTest”，以作为存放Java源代码的地方。打开XP中的记事本，先将其保存到JavaTest文件夹中，在“文件名”文本框中输入&#8221;Hello.java&#8221;。注意，在文件名的前后各加上一个双引号，否则，记事本就会将其存为&#8221;Hello.java.txt&#8221;的文本文件。然后输入以下代码：
public class Hello {
public static void main(String[] args) {
System.out.println(&ldquo;Hello, world&rdquo;);
}
}</li>
</ol>


<p>再次保存文件。</p>

<ol>
<li>在命令行窗口中输入</li>
</ol>


<p>cd C:\JavaTest</p>

<p>将当前路径转入JavaTest中。然后，输入</p>

<p>javac Hello.java</p>

<p> JDK就在JavaTest文件夹中编译生成一个Hello.class的类文件。如果出现“1 error”或“XX errors”的字样，说明是源代码的输入有误，请根据出错提示，仔细地按第7步的代码找出并修正错误。请读者注意甄别代码输入有误的问题与classpath设置有误的问题。因为本文是关于如何正确设置classpath及package的，因此，这里假设读者输入的代码准确无误。到目前为此，由于我们是在源代码的当前路径下编译，因此，不会出现classpath设置有误的问题。</p>

<ol>
<li>在命令行窗口中输入</li>
</ol>


<p>java Hello</p>

<p>屏幕出现了</p>

<p>Hello world</p>

<p> 成功了，我们已经顺利地编译及运行了第一个Java程序。
 但是，第8步及第9步是不完美的，因为我们是在JavaTest这个存放源码的文件夹中进行编译及运行的，因此，一些非常重要的问题并没有暴露出来。实际上，第8步的“javac Hello.java”及第9步的“java Hello”涉及到两个问题，一是操作系统如何寻找“javac”及“java”等命令，二是操作系统如何寻找“Hello.java”及“Hello.class”这些用户自己创建的文件。对于“javac”及“java”等命令，由于它们均是可执行文件，操作系统就会依据我们在第6步中设置好的Path路径中去寻找。而对于“Hello.java”及“Hello.class”这些文件，Path的设置不起作用。由于我们是在当前工作路径中工作，java及javac会在当前工作路径中寻找相应的java文件(class文件的寻找比较特殊，详见第11步)，
 因此一切正常。下面我们开始人为地将问题复杂化，在非当前工作路径中编译及运行，看看结果如何。
 10. 在命令行窗口中输入</p>

<p>cd C:
转入到C盘根目录上，当前路径离开了存放源码的工作区。输入</p>

<p>javac Hello.java</p>

<p>屏幕出现：</p>

<p>error: cannot read: Hello.java
1 error</p>

<p>找不到Hello.java了。我们要给它指定一个路径，告诉它到C:\JavaTest去找Hello.java文件。输入</p>

<p>javac C:\JavaTest\Hello.java</p>

<p>OK，这回不报错了，编译成功。</p>

<ol>
<li>输入</li>
</ol>


<p>java C:\JavaTest\Hello</p>

<p>这回屏幕出现：</p>

<p>Exception in thread &ldquo;main&rdquo; java.lang.NoClassDefFoundError: C:\JavaTest\Hello</p>

<p> 意思为在“C:\JavaTest\Hello”找不到类的定义。明明C:\JavaTest\Hello是一个.class文件，为什么就找不到呢？原来，Java对待.java文件与.class文件是有区别的。对.java文件可以直接指定路径给它，而java命令所需的.class文件不能出现扩展名，也不能指定额外的路径给它。</p>

<p>那么，如何指定路径呢？对于Java所需的.class文件，必须通过classpath来指定。</p>

<ol>
<li>依照第5步，弹出“环境变量”窗口，在用户变量中新建一个变量，变量名为“classpath”，变量值为&#8221;C:\JavaTest&#8221;。一路按“确定”退出。关闭原命令行窗口，打开新的命令行窗口，输入</li>
</ol>


<p>java Hello</p>

<p>“Hello world”出来了。由此可见，在“环境变量”窗口中设置classpath的目的就是告诉JDK，到哪里去寻找.class文件。这种方法一旦设置好，以后每次运行java或javac时，在需要调用.class文件时，JDK都会自动地来到这里寻找。因此，这是一个全局性的设置。</p>

<ol>
<li>除了这种在环境变量”窗口中设置classpath的方法之外，还有另一种方法，即在java命令后面加上一个选项classpath，紧跟着不带扩展名的class文件名。例如，</li>
</ol>


<p>java -classpath C:\JavaTest Hello</p>

<p> JDK遇到这种情况时，先根据命令行中的classpath选项中指定的路径去寻找.class文件，找不到时再到全局的classpath环境变量中去寻找。这种情况下，即使是没有设置全局的classpath环境变量，由于已经在命令行中正确地指定类路径，也可以运行。</p>

<p> 为了在下面的例子中更好地演示classpath的问题，我们先将全局的classpath环境变量删除，而在必要时代之以命令行选项-classpath。弹出“环境变量”窗口，选中“classpath”的变量名，按“删除”键。</p>

<p> 此外，java命令中还可以用cp，即classpath的缩写来代替classpath，如java -cp C:\JavaTest Hello。特别注意的是，JDK 1.5.0之前，javac命令不能用cp来代替classpath，而只能用classpath。而在JDK 1.5.0中，java及javac都可以使用cp及classpath。因此，为保持一致，建议一概使用classpath作为选项名称。</p>

<ol>
<li>我们再次人为地复杂化问题。关闭正在编辑Hello.java的记事本，然后将JavaTest文件夹名称改为带空格的“Java Test”。在命令行中输入</li>
</ol>


<p>javac C:\Java Test\Hello.java</p>

<p>长长的洋文又出来了，但这回却是报错了：</p>

<p>javac: invalid flag: C:\Java</p>

<p> JDK将带有空格的C:\Java Test分隔为两部分&#8221;C:\Java&#8221;及&#8221;Test\Hello.java&#8221;，并将C:\Java视作为一个无效的选项了。这种情况下，我们需要将整个路径都加上双引号，即</p>

<p>javac &ldquo;C:\Java Test\Hello.java&rdquo;</p>

<p>这回JDK知道，引号里面的是一个完整的路径，因此就不会报错了。同样，对java命令也需要如此，即</p>

<p>java -classpath &ldquo;C:\Java Test&rdquo; Hello</p>

<p> 对于长文件名及中文的文件夹，XP下面可以不加双引号。但一般来说，加双引号不容易出错，也容易理解，因此，建议在classpath选项中使用双引号。</p>

<ol>
<li>我们再来看.java文件使用了其他类的情况。在C:\Java Test中新建一个Person.java文件，内容如下：
public class Person {
private String name;</li>
</ol>


<p> public Person(String name) {
 this.name = name;
 }</p>

<p> public String getName() {
 return name;
 }
}</p>

<p>然后，修改Hello.java，内容如下：</p>

<p>public class Hello {
 public static void main(String[] args) {
 Person person = new Person(&ldquo;Mike&rdquo;);
 System.out.println(person.getName());
 }
}</p>

<p>在命令行输入</p>

<p>javac &ldquo;C:\Java Test\Hello.java&rdquo;</p>

<p>错误来了：</p>

<p>C:\Java Test\Hello.java:3: cannot find symbol
symbol: class Person
  JDK提示找不到Person类。为什么javac &ldquo;C:\Java Test\Hello.java&#8221;在第14步中可行，而在这里却不行了呢？第14步中的Hello.java文件并没有用来其他类，因此，JDK不需要去寻找其他类，而到了这里，我们修改了Hello.java，让其使用了一个Person类。根据第11步，我们需要告诉JDK，到哪里去找所用到的类，即使这个被使用的类就与Hello.java一起，同在C:\Java Test下面！输入</p>

<p>javac -classpath &ldquo;C:\Java Test&rdquo; &ldquo;C:\Java Test\Hello.java&rdquo;</p>

<p>编译通过，JDK在C:\Java Test文件夹下同时生成了Hello.class及Person.class两个文件。实际上，由于Hello.java使用了Person.java类，JDK先编译生成了Person.class，然后再编译生成Hello.class。因此，不管Hello.java这个主类使用了多少个其他类，只要编译这个类，JDK就会自动编译其他类，很方便。输入</p>

<p>java -classpath &ldquo;C:\Java Test&rdquo; Hello</p>

<p>屏幕出现了</p>

<p>Mike</p>

<p>成功。</p>

<ol>
<li>第15步说明了在Hello.java中如何使用一个我们自己创建的Person.java，而且这个类与Hello.java是同在一个文件夹下。在这一步中，我们将考查Person.java如果放在不同文件夹下面的情况。</li>
</ol>


<p>先将C:\Java Test文件夹下的Person.class文件删除，然后在C:\Java Test文件夹下新建一个名为DF的文件夹，并将C:\Java Test文件夹下的Person.java移动到其下面。在命令行输入</p>

<p>javac -classpath &ldquo;C:\Java Test\DF&rdquo; &ldquo;C:\Java Test\Hello.java&rdquo;</p>

<p>编译通过。这时javac命令没有什么不同，只需将classpath改成C:\Java Test\DF就行了。</p>

<p>在命令行输入</p>

<p>java -classpath &ldquo;C:\Java Test&rdquo; Hello</p>

<p> 这时由于Java需要找在不同文件夹下的两个.class文件，而命令行中只告诉JDK一个路径，即C:\Java Test，在此文件夹下，只能找到Hello.class，找不到Person.class文件，因此，错误是可以预料得到的：</p>

<p>Exception in thread &ldquo;main&rdquo; java.lang.NoClassDefFoundError: Person
  at Hello.main(Hello.java:3)</p>

<p> 果真找不到Person.class。在设置两个以上的classpath时，先将每个路径以双引号引起来，再将这些路径以“;”号隔开，并且每个路径与“;”之间不能带有空格。因此，我们在命令行重新输入：</p>

<p>java -classpath &ldquo;C:\Java Test&rdquo;;&ldquo;C:\Java Test\DF&rdquo; Hello</p>

<p> 编译成功。但也暴露出一个问题，如果我们需要用到许多分处于不同文件夹下的类，那这个classpath的设置岂不是很长！有没有办法，对于一个文件夹下的所有.class文件，只指定这个文件夹的classpath，然后让JDK自动搜索此文件夹下面所有相应的路径？有，只要使用package。</p>

<ol>
<li>package简介。Java中引入package的概念，主要是为了解决命名冲突的问题。比如说，在我们的例子中，我们设计了一个很简单的Person类，如果某人开发了一个类库，其中恰巧也有一个Person类，当我们使用这个类库时，两个Person类出现了命名冲突，JDK不知道我们到底要使用哪个Person类。更有甚者，当我们也开发了一个很庞大的类库，无可避免地，我们的类库中与其他人开发的类库中命名冲突的情况就会越来越多。总不能为了避免自己的类名与其他人开发的类名相同，而让每个编程人员都绞尽脑汁地将一个本应叫Writer的类强行改名为SarkuyaWriter，MikeWriter, SmithWriter吧？</li>
</ol>


<p> 现实生活中也是如此。假如你名叫张三，又假如与你同一单位的人中有好几个都叫张三，那你的问题就来了。某天单位领导在会上宣布，张三被任命为办公室主任，你简直不知道是该哭还是该笑。但如果你的单位中只有你叫张三，你才不会在乎全国叫张三的人有多少个，因为其他张三都分布在全国各地、其他城市，你看不见他们，摸不着他们，自然不会担心。</p>

<p> Sun从这个“张三问题”受到了很大的启发，为解决命名冲突问题，就采取了“眼不见心不烦”的策略：将每个类都归属到一个特定的区域中，在同一个区域中的所有类，都不允许同名；而不同区域的类，由于相互看不到，则允许有同名的类存在。这样，就解决了命名冲突的问题，正如北京的张三与上海的张三毕竟不是同一人。这个区域在Java中就叫package。由于package在Java中非常重要，如果你没有定义自己的package，JDK将会你的类都归到一个默认的无名package中。</p>

<p> 自定义package的名称可以由各个程序员自由创建。作为避免命名冲突的手段，package的名称最好足以与其他程序员的区别开来。在互联网上，每个域名都是唯一的，因此，Sun推荐将你自己的域名倒写后作为package的名称。如果你没有自己的域名，很可能只是因为囊中羞涩而不去申请罢了，并不见得你假想的域名与其他域名发生冲突。例如，笔者假想的域名是sarkuya.com，目前就是唯一的，因此我的package就可以定名为com.sarkuya。谢谢Java给了我们一个免费使用我们自己域名的机会，唯一的前提是倒着写。当然，每个package下面还可以带有不同的子package，如com.sarkuya.util，com.sarkuya.swing，等等。</p>

<p> 定义package的方式是在相应的.java文件的第一行加上“package packagename;”的字样，而且每个.java文件只能有一个package。实际上，Java中的package的实现是与计算机文件系统相结合的，即你有什么样的package，在硬盘上就有什么样的存放路径。例如，某个类的package名为com.sarkuya.util，那么，这个类就应该必须存放在com/sarkuya/util的路径下面。至于这个com/sarkuya/util又是哪个文件夹的子路径，第18步会谈到。</p>

<p> package除了有避免命名冲突的问题外，还引申出一个保护当前package下所有类文件的功能，主要通过为类定义几种可视度不同的修饰符来实现：public, protected, private, 另外加上一个并不真实存在的friendly类型。</p>

<p> 对于冠以public的类、类属变量及方法，包内及包外的任何类均可以访问；
protected的类、类属变量及方法，包内的任何类，及包外的那些继承了此类的子类才能访问；
private的类、类属变量及方法，包内包外的任何类均不能访问；
如果一个类、类属变量及方法不以这三种修饰符来修饰，它就是friendly类型的，那么包内的任何类都可以访问它，而包外的任何类都不能访问它(包括包外继承了此类的子类)，因此，这种类、类属变量及方法对包内的其他类是友好的，开放的，而对包外的其他类是关闭的。</p>

<p> 前面说过，package主要是为了解决命名冲突的问题，因此，处在不同的包里面的类根本不用担心与其他包的类名发生冲突，因为JDK在默认情况下只使用本包下面的类，对于其他包，JDK一概视而不见：“眼不见心不烦”。如果要引用其他包的类，就必须通过import来引入其他包中相应的类。只有在这时，JDK才会进行进一步的审查，即根据其他包中的这些类、类属变量及方法的可视度来审查是否符合使用要求。如果此审查通不过，编译就此卡住，直至你放弃使用这些类、类属变量及方法，或者将被引入的类、类属变量及方法的修饰符改为符合要求为止。如果此审查通过，JDK最后进行命名是否冲突的审查。如果发现命名冲突，你可以通过在代码中引用全名的方式来显式地引用相应的类，如使用</p>

<p>java.util.Date = new java.util.Date()</p>

<p>或是</p>

<p>java.sql.Date = new java.sql.Date()。</p>

<p>package的第三大作用是简化classpath的设置。还记得第16步中的障碍吗？这里重新引用其java命令：</p>

<p>java -classpath &ldquo;C:\Java Test&rdquo;;&ldquo;C:\Java Test\DF&rdquo; Hello</p>

<p> 我们必须将所有的.class文件的路径一一告诉JDK，而不管DF其实就是C:\Java Test的子目录。如果要用到100个不同路径的.class文件，我们就得将classpath设置为一个特别长的字符串，很累。package的引入，很好地解决了这个问题。package的与classpath相结合，通过import指令为中介，将原来必须由classpath完成的类路径搜索功能，很巧妙地转移到import的身上，从而使classpath的设置简洁明了。我们先看下面的例子。</p>

<ol>
<li>先在Hello.java中导入DF.Person。代码修改如下：
import DF.Person;</li>
</ol>


<p>public class Hello {
 public static void main(String[] args) {
 Person person = new Person(&ldquo;Mike&rdquo;);
 System.out.println(person.getName());
 }
}</p>

<p>再将DF子文件夹中的Person.java设置一个DF包。代码修改如下：
  package DF;</p>

<p>public class Person {
 private String name;
 public Person(String name) {
 this.name = name;
 }</p>

<p> public String getName() {
 return name;
 }
}</p>

<p>好了，神奇的命令行出现了：</p>

<p>javac -classpath &ldquo;C:\Java Test&rdquo; &ldquo;C:\Java Test\Hello.java&rdquo;
java -classpath &ldquo;C:\Java Test&rdquo; Hello
  尽管这次我们只设置了C:\Java Test的classpath，但编译及运行居然都通过了！事实上，Java在搜索.class文件时，共有三种方法：
一是全局性的设置，详见第12步，其优点是一次设置，每次使用；
二是在每次的javac及java命令行中自行设置classpath，这也是本文使用最多的一种方式，其优点是不加重系统环境变量的负担；
 三是根据import指令，将其内容在后台转换为classpath。JDK将读取全局的环境变量classpath及命令行中的classpath选项信息，然后将每条classpath与经过转换为路径形式的import的内容相合并，从而形成最终的classpath. 在我们的例子中，JDK读取全局的环境变量classpath及命令行中的classpath选项信息，得到C:\Java Test。接着，将import DF.Person中的内容，即DF.Person转换为DF\Person, 然后将C:\Java Test与其合并，成为C:\Java Test\DF\Person，这就是我们所需要的Person.class的路径。在Hello.java中有多少条import语句，就自动进行多少次这样的转换。而我们在命令行中只需告诉JDK最顶层的classpath就行了，剩下的则由各个类中的import指令代为操劳了。这种移花接木的作法为我们在命令行中手工地设置classpath提供了极大的便利。</p>

<p> 应注意的一点是，import指令是与package配套使用的，只有在某类通过“package pacakgename;”设定了包名后，才能给其他类通过import指令导入。如果import试图导入一个尚未设置包的类，JVM就会报错。</p>

<ol>
<li><p>我们接下来看，当使用JDK类库时，classpath如何设置。</p></li>
<li><p>修改Hello.java，内容如下：
import DF.Person;
import java.util.Date;</p></li>
</ol>


<p>public class Hello {
 public static void main(String[] args) {
 Date date = new Date();
 System.out.println(date);</p>

<p> Person person = new Person(&ldquo;Mike&rdquo;);
 System.out.println(person.getName());
 }
}</p>

<ol>
<li>JDK类库存放于C:\Program Files\Java\jdk1.5.0\jre\lib\rt.jar文件中。关于jar文件的介绍，已经超出了本文的范围， 感兴趣的读者可以阅读Horstmann写的Core Java一书 。</li>
</ol>


<p> jar文件可以用WinRar打开。用WinRar打开后，可以看到里面有一些文件夹，双击其中的java文件夹，再双击util的文件夹，可以在看到Date.class文件就在其中。如果你看过Data.java或其他JDK类库的源码(在C:\Program Files\Java\jdk1.5.0\src.zip文件中)，你就会发现，像java、util这些文件夹均是package。这也是Hello.java第2行中使用了import指令的原因。</p>

<p> 我们可以通过WinRar的查找功能来定位某个类所在的包。在“查找文件”的窗口中的“要查找的文件名”文本框中输入Date.class，就会查找出在rt.jar文件中存在两个Date.class文件，一个是java\sql\Date.class，另一个是java\util\Date.class。其中，sql下面的Date.class文件与数据库有关，并非我们这里所需，java\util\Date.class才是我们所要的。</p>

<p>  rt.jar文件就像本文中的C:\Java Test中一样，是JDK类库的唯一入口。我们可以在命令行的classpath选项指定.jar文件。需要注意，.jar文件的classpath设置有些特珠。在以前的例子中，我们设置classpath时都是设置了路径就行了，而对于.jar文件，我们必须将.jar文件名直接加到classpath中。</p>

<ol>
<li>在命令行输入</li>
</ol>


<p>javac -classpath &ldquo;C:\Program Files\Java\jdk1.5.0\jre\lib\rt.jar&rdquo;;&ldquo;C:\Java Test&rdquo; &ldquo;C:\Java Test\Hello.java&rdquo;
java -classpath &ldquo;C:\Program Files\Java\jdk1.5.0\jre\lib\rt.jar&rdquo;;&ldquo;C:\Java Test&rdquo; Hello</p>

<p>这样当然没有问题，因为我们指定了rt.jar文件及C:\Java Test两个classpath。但且慢，在命令行输入：</p>

<p>javac -classpath &ldquo;C:\Java Test&rdquo; &ldquo;C:\Java Test\Hello.java&rdquo;
java -classpath &ldquo;C:\Java Test&rdquo; Hello</p>

<p> 不可思议的是，编译及运行成功了！令人惊讶的是在我们将classspath只设置为C:\Java Test的情况下，JDK如何得出java.util.Date的classpath？</p>

<p> 原因在于，就像java的Path路径已经悄悄在后台设置好一样，rt.jar的classpath路径也悄悄地在后台设置了。因此，我们不必多此一举手工设置其classpath了。</p>

<ol>
<li>最后一点需要谈到的是，如果主类恰好也在一个package中(在大型的开发中，其实这才是一种最常见的现象)，那么java命令行的类名前面就必须加上包名。</li>
</ol>


<p> 在C:\Java Test下面新建一个文件夹，名为NF。将C:\Java Test下面的Hello.class删除，将Hello.java移到NF文件夹下。打开NF文件夹下的Hello.java，为其设置package属性。
  package NF;</p>

<p>import DF.Person;
import java.util.Date;</p>

<p>public class Hello {
 public static void main(String[] args) {
 Date date = new Date();
 System.out.println(date);</p>

<p> Person person = new Person(&ldquo;Mike&rdquo;);
 System.out.println(person.getName());
 }
}</p>

<p>编译与以前没啥区别，只不过是修正一下改过之后的路径。</p>

<p>javac -classpath &ldquo;C:\Java Test&rdquo; &ldquo;C:\Java Test\NF\Hello.java&rdquo;</p>

<p>而java命令行却有了变化</p>

<p>java -classpath &ldquo;C:\Java Test&rdquo; NF.Hello</p>

<p>上面命令行语句中，NF.Hello告诉JDK，Hello.class在NF的package下面。</p>

<p> 至此，本文有关classpath及package的问题的讨论已经全部结束。由此可见，Java的入门的确非常不易。如果初学Java的程序员一见到Java的编译竟是如此的复杂，多半就会抽身而退。因此，笔者认为，Sun在J2SE的Tutorial中故意将编译的问题尽量简单化，以吸引更多的Java初学者。一旦品尝了Java的香醇可口的美味后，就不用担心他们退出了，因为咖啡是非常容易让人上瘾的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/04/085500/">Java中classpath与包名关系的一个试验</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-04T08:55:00+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:55 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>通过修改源文件中包名和手工编译源文件的方法，说明使用Java引用的方法是：
JAR文件实际上是zip格式压缩包，假设包结构为dir_a/dir_b/c.class（dir_a目录下是dir_b目录，dir_b目录下是c.class文件），将该JAR包的绝对路径加入到classpath中，然后在源文件里用import a.b.c的方法使用c类。下面分别用手工编译、运行不同包名源文件的方法证明以上论述。
方案1：类文件中不写包名： DOS命令为： cd e:\ex\leechau
set CLASSPATH=e:\MyDoc\JEx\MinaServer\lib\slf4j-jdk14-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\slf4j-api-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\mina-core-2.0.0-RC1.jar;.
javac SamplMinaServerHandler.java
javac MyMinaServer.java
java MyMinaServer  SamplMinaServerHandler.java文件内容为：  // package ex.leechau;  import org.apache.mina.core.service.IoHandlerAdapter;  import org.apache.mina.core.session.IoSession;   public class SamplMinaServerHandler extends IoHandlerAdapter{   private int count=0;   //当一个客端端连结进入时   @Override   public void sessionOpened(IoSession session) throws Exception {   System.out.println(&ldquo;incomming client : &rdquo;+session.getRemoteAddress());   }   //当一个客户端关闭时   @Override   public void sessionClosed(IoSession session) {    System.out.println(&ldquo;one Clinet Disconnect !&rdquo;);   }   @Override   public void messageReceived(IoSession session, Object message)     throws Exception {    //我们己设定了服务器解析消息的规则是一行一行读取,这里就可转为String:    String s=(String)message;    // Write the received data back to remote peer    System.out.println(&ldquo;收到客户机发来的消息: &rdquo;+s);    //测试将消息回送给客户端    session.write(s+count);    count++;   }  }  MyMinaServer.java文件内容为：  // package ex.leechau;
import java.io.IOException;
import java.net.InetSocketAddress;
import org.apache.mina.core.filterchain.DefaultIoFilterChainBuilder;
import org.apache.mina.filter.codec.ProtocolCodecFilter;
import org.apache.mina.filter.codec.textline.TextLineCodecFactory;
import org.apache.mina.transport.socket.SocketAcceptor;
import org.apache.mina.transport.socket.nio.NioSocketAcceptor;
public class MyMinaServer {
  public static void main(String[] args) throws IOException {
   //创建一个非阻塞的Server端Socket,用NIO
  SocketAcceptor acceptor = new NioSocketAcceptor();
  //创建接收数据的过滤器
  DefaultIoFilterChainBuilder chain = acceptor.getFilterChain();
  //设定这个过滤器将一行一行(/r/n)的读取数据
  chain.addLast(&ldquo;myChin&rdquo;, new ProtocolCodecFilter(new TextLineCodecFactory()));
  //设定服务器端的消息处理器:一个SamplMinaServerHandler对象,
  acceptor.setHandler(new SamplMinaServerHandler());
  // 服务器端绑定的端口
  int bindPort=9988;
  //绑定端口,启动服务器
  acceptor.bind(new InetSocketAddress(bindPort));
  System.out.println(&ldquo;Mina server is listening on port: &rdquo; + bindPort);
  }
}  方案2：类文件中写包名，在源文件目录下编译： cd e:\ex\leechau
set CLASSPATH=e:\MyDoc\JEx\MinaServer\lib\slf4j-jdk14-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\slf4j-api-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\mina-core-2.0.0-RC1.jar;e:\
javac SamplMinaServerHandler.java
javac MyMinaServer.java
java MyMinaServer  SamplMinaServerHandler.java和MyMinaServer.java文件取消方案1中包名上的注释。
方案3：类文件中写包名，在项目根目录下编译： cd e:\
set CLASSPATH=e:\MyDoc\JEx\MinaServer\lib\slf4j-jdk14-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\slf4j-api-1.3.0.jar;e:\MyDoc\JEx\MinaServer\lib\mina-core-2.0.0-RC1.jar;.
javac ex/leechau/SamplMinaServerHandler.java
javac ex/leechau/MyMinaServer.java
java ex/leechau/MyMinaServer SamplMinaServerHandler.java和MyMinaServer.java文件与方案2一样。
以上3中方案都可以是Mina Server正常运行，但如果在有包名的情况下使用方案1的方法定义classpath，则编译MyMinaServer.java时会出现“无法识别SamplMinaServerHandler”错误。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/04/085015/">用UltraEdit Color Scheme Manager修改UE的配色主题</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-04T08:50:15+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>8:50 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>UltraEdit的各种配置信息都保存在一个叫UEdit32.ini的文件中，配色主题是其中的一部分，UltraEdit Color Scheme Manager为修改此部分提供了一个便捷的工具，用户可首先生成自己的配色文件（或者使用别人制作的配色文件），然后用它导入到UEdit32.ini中，就实现了添加配色主题的目的。具体步骤是：
 下载压缩包uecolors_v1.2.1.1006.zip，解压，运行其中的uecolors.exe；
 为UltraEdit Color Scheme Manager指定UE的ini文件位置【Settings->Set INI File Location】，根据版本不同，ini文件可能出现在两处：c:\Documents and Settings\Administrator\Application Data\IDMComp\UltraEdit\UEdit32.ini或者UE的安装目录下；
 【File->Open Scheme】将做好的配色主题文件导入（例如压缩包里自带的Borland.ueTheme），【File->Export Theme to UE】；
 运行UE，【View->Set Colors->Save】保存配色主题；
 关闭UE，打开UEdit32.ini，将默认的配色主题名字user scheme 1 改为自己定义的名字；</p>

<p>That&rsquo;s it.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/03/145318/">jEdit使用笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-03T14:53:18+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2010</span></span> <span class='time'>2:53 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>安装</h1>

<p>首先下载jar包，然后命令行执行：java -jar jeditInstall.jar</p>

<p>安装完毕后，在安装目录下执行：java -jar jedit.jar</p>

<h1>修改字体</h1>

<p>Options -> Global Options:</p>

<p> Text Area: Editor字体；</p>

<p> Appearence: 列表、工具栏等处的字体；</p>

<h1>Java开发相关插件</h1>

<ul>
<li><p>ProjectViewer, JavaSideKick, Console, JSwat或者JavaDebugger</p></li>
<li><p>Console: 修改字体：Options -> Plugin Options -> Console -> General -> Font;</p></li>
</ul>


<p>jEdit的问题与DrJava一样，就是不具备专用IDE（如Eclipse）的代码感知功能，例如动态检查语法错误，缺包（import语句解析失败）提示等，目前的解决方案是Eclipse + viPlugin；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/03/094208/">用Notepad++实现轻量级Java IDE</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-03T09:42:08+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2010</span></span> <span class='time'>9:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>打开Notepad++的命令窗口</p>

<p>主菜单【插件->NppExec->Show Console Dialog】</p>

<p>设置环境变量</p>

<p>设置JAVA_HOME为：f:\warez\Develop\Java\jdk1.5.0_16</p>

<p>验证：在npp命令窗口中输入javac并回车，如果输出javac的帮助信息说明环境变量设置成功；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/01/142409/">Eclipse插件安装方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-01T14:24:09+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2010</span></span> <span class='time'>2:24 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Eclipse SDK 3.7支持在dropins文件夹中安装插件，解压后的目录格式为：$ECLIPSE_DIR/dropins/<plugin_name>/plugins(features)，如下图所示：</p>

<p>$ECLIPSE_DIR/dropins</p>

<pre><code>|__IvyDE

| |__plugins

| |__features

|__Terracotta

  |__plugins
</code></pre>

<p>以上方法在Eclipse SDK 3.7下安装ivyde和terracotta两个插件成功。</p>

<p>下面是旧版Eclipse的安装方法，供参考。</p>

<p>Eclipse Galileo安装插件主要有3中方式：直接解压、菜单和外部插件。直接解压就是将插件中plugins和features目录中的文件解压到eclipse对应的目录中，这显然不是好办法，一旦插件要升级或者不想用了，卸载会变得及其困难。菜单方法就是用elipse菜单【Help->Install New Software】装插件，试了一下似乎不好用，插件管理确实是eclipse需要加强的地方（也或许是开发者认为做这个功能没必要？）。外部插件就是写link文件，比较而言这种方法是最好的，想卸载的时候只要去掉link文件就行了。</p>

<p>过程如下：</p>

<p>1、解压插件。确定插件解压目录，如f:\warez\IDEs\EclipsePlugins\，将插件解压到这个目录下，目录结构如下：</p>

<p> f:\warez\IDEs\EclipsePlugins\language\eclipse\plugins\</p>

<p>f:\warez\IDEs\EclipsePlugins\language\eclipse\features\</p>

<p>也就是保证每一个插件目录（这里是 language ）下是 eclipse，再下面是 plugins和features。</p>

<p> 2、在 eclipse解压目录 下新建文件夹   links（也就是links与eclipse.exe处在相同目录下），例如：</p>

<p> f:\warez\IDEs\Eclipse0901\eclipse.exe与f:\warez\IDEs\Eclipse0901\links\；</p>

<p> 3、在  links   下新建一个   link   文件，比如   language.start  ， 后缀名可以任意取，如   .link,.ini,.txt   等等   ,   只要 link 文件名和插件文件安装目录中的最后文件夹名一致即可， 在这里我的插件安装目录结构为  f:\warez\IDEs\EclipsePlugins\language\， 所以   link   文件名就命名为 language.start， 如果你的插件安装目录结构为 D:\eclipse\myPlugins\languagepack,   则 link   文件名应为 languagepack.start 。</p>

<p> 4、在 language.start 中写入如下一句话：path=F:/warez/IDEs/EclipsePlugins/language， 即 path= 你的插件安装目录（ 路径字符串中要用/代替\ ， language后面不要写“/” ）；</p>

<p> 5、启动 eclipse：在 f:\warez\IDEs\Eclipse0901下运行 eclipse -clean；</p>

<p> 如果发现查件没有安装成功，按下面的步骤debug：</p>

<p> 1、确认配置好插件启动eclipse时一定要用eclipse -clean的方法启动，这样eclipse会重新检查、加载一遍插件，之后再启动eclipse就不需要-clean参数了。  2、若还不行，删除 f:\warez\IDEs\Eclipse0901\configuration下的org.eclipse.update目录（这是一个记录插件更新情况的文件夹），删除掉这个文件夹后，   eclipse   会重新扫描所有的插件；</p>

<p> 3、若还不行，最有效的办法是分析工作目录下 .metadata目录下的.log文件（如 d:\workspace.metadata.log），如果插件未能正确加载，会在目录里给出加载插件失败的信息；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/09/01/094254/">设计原则</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-09-01T09:42:54+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2010</span></span> <span class='time'>9:42 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>依赖都定义在接口中（依赖倒置原则），接口的设计要符合“只有一个原因引起接口变化”（单一职责原则）。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/31/113536/">VBA语法概述</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-31T11:35:36+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2010</span></span> <span class='time'>11:35 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>1，标识符 是一种标识变量、常量、过程、函数、类等语言构成单位的符号，利用它可以完成对变量、常量、过程、函数、类等的引用。命名规则如下： A, 字母打头，由字母、数字和下划线组成，如 A987b_23Abc B, 字符长度小于40，（Excel2002以上中文版等，可以用汉字且长度可达254个字符） C, 不能与VB保留字重名，如public, private, dim, goto, next, with, integer, single等   2,运算符 是代表VB某种运算功能的符号。 A, 赋值运算符 = B, 数学运算符 &amp;、+ (字符连接符)、+(加)、-（减）、Mod（取余）、\（整除）、*（乘）、/（除）、-（负号）、^（指数） C, 逻辑运算符Not（非）、And（与）、Or（或）、Xor（异或）、Eqv（相等）、Imp（隐含） D, 关系运算符 = （相同）、&lt;>（不等）、>（大于）、&lt;（小于）、>=（不小于）、&lt;=（不大于）、Like、Is E, 位运算符 Not（逻辑非）、And（逻辑与）、Or（逻辑或）、Xor（逻辑异或）、Eqv（逻辑等）、Imp（隐含）   3,数据类型 VBA共有12种数据类型，具体见下表，此外用户还可以根据以下类型用Type自定义数据类型。  数据类型 类型标识符 字节 字符串型 String $ 字符长度(0-65400) 字节型 Byte 无 1 布尔型 Boolean 无 2 整数型 Integer % 2 长整数型 Long &amp; 4 单精度型 Single ! 4 双精度型 Double # 8 日期型 Date 无 8 公元100/1/1-9999/12/31 货币型 Currency @ 8 小数点型 Decimal 无 14 变体型 Variant 无 以上任意类型，可变 对象型 Object 无 4    4, 变量与常量: 1）VBA允许使用未定义的变量，默认是变体变量Variant。 2）在模块通用说明部份，加入 Option Explicit 语句可以强迫用户进行变量定义。 3）变量定义语句及变量作用域 Dim 变量 as 类型 &lsquo;定义为局部变量，如 Dim xyz as integer
Private  变量 as 类型 &#8216;定义为私有变量，如 Private   xyz as byte
Public  变量 as 类型 &#8216;定义为公有变量，如 Public   xyz as single
Global   变量 as 类型 &#8216;定义为全局变量，如 Globlal   xyz as date
Static  变量 as 类型 &#8216;定义为静态变量，如 Static xyz as double 一般变量作用域的原则是，那部份定义就在那部份起作用，模块中定义则在该模块那作用。 4）常量为变量的一种特例，用Const定义，且定义时赋值，程序中不能改变值，作用域也如同变量作用域。如下定义：Const Pi=3.1415926 as single   5,数组 是包含相同数据类型的一组变量的集合，对数组中的单个变量引用通过数组索引下标进行。在内存中表现为一个连续的内存块，必须用Global或Dim语句来定义。定义规则如下： Dim 数组名([lower to ]upper [, [lower to ]upper, ….]) as type ;Lower缺省值为0。二维数组是按行列排列，如XYZ(行，列)。 除了以上固定数组外，VBA还有一种功能强大的动态数组，定义时无大小维数声明；在程序中再利用Redim语句来重新改变数组大小，原来数组内容可以通过加preserve关键字来保留。如下例： Dim array1() as double : Redim array1(5) : array1(3)=250 : Redim preserve array1(5,10)   6,注释和赋值语句 1）注释语句是用来说明程序中某些语句的功能和作用；VBA中有两种方法标识为注释语句。  单引号 ’ ;如：’定义全局变量；可以位于别的语句之尾，也可单独一行  Rem ;如：Rem定义全局变量；只能单独一行  2）赋值语句是进行对变量或对象属性赋值的语句，采用赋值号 =，如X=123：Form1.caption=”我的窗口”。对对象的赋值采用：set myobject=object 或 myobject:=object   7,书写规范: 1）VBA不区分标识符的字母大小写，一律认为是小写字母； 2）一行可以书写多条语句，各语句之间以冒号 : 分开； 3）一条语句可以多行书写，以空格加下划线 _ 来标识下行为续行； 4）标识符最好能简洁明了，不造成歧义。   8,判断语句 1）If…Then…Else语句 If condition Then [statements][Else elsestatements]
如1：If A>B And C<D Then A=B+2 Else A=C+2
如2：If x>250 Then x=x-100
或者，可以使用块形式的语法：
If condition Then
[statements]
[ElseIf condition-n Then
[elseifstatements] &hellip;
[Else
[elsestatements]]
End If
如1:
If Number &lt; 10 Then
Digits = 1
ElseIf Number &lt; 100 Then
Digits = 2
Else
Digits = 3
End If 2）Select Case…Case…End Case语句 如1：
Select Case Pid
Case “A101”
Price=200
Case “A102”
Price=300
……
Case Else
Price=900
End Case 3）Choose 函数： choose(index, choce-1,choice-2,…,choice-n)，可以用来选择自变量串列中的一个值，并将其返回，index 必要参数，数值表达式或字段，它的运算结果是一个数值，且界于 1 和可选择的项目数之间。choice 必要参数，Variant表达式，包含可选择项目的其中之一。如： GetChoice = Choose(Ind, &ldquo;Speedy&rdquo;, &ldquo;United&rdquo;, &ldquo;Federal&rdquo;) 4）Switch函数： Switch(expr-1, value-1[, expr-2, value-2 _ [, expr-n,value-n]]) switch函数和Choose函数类似，但它是以两个一组的方式返回所要的值，在串列中，最先为TRUE的值会被返回。 expr 必要参数，要加以计算的 Variant 表达式。value 必要参数。如果相关的表达式为 True，则返回此部分的数值或表达式，没有一个表达式为 True，Switch 会返回一个 Null值。   9,循环语句 1）For Next语句 以指定次数来重复执行一组语句 For counter = start To end [Step step]  &rsquo; step 缺省值为1
[statements]
[Exit For]
[statements]
Next [counter]
如1：
For Words = 10 To 1 Step -1    &lsquo; 建立 10 次循环
For Chars = 0 To 9     &rsquo; 建立 10 次循环
MyString = MyString &amp; Chars   &lsquo; 将数字添加到字符串中
Next Chars       &rsquo; Increment counter
MyString = MyString &amp; &ldquo; &rdquo;   &lsquo; 添加一个空格
Next Words 2）For Each…Next语句:主要功能是对一个数组或集合对象进行，让所有元素重复执行一次语句 For Each element In group
Statements
[Exit for]
Statements
Next [element]
如1：
For Each rang2 In range1
With range2.interior
.colorindex=6
.pattern=xlSolid
End with
Next
这上面一例中用到了 With…End With 语句，目的是省去对象多次调用，加快速度；语法为：
With object
[statements]
End With 3）Do…loop语句 在条件为true时，重复执行区块命令 Do {while |until} condition  &rsquo; while 为当型循环，until为直到型循环，顾名思义，不多说啦
Statements
Exit do
Statements
Loop
或者使用下面语法
Do        &lsquo; 先do 再判断，即不论如何先干一次再说
Statements
Exit do
Statements
Loop {while |until} condition   10,其他类语句和错误语句处理 A, 其他循环语句:结构化程序使用以上判断和循环语句已经足够，建议不要轻易使用下面的语句，虽然VBA还支持。 1)Goto line 该语句为跳转到line语句行 2)On expression gosub destinatioinlist 或者 on expression goto destinationlist 语句为根据 exprssion表达式值来跳转到所要的行号或行标记 3)Gosub line…line…Return语句， Return 返回到 Gosub line行，如下例： Sub gosubtry()
Dim num
Num=inputbox(“输入一个数字，此值将会被判断循环”)
If num>0 then Gosub Routine1 ：Debug.print num：Exit sub
Routine1:
Num=num/5
Return
End sub 4)while…wend语句，只要条件为TRUE，循环就执行，这是以前VB老语法保留下来的，如下例： while condition &#8216;while I&lt;50 [statements] &#8216;I=I+1 wend &#8216;Wend B, 错误语句处理:执行阶段有时会有错误的情况发生，利用On Error语句来处理错误，启动一个错误的处理程序。语法如下： On Error Goto Line　　　&#8217;当错误发生时，会立刻转移到line行去
On Error Resume Next  &#8216;当错误发生时，会立刻转移到发生错误的下一行去
On Erro Goto 0    &#8216;当错误发生时，会立刻停止过程中任何错误处理过程   11,过程和函数 过程是构成程序的一个模块，往往用来完成一个相对独立的功能。过程可以使程序更清晰、更具结构性。VBA具有四种过程：Sub 过程、Function函数、Property属性过程和Event事件过程。 A, Sub过程:Sub 过程的参数有两种传递方式：按值传递(ByVal)和按地址传递(ByRef)。如下例：  B, Function函数:函数实际是实现一种映射，它通过一定的映射规则，完成运算并返回结果。参数传递也两种：按值传递(ByVal)和按地址传递(ByRef)。如下例： Function password(ByVal x as integer, byref y as integer) as boolean
If y=100 then y=x+y else y=x-y
x=x+100
if y=150 then password=true else password=false
End Function
Sub call_password ()
Dim x1 as integer
Dim y1 as integer
x1=12
y1=100
if password then ‘调用函数：1. 作为一个表达式放在=右端 ; 2. 作为参数使用
debug.print x1
end if
End sub C, Property属性过程和Event事件过程:这是VB在对象功能上添加的两个过程，与对象特征密切相关，也是VBA比较重要组成，技术比较复杂，可以参考相关书籍。   12,内部函数 在VBA程序语言中有许多内置函数，可以帮助程序代码设计和减少代码的编写工作。 A．测试函数
IsNumeric(x)         ‘是否为数字, 返回Boolean结果，True or False
IsDate(x)          ‘是否是日期, 返回Boolean结果，True or False
IsEmpty（x）         ‘是否为Empty, 返回Boolean结果，True or False
IsArray(x)           ‘指出变量是否为一个数组。
IsError(expression)        ‘指出表达式是否为一个错误值
IsNull(expression)        ‘指出表达式是否不包含任何有效数据 (Null)。
IsObject(identifier)        ‘指出标识符是否表示对象变量
B．数学函数
Sin(X)、Cos(X)、Tan(X)、Atan(x) 三角函数，单位为弧度
Log(x) 返回x的自然对数
Exp(x)返回 ex
Abs(x) 返回绝对值
Int(number)、Fix(number) 都返回参数的整数部分，区别：Int 将 -8.4 转换成 -9，而 Fix 将-8.4 转换成 -8
Sgn(number) 返回一个 Variant (Integer)，指出参数的正负号
Sqr(number) 返回一个 Double，指定参数的平方根
VarType(varname) 返回一个 Integer，指出变量的子类型
Rnd（x）返回0-1之间的单精度数据，x为随机种子
C．字符串函数
Trim(string)         去掉string左右两端空白
Ltrim(string)         去掉string左端空白
Rtrim(string)         去掉string右端空白
Len(string)         计算string长度
Left(string, x)       取string左段x个字符组成的字符串
Right(string, x)       取string右段x个字符组成的字符串
Mid(string, start,x)     取string从start位开始的x个字符组成的字符串
Ucase(string)         转换为大写
Lcase(string)         转换为小写
Space(x)         返回x个空白的字符串
Asc(string)         返回一个 integer，代表字符串中首字母的字符代码
Chr(charcode)        返回 string，其中包含有与指定的字符代码相关的字符
D．转换函数
CBool(expression)      转换为Boolean型
CByte(expression)       转换为Byte型
CCur(expression)       转换为Currency型
CDate(expression)       转换为Date型
CDbl(expression)       转换为Double型
CDec(expression)       转换为Decemal型
CInt(expression)       转换为Integer型
CLng(expression)       转换为Long型
CSng(expression)       转换为Single型
CStr(expression)       转换为String型
CVar(expression)       转换为Variant型
Val(string)         转换为数据型
Str(number)        转换为String
E．时间函数
Now     返回一个 Variant (Date)，根据计算机系统设置的日期和时间来指定日期和时间。
Date     返回包含系统日期的 Variant (Date)。
Time   返回一个指明当前系统时间的 Variant (Date)。
Timer     返回一个 Single，代表从午夜开始到现在经过的秒数。
TimeSerial(hour, minute, second) 返回一个 Variant (Date)，包含具有具体时、分、秒的时间。
DateDiff(interval, date1, date2[, firstdayofweek[, firstweekofyear]])
返回 Variant (Long) 的值，表示两个指定日期间的时间间隔数目
Second(time) 返回一个 Variant (Integer)，其值为 0 到 59 之间的整数，表示一分钟之中的某个秒
Minute(time) 返回一个 Variant (Integer)，其值为 0 到 59 之间的整数，表示一小时中的某分钟
Hour(time)   返回一个 Variant (Integer)，其值为 0 到 23 之间的整数，表示一天之中的某一钟点
Day(date)   返回一个 Variant (Integer)，其值为 1 到 31 之间的整数，表示一个月中的某一日
Month(date)   返回一个 Variant (Integer)，其值为 1 到 12 之间的整数，表示一年中的某月
Year(date)   返回 Variant (Integer)，包含表示年份的整数。
Weekday(date, [firstdayofweek]) 返回一个 Variant (Integer)，包含一个整数，代表某个日期是星期几   13, 文件操作 1）文件 Dir[(pathname[, attributes])] ；pathname 可选参数，用来指定文件名的字符串表达式，可能包含目录或文件夹、以及驱动器。如果没有找到 pathname，则会返回零长度字符串 (&ldquo;&rdquo;); attributes 可选参数。常数或数值表达式，其总和用来指定文件属性。如果省略，则会返回匹配 pathname 但不包含属性的文件。 2）删除 Kill pathname 从磁盘中删除文件, pathname 参数是用来指定一个文件名 RmDir pathname 从磁盘中删除删除目录，pathname 参数是用来指定一个文件夹 3）打开 Open pathname For mode [Access access] [lock] As [#]filenumber [Len=reclength] 能够对文件输入/输出 (I/O)。 pathname 必要。字符串表达式，指定文件名，该文件名可能还包括目录、文件夹及驱动器。 mode 必要。关键字，指定文件方式，有 Append、Binary、Input、Output、或 Random 方式。如果未指定方式，则以 Random 访问方式打开文件。 access 可选。关键字，说明打开的文件可以进行的操作，有 Read、Write、或 Read Write 操作。 lock 可选。关键字，说明限定于其它进程打开的文件的操作，有 Shared、Lock Read、Lock Write、和 Lock Read Write 操作。 filenumber 必要。一个有效的文件号，范围在 1 到 511 之间。使用 FreeFile 函数可得到下一个可用的文件号。 reclength 可选。小于或等于 32，767（字节）的一个数。对于用随机访问方式打开的文件，该值就是记录长度。对于顺序文件，该值就是缓冲字符数。说明 对文件做任何 I/O 操作之前都必须先打开文件。Open 语句分配一个缓冲区供文件进行 I/O 之用，并决定缓冲区所使用的访问方式。如果 pathname 指定的文件不存在，那么，在用 Append、Binary、Output、或 Random 方式打开文件时，可以建立这一文件。如果文件已由其它进程打开，而且不允许指定的访问类型，则 Open 操作失败，而且会有错误发生。如果 mode 是 Binary 方式，则 Len 子句会被忽略掉。 重要 在 Binary、Input 和 Random 方式下可以用不同的文件号打开同一文件，而不必先将该文件关闭。在 Append 和 Output 方式下，如果要用不同的文件号打开同一文件，则必须在打开文件之前先关闭该文件。 4）读入 Input #filenumber, varlist 从已打开的顺序文件中读出数据并将数据指定给变量 Get [#]filenumber, [recnumber], varname将一个已打开的磁盘文件读入一个变量之中。 5）写入 Write #filenumber, [outputlist] 将数据写入顺序文件 Print #filenumber, [outputlist] 将格式化显示的数据写入顺序文件中 Put [#]filenumber, [recnumber], varname 将一个变量的数据写入磁盘文件中。 6）关闭 Close [filenumberlist] 关闭 Open 语句所打开的输入/输出 (I/O) 文件 注意 如果今后想用 Input # 语句读出文件的数据，就要用 Write # 语句而不用 Print # 语句将数据写入文件。因为在使用 Write # 时，将数据域分界就可确保每个数据域的完整性，因此可用 Input # 再将数据读出来。使用 Write # 还能确保任何地区的数据都被正确读出。Write 与 Print # 语句不同，当要将数据写入文件时，Write # 语句会在项目和用来标记字符串的引号之间插入逗号。Write # 语句在将 outputlist 中的最后一个字符写入文件后会插入一个新行字符，即回车换行符，(Chr(13) + Chr(10))。 7）其他文件函数 LOF(filenumber) 返回一个 Long，表示用 Open 语句打开的文件的大小，该大小以字节为单位。 EOF(filenumber) 返回一个 Integer，它包含 Boolean 值 True，表明已经到达为 Random 或顺序 Input 打开的文件的结尾。 Loc(filenumber) 返回一个 Long，在已打开的文件中指定当前读/写位置 Seek(filenumber) 返回一个 Long，在 Open 语句打开的文件中指定当前的读/写位置</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/08/30/160444/">解析java源文件</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2010-08-30T16:04:44+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2010</span></span> <span class='time'>4:04 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>尝试从java源文件中解析出类、方法、属性等信息，但下面的代码没有完全实现。</p>

<p>Sub parseJava()
  Dim package_name as String
  &lsquo;read a file
  Documents.Open FileName:=&ldquo;f:\CommandCm.java&rdquo;, ConfirmConversions:=False, ReadOnly:=True
  paraNo = ActiveDocument.Paragraphs.Count
  For lineNo = 1 To paraNo
   Set curParaWords = ActiveDocument.Paragraphs(lineNo).Range.Words
   Dim strCurPara as String
   strCurPara = ActiveDocument.Paragraphs(lineNo).Range.Text
   If InStr(strCurPara, &ldquo;package&rdquo;)=1 Then
    &#8216;包名是package后、分号前的部分
    tmpStr = Right(strCurPara,Len(strCurPara)-Len(&ldquo;package&rdquo;)-1)
    package_name = Left(tmpStr, Len(tmpStr)-2)
   End If
   If InStr(strCurPara, &ldquo;public class&rdquo;)=1 Then
    &#8216;类名是这一行的第三个单词，且不含末尾空格
    class_name = RTrim(curParaWords(3).Text)
   End If
   If InStr(strCurPara, &ldquo;public interface&rdquo;)=1 Then
    &#8216;接口名是这一行的第三个单词，且不含末尾空格
    class_name = RTrim(curParaWords(3).Text)
   End If
   Select Case curParaWords(2).Text
   Case &ldquo;public&rdquo;</p>

<p>   Case &ldquo;private&rdquo;
   Case &ldquo;protected&rdquo;
   Case Else
   End Case
   If curParaWords(2)=&ldquo;public&rdquo; Then
    &lsquo;接口名是这一行的第三个单词，且不含末尾空格
    class_name = RTrim(ActiveDocument.Paragraphs(lineNo).Range.Words(3).Text)
   End If
  Next lineNo
  ActiveDocument.Close
End Sub</p>

<p> 下面是业务逻辑：</p>

<p>数据结构：</p>

<p> 类相关数据表ClassInfo（Map）</p>

<p> key: name, description, class_name, package, extends, interface;</p>

<p>属性数据表PropInfo（List<Map>）</p>

<p>方法数据表MethodInfo（List<Map>）</p>

<p>文本格式约定：</p>

<p>顶格、package起首代码行为package声明行；</p>

<p>顶格、public class起首的代码行是类声明行；</p>

<p> 顶格、 public  interface起首的代码行是接口声明行；</p>

<p> 一个tab后跟public、private、protected是方法或者属性</p>

<p> 有左括号的是方法， 左括号前单词是方法名，方法名前是返回值的数据类型；</p>

<p> 无左括号 的是 属性，等号左边单词是属性名，若无等号分号前单词是属性名，若都没有输出一条 “文件名：行号：异常属性/方法，手工提取” 提示；</p>

<p> 一个tab后跟其他字母 输出一条“文件名：行号：异常属性/方法，手工提取”提示；</p>

<p> 一个tab后跟非字母符号（如/*是注释，@是编译标志）略过；</p>

<p>流程：</p>

<p> 用户输入目标目录</p>

<p> 将文件名保存在ClassInfo.name和class_name中；</p>

<p> 加载该目录下所有java文件， 对于一个java文件：</p>

<p>第一次文本逐行读取：提取除方法/属性说明外所有信息；</p>

<p>第二次文本逐行读取：寻找以“* 方法名”开始的行，作为方法说明，放入对应的方法Map中；</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/102">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/100">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/04/18/140631/">4月17日讲座文字稿</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/17/151844/">Linux Mint System Backup and Restore</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/16/172913/">Fzf让命令行更方便</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/15/105035/">How to Sync a Fork on Github</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/04/08/161006/">Python的Generator和yield</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
