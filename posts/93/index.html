
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Dark Matter in Cyberspace</title>
  <meta name="author" content="Li Chao">

  
  <meta name="description" content="Groovy的单元测试可以通过两种方法进行，一是用JUnit框架，二是用Groovy自己的TestSuite测试。JUnit测试代码是Java代码，GroovyTestSuite的测试代码是groovy代码，且只能一次运行测试类中所有的TestCase，灵活性较JUnit方法稍差。下面是一个实例 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://leetschau.github.io/posts/93/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Dark Matter in Cyberspace" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Dark Matter in Cyberspace</a></h1>
  
    <h2>A notes repository for Meteor.js, data mining, Linux, etc.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="leetschau.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/31/172555/">如何进行Groovy的单元测试</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-31T17:25:55+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>31</span><span class='date-suffix'>st</span>, <span class='date-year'>2011</span></span> <span class='time'>5:25 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Groovy的单元测试可以通过两种方法进行，一是用JUnit框架，二是用Groovy自己的TestSuite测试。JUnit测试代码是Java代码，GroovyTestSuite的测试代码是groovy代码，且只能一次运行测试类中所有的TestCase，灵活性较JUnit方法稍差。下面是一个实例：</p>

<p>被测试类（Song.groovy文件内容）：
 package  org.leechau.ut;</p>

<p> class  Song {
    def  name
    def  artist
    def  genre
  String toString(){
     &ldquo;${ name }, ${  artist }, ${ genre  }&rdquo;
  }
    def  getGenre(){
     genre ?. toUpperCase ()
  }
 }</p>

<p> class  Song2 {
    def  name2
    def  ex(){
     println  name2
  }</p>

<h2> } </h2>

<p> JUnit测试文件（SongTest.java）：
  package  org.leechau.ut;</p>

<p> import  org.junit.Assert;
 import  org.junit.Test;</p>

<p> public  class  SongTest {</p>

<p>   @Test
    public  void  testToString() {
    Song sng =  new  Song();
    sng.setArtist(  &ldquo;Lee&rdquo; );
    Assert. assertEquals ( &ldquo;Lee&rdquo; , sng.getArtist());
  }
 }</p>

<hr />

<p> Groovy测试文件（TestSong2.groovy）：
  package  org.leechau.ut2;</p>

<p> import  groovy.util.GroovyTestCase</p>

<p> import  org.leechau.ut.Song
 import  org.leechau.ut.Song2</p>

<p> class  SongTest2  extends  GroovyTestCase{</p>

<pre><code>void  testGetGenre() { 
 def  sng =  new  Song() 
sng.setGenre  "Pop" 
 assertEquals (sng.getGenre(),  "POP" ) 
</code></pre>

<p>  }</p>

<pre><code>void  testSong2(){ 
 def  sng2 =  new  Song2() 
sng2.setName2  "Song2" 
 assertEquals (sng2.getName2(),  "Song2" ) 
</code></pre>

<p>  }
 }</p>

<hr />

<p> 且需要进行运行设置：
 1. 在Java Application中新建一个run configuration；</p>

<ol>
<li><p>Main标签下的Main Class写：groovy.util.GroovyTestSuite，且勾选“Include System Libraries when searching for a main class”；</p></li>
<li><p>Arguments标签下program arguments下写上测试脚本的相对路径，如：src\org\leechau\ut2\SongTest2.groovy；</p></li>
<li><p>运行该配置；</p></li>
</ol>


<p> 结果如下：</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/26/092619/">在48服务器上安装并使用PyScripter编辑的方法</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-26T09:26:19+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>9:26 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>类似于BVT这样的脚本一般都运行在服务器上，在本机调试好再移动到服务器上比较麻烦，理想方法是在服务器上直接调试python源代码，这就需要有IDE支持，下面说明了在48服务器上使用绿色版PyScripter的完整过程。</p>

<ol>
<li><p>以用户名 ser2 登录48服务器（地址：10.0.2.48）；</p></li>
<li><p>将PyScripter_confs_on48.zip解压到C:\Documents and Settings\ serv2 \Application Data下，即PyScripter.ini的绝对路径为：</p></li>
</ol>


<p> C:\Documents and Settings\serv2\Application Data\PyScripter\PyScripter.ini</p>

<ol>
<li><p>解压PyScripter-v2.4.1.zip到任意位置，运行其中的PyScripter.exe启动PyScripter；</p></li>
<li><p>从SVN上下载源代码；</p></li>
</ol>


<hr />

<p>注1：第2步的目的是将PyScripter常用的设置（如字号大小，背景颜色，快捷键等）一次性设置好，这些设置都保存在前述的</p>

<p>&ldquo; C:\Documents and Settings\serv2\Application Data\PyScripter\PyScripter.ini "文件中。</p>

<p>注2：第1步中的登录用户名要与第2步中的路径名一致（这里都是serv2），否则当前用户没有其他用户目录的写权限，不可能解压文件；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/25/123121/">Ivy可以在ant中直接使用的变量</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-25T12:31:21+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>12:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在 ant 文件中使用&lt;ivy:resolve/>进行解析后，可以使用如下变量：</p>

<p>ivy.organisation</p>

<p>ivy.module</p>

<p>ivy.revision</p>

<p>ivy.resolved.configurations</p>

<p>例如如下代码：
   <target  name= "UT_junit"  depends=  "cleanForZip" >
   <mkdir dir="${junit.test.result}"/>
     <javac  srcdir= "${test.src.dir}"  destdir= "${test.class.dir}"  encoding= "GBK" >
      <classpath>
       <pathelement  location= "${build.dist.dir}/${ ivy.module }-${ ivy.revision }.jar" />
       <path  refid= "lib.path" />
       <path  refid= "test.lib.path" />
      </classpath>
     </javac>
 需要注意的是由于这些变量仅在 &lt;ivy:resolve/>后才生成，因此不要用<property name="..." value="${ivy.module}" />将它们的赋给一个变量，因为所有的变量赋值都是在任务（target）之前进行的（不论赋值的位置是否在包含&lt;ivy:resolve/>的target之后），因此变量肯定是得不到上述变量的值的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/19/094133/">射手网字幕编码修改笔记</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-19T09:41:33+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>9:41 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>用射手播放器自动下载的视频用文本编辑器打开后经常是乱码，实验后发现主要是由于这些文件使用Big5编码格式，用Notepad2就可以进行编码转换，但Notepad2没有中文繁简体转换的功能，用Word进行转换是一种比较完整的解决方案，下面是详细操作过程：</p>

<p>用Word打开这个srt文件，Word会自动侦测其编码格式；</p>

<p>打开文件后，选中所有文本后用【审阅->繁转简】转为简体并保存：在【是否保存为这种格式】对话框里选“否”，然后在保存对话框中将【保存类型】选为【纯文本(*.txt)】，文件名框中将扩展名改为srt，在随后出现的编码对话框里【文本编码】选【其他编码】，在编码列表里选【Unicode (UTF-8)】，确定即可。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/16/162950/">CD管理和检索软件比较</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-16T16:29:50+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>16</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>4:29 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>之前一直用EverCD+，考虑到鸡蛋不能放在一个篮子里，又找了几款功能类似的进行了比较，主要考察一下几个功能：</p>

<p> 多个镜像：一个数据文件可以包含多个目录的镜像，便于数据管理和搜索； 目录更新：目录内容发生变化后，更新其在管理软件中的镜像（对于一次性写光盘不存在更新问题）； 多种搜索类型：除了按名称搜索，还能按大小、日期等搜索； 导出、导入为通用数据文件：如csv、xml文件等；</p>

<p> 备选软件
 WhereIsIt：商业软件，暂未找到破解版； VVV (Virtual Volumes View)：开源软件（C++写成），无需安装，支持多个镜像，支持更新和搜索，不能导入，能够导出为CSV文件；有源代码下载，体积小巧（Windows压缩包4MB，源代码2MB）； Visual CD：免费软件，需安装， 间接支持多个镜像（ 一个vcc文件只能对应一个目录镜像，但可以在多个vcc文件内搜索 ）， 支持更新和搜索，不能导入csv和xml，导出功能强（能够导出为html、txt、rtf和txt格式）； Offline CD Browser：免费软件，数据文件放在了默认的安装文件内，安全性差，界面老土，支持更新和搜索，多种搜索类型，无导入和导出功能； Blue Mirror DVD/CD Indexer：安装过程需要联网，间接支持多个镜像（一个数据文件只包含一个镜像，但可以用“Merge with File”合并多个数据文件），似乎没有更新功能和搜索功能，可以导出为CSV文件； EverCD+：支持导出为xml文件； GCstar：安装文件很大，似乎是一个个人文档管理软件，严格来说不属于光盘管理软件； 总结</p>

<p>VVV无需安装，体积小，功能完善，开源，是EverCD+比较好的替代品；</p>

<p>这类软件都没有从csv、xml文件导入的功能，所以目前的EverCD+数据文件可能无法导入到其他软件中。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/13/163122/">Haskell Notes</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-13T16:31:22+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>13</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>4:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Installation</h1>

<pre><code>sudo apt-get install aptitude
sudo aptitude install haskell-platform
</code></pre>

<p>verified on Linux Mint 14 Xfce.</p>

<p>Install hoogle (offline documentation of Haskell):</p>

<pre><code>cabal update
cabal install alex happy &amp;&amp; cabal install hoogle
</code></pre>

<p>Ref: <a href="http://stackoverflow.com/questions/11753979/cabal-install-hoogle-error">http://stackoverflow.com/questions/11753979/cabal-install-hoogle-error</a></p>

<p>Very slow, you can use <a href="http://www.haskell.org/hoogle/">the online version</a>;</p>

<p>modify ~/.cabal/conifg:</p>

<pre><code>remote-repo: old.hackage.haskell.org:http://old.hackage.haskell.org
</code></pre>

<p>Ref:</p>

<p><a href="http://hackage.haskell.org/">http://hackage.haskell.org/</a></p>

<p><a href="http://www.haskell.org/haskellwiki/Hoogle">http://www.haskell.org/haskellwiki/Hoogle</a></p>

<pre><code>$ cabal update
$ cabal install hoogle
$ ~/.cabal/bin/hoogle data # create database
$ ~/.cabal/bin/hoogle map # search "map"
</code></pre>

<p>Save the following lines to ~/.ghci to enable you use &ldquo;:hoogle&rdquo; or &ldquo;:doc&rdquo; to get doc info in ghci:</p>

<pre><code>:def hoogle \x -&gt; return $ ":!hoogle \"" ++ x ++ "\""       
:def doc \x -&gt; return $ ":!hoogle --info \"" ++ x ++ "\""
</code></pre>

<h1>Sample Project</h1>

<p>Based on <a href="http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program;">http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program;</a></p>

<ol>
<li><p>create home folder: <code>take haq</code>;</p></li>
<li><p>create source file &ldquo;Haq.hs&rdquo;;</p></li>
<li><p>stick it in version control:</p>

<pre><code> git init
 git add Haq.hs
 git commit -m "add first source"
</code></pre></li>
<li><p>add a build system: <code>cabal init</code>;</p></li>
<li><p>modify .cabal file: add &ldquo;Haq.hs&rdquo; after &ldquo;&ndash; main-is:&rdquo; and uncomment this line(delete &ldquo;&ndash;&rdquo;); If you donot specify the license type, comment out the line &ldquo;license-file&rdquo;;</p></li>
<li><p>cabal update</p></li>
<li><p>cabal install &ndash;prefix=<dst_folder> &ndash;user</p></li>
<li><p>run app: <code>bin/haq me</code> under <dst_folder>, or run app in-place (under current directory): dist/build/haq/haq me</p></li>
</ol>


<p>verified on Haskell Platform 7.4.2, Linux Mint 14:</p>

<p>$ ghc &ndash;version</p>

<p>The Glorious Glasgow Haskell Compilation System, version 7.4.2</p>

<h1>Miscellaneous</h1>

<ul>
<li><p>ghc: compiler</p></li>
<li><p>ghci: interactive shell;</p></li>
<li><p>runghc: run haskell script without compile</p></li>
<li><p>Compile haskell source file to executable:</p>

<pre><code>  $ ghc --make &lt;FileName&gt;.hs -o &lt;ExeFileName&gt;
</code></pre></li>
</ul>


<p>for example:</p>

<pre><code>$ ghc --make Test.hs -o test
</code></pre>

<h1>GHCi usage</h1>

<ul>
<li><p>get current working directory: :!pwd (you can use :!<shell_cmd> to run any shell command);</p></li>
<li><p>turn on/off type declaration: :set +t, :unset +t</p></li>
<li><p>get type information of a object: :t</p></li>
<li><p>define local variable and show bindings:</p>

<pre><code>  let x = 3, 
  :show bindings
</code></pre></li>
<li><p>load module: :m +Data.Ratio</p></li>
<li><p>change cwd: :cd <path_name></p></li>
<li><p>load file: :l <file_name></p></li>
<li><p>quit ghci shell: :q</p></li>
<li><p>get function doc: :i <func_name></p></li>
</ul>


<h1>Syntax</h1>

<ul>
<li><p>comments: &ndash;</p></li>
<li><p>comparison: /=, >, &lt;</p></li>
<li><p>boolean operation: not, || , &amp;&amp;</p></li>
<li><p>Haskell requires type names to start with an uppercase letter, and variable names must start with a lowercase letter.</p></li>
<li><p>To construct a rational number: 11 % 29 (after &ldquo;:m +Data.Ratio&rdquo;)</p></li>
<li><p>values in &ldquo;where&rdquo;, &ldquo;case&rdquo; and &ldquo;let&rdquo; clause must keep the SAME indentions;</p></li>
</ul>


<h1>Shell Interaction Library</h1>

<p>shqq, shelly</p>

<p>Ref: <a href="http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts">Shelly: Write your shell scripts in Haskell</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/12/200007/">视频分割、合并软件比较</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-12T20:00:07+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>8:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>特点</p>

<p>支持格式：是否同时支持AVI、MPG、RM、RMVB、WMV等视频格式的分割；</p>

<p>输入时间：直接输入时间，而不是用游标拖动；</p>

<p>多段剪辑：是否支持从一个文件中设置多个片段，一次性剪辑出来；</p>

<p>快速分割：是否能够在不重新编码的情况下分割视频；</p>

<p>Boilsoft Video Cutter</p>

<p>不能分割rmvb，有时会出现不能预览视频的情况，支持输入时间（操作比较麻烦），支持多段剪辑，支持快速分割；</p>

<p>Boilsoft.Video.Splitter</p>

<p>所有分割均失败；</p>

<p>Ultra Video Splitter</p>

<p>支持所有格式，支持输入时间，不支持多段剪辑，支持快速分割；</p>

<p>SolveigMM Video Splitter</p>

<p>支持AVI和WMV以及多种音频格式，支持输入时间，多段剪辑，快速分割，支持批处理操作，能够对进度条进行缩放，有视频（仅AVI、WMV、ASF）和音频合并功能，分割质量好，快捷键支持好；</p>

<p> 结论：当分割AVI、WMV、ASF格式文件时用SolveigMM Video Splitter，分割RM格式文件时用Ultra Video Splitter。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/11/150130/">删除过期的文件夹</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-11T15:01:30+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>3:01 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>BVT将每天检出并运行单元测试的源代码放入一个以日期命名的文件夹中，每个文件夹都很大，因此需要及时清除比较老的文件夹以节约磁盘空间，例如今天是5月11日，bvt运行目录e:\bvt_build下有如下文件夹和文件：</p>

<p> 2011-04-18\</p>

<p> 2011-04-19\</p>

<p> 2011-04-22\</p>

<p> 2011-04-25\</p>

<p> 2011-04-27\</p>

<p> 2011-05-10\</p>

<p> 2011-05-09\</p>

<p>  2011-05-08\</p>

<p> backup\</p>

<p> note.txt</p>

<p>现在的要求是仅保留今天、昨天和前天共3天的文件夹，其余文件夹删除（文件都保留），技术关键有两点：一是怎样将字符串形式的日期转换为可以用来做减法的date对象，以便判断与今天的间隔，这里采用的方法是：先将字符串转换为一个datetime对象，然后转换为一个timestamp（实数），再将timestamp转换为date对象；二是怎样将时间间隔（timedelta）对象转换为整型数以便进行比较，这里用的方法是得到timedelta对象后取其days属性。代码如下：</p>

<p> import os,shutil,time</p>

<p> from datetime import datetime, timedelta, date</p>

<p> today = date.today()</p>

<p> sub_items = os.listdir(&lsquo;e:/bvt_build&rsquo;)</p>

<p> for item in sub_items:</p>

<p>  try:</p>

<p>   timeFloat = time.mktime(time.strptime(item, &ldquo;%Y-%m-%d&rdquo;))</p>

<p>   the_day = date.fromtimestamp(timeFloat)</p>

<p>   time_span = (today - the_day).days</p>

<p>   if time_span > 2:</p>

<pre><code>shutil.rmtree(os.path.join('e:/bvt_build',item)) 
</code></pre>

<p>  except:</p>

<p>   continue</p>

<p>运行后的结果如下：</p>

<p> 2011-05-09\</p>

<p> 2011-05-10\</p>

<p> backup\</p>

<p> note.txt</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/10/175806/">Bvt脚本运行环境设置</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-10T17:58:06+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>5:58 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>tools目录：来自svn；</p>

<p>log目录以及下面的bvt.log文件：自动生成；</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/10/135056/">Python的目录文件拷贝</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2011-05-10T13:50:56+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2011</span></span> <span class='time'>1:50 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Python中进行目录（包括其中所有的文件和子目录）的拷贝时，如果使用shutil 模块，有两个方法，分别是copy()和copytree()方法，copy只能拷贝单个文件，copytree虽然可以拷贝整个目录，但要求目标目录必须不存在。当需要把多个源目录中的文件、子目录拷贝到一个目标目录下时，不能用这个方法，解决的方法是使用distutils.dir_util 模块的copy_tree方法。示例代码如下：</p>

<p> from distutils.dir_util import copy_tree</p>

<p> copy_tree(&lsquo;e:\GODU_SERVER_2.2\bin&rsquo;, &lsquo;e:\bvt_build\2011-05-10\GODU_SERVER_2.2\bin&rsquo;)</p>

<p> copy_tree(&lsquo;e:\GODU_SERVER_2.2\conf&rsquo;, &lsquo;e:\bvt_build\2011-05-10\GODU_SERVER_2.2\conf&rsquo;)</p>

<p>详见用户手册。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/94">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/92">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/07/31/160627/">Chinese Characters Can't Be Displayed Correctly in Git Log</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/23/121622/">Development Collaboration With Pull Request</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/22/082040/">Running Meteor and Node App on Ubuntu 14.04 VPS</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/18/005622/">基于ionic的移动网页开发</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/10/065540/">Manage Nodejs App With Forever</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/leetschau">@leetschau</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'leetschau',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Li Chao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
