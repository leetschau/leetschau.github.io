<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 并发 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/bing-fa/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-04-15T10:58:04+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用Autohotkey模拟两台客户机的并发访问事件]]></title>
    <link href="http://leetschau.github.io/blog/2013/03/02/105214/"/>
    <updated>2013-03-02T10:52:14+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/03/02/105214</id>
    <content type="html"><![CDATA[<p>现在需要从主机113和747上同时向服务器47发送指令"cat bigMsg"，以观察47对并发请求的处理能力以及网络传输带宽，可以在pc上分别登录到113和747上，然后分别输入该指令，但手工顺序输入毕竟时间间隔比较大，如果bigMsg不够大，手工操作在47上就变成顺序执行了，如果对开始时间点的要求不那么严格，可以用Autohotkey脚本实现模拟的并发访问，下面演示了用ahk脚本实现的在两台主机上同时运行top指令，8秒后分别发送q退出top界面，以证明ahk脚本确实能够起到“非阻塞发送两条指令”的效果。</p>

<ol>
<li><p>类似于手工操作，用Kitty登录113和747，假设两个窗口的标题分别为"lichao@pwm"和"godu@goduserver"；</p></li>
<li><p>建立ahk脚本（分别在两个主机上运行）：</p></li>
</ol>


<p> SetTitleMatchMode, 2
 WinActivate, godu
 SendInput, top{enter}
 WinActivate, lichao
 SendInput, top{enter}
 Sleep, 8000
 WinActivate, godu
 SendInput, q
 WinActivate, lichao
 SendInput, q
1. 在vim窗口里运行":silent !%&ldquo;执行这个脚本，与直接运行&rdquo;!%&ldquo;相比，silent指令不会出现一个dos窗口，然后要求用户看回车返回vim窗口（参考<a href="http://vim.wikia.com/wiki/Avoiding_the_%22Hit_ENTER_to_continue%22_prompts%EF%BC%89%E3%80%82">http://vim.wikia.com/wiki/Avoiding_the_%22Hit_ENTER_to_continue%22_prompts%EF%BC%89%E3%80%82</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ConcurrentLinkedQueue vs LinkedBlockingQueue]]></title>
    <link href="http://leetschau.github.io/blog/2013/02/04/151243/"/>
    <updated>2013-02-04T15:12:43+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/02/04/151243</id>
    <content type="html"><![CDATA[<p>根据LinkedBlockingQueue实现的接口BlockingQueue的文档，BlockingQueue及其所有实现类都是线程安全的，且可用于多个Producer/Consumer的场景，它的主要用途是Producer-Consumer模型，它提供了4种出/入队列的方法，分别是抛异常、特殊值、阻塞和超时。</p>

<p>LinkedBlockingQueue初始化时可以设置容量，所以BlockingQueue具备一种“流量平衡”能力，即当消费过快以至于队列空时，出队列（消费）操作将阻塞；生产过快以至于队列满时，入队列（生产）操作将阻塞。</p>

<p>BlockingQueue的take()方法在阻塞状态下是不消耗CPU的。</p>

<p>ConcurrentLinkedQueue是一个"wait-free" algorithm（见文档），它的使用场景目前还不清楚。</p>

<p>参考：</p>

<p> <a href="http://stackoverflow.com/questions/1426754/linkedblockingqueue-vs-concurrentlinkedqueue">http://stackoverflow.com/questions/1426754/linkedblockingqueue-vs-concurrentlinkedqueue</a></p>

<p> <a href="http://stackoverflow.com/questions/1426342/need-a-queue-that-can-support-multiple-readers/1426375#1426375">http://stackoverflow.com/questions/1426342/need-a-queue-that-can-support-multiple-readers/1426375#1426375</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用TestNG进行并发测试]]></title>
    <link href="http://leetschau.github.io/blog/2010/09/17/173257/"/>
    <updated>2010-09-17T17:32:57+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/09/17/173257</id>
    <content type="html"><![CDATA[<p>写并发测试用例的时候不要用JUnit，它不支持并发，将测试函数写在public static void main(String[] args)中。但如果一个测试类里有多个并发测试case的时候这招就不灵了，需要用testng解决这个问题。在Eclipse中使用TestNG需要首先安装testng for eclispe的plugin（见[1]），然后引用testng的jar包。然后就可以写测试用例了。</p>

<p>testng声明并发测试很简单，示例如下（改自[3]）：</p>

<p> import org.testng.annotations.Test; @Test(invocationCount = 5, threadPoolSize = 3)
public void testThreadPool() {
 System.out.println(&ldquo;Thread: &rdquo; + Thread.currentThread().getId());
}
参数含义：（引自[2]）</p>

<p>invocationCount: The number of times this method should be invoked.（线程体总共被执行多少次）；
threadPoolSize: The size of the thread pool for this method. The method will be invoked from multiple threads as specified by invocationCount.（线程池的大小，也就是并发的线程数目是多少）
Note: this attribute is ignored if invocationCount is not specified
上面这个例子输出可能如下： Thread: 14
Thread: 13
Thread: 15
Thread: 14
Thread: 13
即程序共运行5次，共有3个线程。</p>

<p>[1] <a href="http://testng.org/doc/download.html">http://testng.org/doc/download.html</a></p>

<p>[2] <a href="http://testng.org/doc/documentation-main.html">http://testng.org/doc/documentation-main.html</a></p>

<p>[3] <a href="http://hi.baidu.com/sunshine/blog/item/9d355982cb1200a40cf4d2c9.html">http://hi.baidu.com/sunshine/blog/item/9d355982cb1200a40cf4d2c9.html</a></p>

<p> <a href="http://www.raptorconsultants.com/uncategorized/testng-junit/">http://www.raptorconsultants.com/uncategorized/testng-junit/</a></p>
]]></content>
  </entry>
  
</feed>
