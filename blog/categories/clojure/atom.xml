<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-08-27T13:25:34+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Run Clojure Script With External Dependencies Without Leiningen]]></title>
    <link href="http://leetschau.github.io/blog/2013/12/04/163536/"/>
    <updated>2013-12-04T16:35:36+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/12/04/163536</id>
    <content type="html"><![CDATA[<p>The normal way of deploy clojure files is using leiningen. But if we have no leiningen, or the script is small and unnecessary to pack as a leiningen project, we can build a &ldquo;bare&rdquo; clojure script in the following way.</p>

<ol>
<li><p>Get the dependency jar files, 2 options:</p>

<ol type="a">
<li><p>download the jar file directly;</p></li>
<li><p>if the dependency project provide the dependency as leiningen dependency items in porject.clj (for example, &ldquo;[org.clojure/data.json &#8220;0.2.3&rdquo;]&ldquo; in <a href="https://github.com/clojure/data.json">data.json</a>), you can build the leiningen project following Parse Sonarqube Data via Web API in Clojure , then copy the denpendency jar files from the ~/.m2/repository folder;</p></li>
</ol>
</li>
<li><p>Build srcipt: get-sonar-data.clj</p>

<p> (require &lsquo;[clojure.data.json :as json])
 (def url &ldquo;<a href="http://10.0.2.74:9000/api/resources?resource=ESB:com.boco.esb.analysismgr.service.impl&amp;metrics=classes">http://10.0.2.74:9000/api/resources?resource=ESB:com.boco.esb.analysismgr.service.impl&amp;metrics=classes</a>&rdquo;)
 (def data (json/read-str (slurp url)))
 (println ((first data) &ldquo;name&rdquo;))
 (println ((first ((first data) &ldquo;msr&rdquo;)) &ldquo;val&rdquo;))</p></li>
<li><p>Run script: java -cp &lsquo;./*:.&rsquo; clojure.main get-sonar-data.clj</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Parse Sonarqube Data via Web API in Clojure]]></title>
    <link href="http://leetschau.github.io/blog/2013/12/04/114616/"/>
    <updated>2013-12-04T11:46:16+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/12/04/114616</id>
    <content type="html"><![CDATA[<ol>
<li><p>build project: lein new sonar-parser</p></li>
<li><p>add dependencies: add &ldquo;[org.clojure/data.json &#8220;0.2.3&rdquo;]&ldquo; in :dependencies in project.clj;</p></li>
<li><p>update (download) dependency jars (into ~/.m2/repository folder): lein deps</p></li>
<li><p>start repl: lein repl</p></li>
<li><p>test in repl:</p></li>
</ol>


<p> (require &lsquo;[clojure.data.json :as json])</p>

<p> (def data (json/read-str (slurp &ldquo;<a href="http://...">http://&#8230;</a>&rdquo;)))</p>

<p> ((first ((first data) &ldquo;msr&rdquo;)) &ldquo;val&rdquo;) ; => 5.0</p>

<ol>
<li><p>add script into src/sonar-parser/core.clj;</p></li>
<li><p>pack project: lein uberjar</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Run Clojure Script Portable]]></title>
    <link href="http://leetschau.github.io/blog/2013/11/22/172634/"/>
    <updated>2013-11-22T17:26:34+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/11/22/172634</id>
    <content type="html"><![CDATA[<p>leiningen is great, but it&rsquo;s for project-level application. How to run clojure script on a bare host, like python script?</p>

<p>Yes, python is build-in for almost all Linux host. But you can build your clojure environment on a host only depends JVM:</p>

<ol>
<li><p>Download clojure distribution from <a href="http://clojure.org/">clojure official website</a>, and extract it somewhere, say, ~/apps/clojure-1.5.1;</p></li>
<li><p>Add a alias in your ~/.bashrc:</p></li>
</ol>


<p> alias clj=&lsquo;java -cp ~/apps/clojure-1.5.1/clojure-1.5.1.jar clojure.main&rsquo;</p>

<ol>
<li>Validate your .bashrc: &ldquo;. ~/.bashrc&rdquo;;</li>
</ol>


<p>That&rsquo;s it!</p>

<p>Now run clojure repl with command &ldquo;clj&rdquo;. Then write a clojure hello world file &ldquo;hw.clj&rdquo;: (println &ldquo;hello world&rdquo;), then run &ldquo;clj hw.clj&rdquo;, you can see the output is the same as you run it in clojure repl console.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Calculate PI in 3 Languages Dynamically]]></title>
    <link href="http://leetschau.github.io/blog/2013/10/18/165217/"/>
    <updated>2013-10-18T16:52:17+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/10/18/165217</id>
    <content type="html"><![CDATA[<p>The algorithm to calculate PI is based on &ldquo;<a href="http://stackoverflow.com/questions/12449430/how-did-the-following-piece-of-java-code-calculate-the-digits-of-pi">http://stackoverflow.com/questions/12449430/how-did-the-following-piece-of-java-code-calculate-the-digits-of-pi</a>&rdquo;.</p>

<h1>Source code</h1>

<h2>Java</h2>

<p> import java.math.BigDecimal;
 import java.math.BigInteger;
 public class PiCalculator {
  public static void main(String[] args) {
   int precision = Integer.parseInt(args[0]);
   BigDecimal total = BigDecimal.ZERO;
   for (int i = 0; i &lt; precision; i++) {
    total = total.add(getStep(i, precision));
   }
   System.out.println(&ldquo;Pi = &rdquo; + total);
  }
  public static BigDecimal getStep(int k, int scale) {
   BigInteger base = BigInteger.valueOf(16).pow(k);
   int k1 = 8 * k + 1;
   int k4 = 8 * k + 4;
   int k5 = 8 * k + 5;
   int k6 = 8 * k + 6;
   base = base.multiply(BigInteger.valueOf(k1));
   base = base.multiply(BigInteger.valueOf(k4));
   base = base.multiply(BigInteger.valueOf(k5));
   base = base.multiply(BigInteger.valueOf(k6));
   int numerator = 4 * k4 * k5 * k6 - 2 * k1 * k5 * k6 - k1 * k4 * k6 - k1
    * k4 * k5;
   return BigDecimal.valueOf(numerator).divide(new BigDecimal(base),
     scale - 1, BigDecimal.ROUND_HALF_UP);
  }
 }</p>

<h1>Groovy</h1>

<p> def scale = Integer.parseInt(args[0])
 BigDecimal total = BigDecimal.ZERO
 for (i in 0..scale-1) {
  total = total.add(getStep(i, scale))
 }
 println &ldquo;Pi = &rdquo; + total
 def getStep(int k, int scale) {
  BigInteger base = BigInteger.valueOf(16).pow(k);
  int k1 = 8 * k + 1;
  int k4 = 8 * k + 4;
  int k5 = 8 * k + 5;
  int k6 = 8 * k + 6;
  base = base.multiply(BigInteger.valueOf(k1));
  base = base.multiply(BigInteger.valueOf(k4));
  base = base.multiply(BigInteger.valueOf(k5));
  base = base.multiply(BigInteger.valueOf(k6));
  int numerator = 4 * k4 * k5 * k6 - 2 * k1 * k5 * k6 - k1 * k4 * k6 - k1 * k4 * k5;
  return BigDecimal.valueOf(numerator).divide(new BigDecimal(base),
    scale - 1, BigDecimal.ROUND_HALF_UP);
 }</p>

<h2>Clojure</h2>

<h3>Create Project</h3>

<p>$ lein new calc-pi;cd calc-pi;cat project.clj</p>

<p> &hellip;</p>

<p> :dependencies [[org.clojure/clojure &ldquo;1.5.1&rdquo;]
     [org.clojure/math.numeric-tower &ldquo;0.0.2&rdquo;]])</p>

<h3>core.clj</h3>

<p> (defn calc-pi
  [k]
  (convert-decimal (calc-pi-expt k) k))
 (defn convert-decimal
  &ldquo;Convert a ratio to decimal with precision prec&rdquo;
  [source prec]
  (with-precision prec (/ (bigdec (numerator source)) (denominator source))))
 (defn calc-pi-expt
  [k]
  (reduce + (map step-expt (range k))))
 (require &lsquo;[clojure.math.numeric-tower :as math])
 (defn step-expt [k]
  (/ (- (/ 4 (+ (<em> 8 k) 1)) (/ 2 (+ (</em> 8 k) 4)) (/ 1 (+ (<em> 8 k) 5)) (/ 1 (+ (</em> 8 k) 6))) (math/expt 16 k)))</p>

<h1>Calculate</h1>

<h2>Java</h2>

<p>$ javac PiCalculator.java</p>

<p>$ time java PiCalculator 500</p>

<p>=> 0.25s</p>

<p>This value doesn&rsquo;t include compilation time!</p>

<p>$ /usr/bin/time -p sh -c &lsquo;javac PiCalculator.java;java PiCalculator 500&rsquo;</p>

<p>=> 0.87</p>

<h2>Clojure</h2>

<p>(time (calc-pi 500)) => 0.8s</p>

<h2>Groovy</h2>

<p>$ time groovy calcPi.groovy 500</p>

<p>=> 1.09s</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Namespaces]]></title>
    <link href="http://leetschau.github.io/blog/2013/10/10/114908/"/>
    <updated>2013-10-10T11:49:08+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/10/10/114908</id>
    <content type="html"><![CDATA[<p>Now we have a 2-dimensional vector glider(as follows) in our own namespace. And we want use clojure.pprint/pprint to print it out.</p>

<p>(def glider (vec (repeat 3 (vec (repeat 6 nil)))))</p>

<h1>Declare require as a common function</h1>

<p> (def glider (vec (repeat 3 (vec (repeat 6 nil)))))</p>

<p> (require &lsquo;clojure.pprint)
 (clojure.pprint/pprint glider)</p>

<p> (require &lsquo;[clojure.data.json :as json])</p>

<p> (defn get-data [url] (json/read-str (slurp url)))</p>

<h1>Put require in namespace declaration</h1>

<p> (ns conways-game-of-life.core (:require clojure.pprint))</p>

<p> (def glider (vec (repeat 3 (vec (repeat 6 nil)))))</p>

<p> (clojure.pprint/pprint glider)</p>

<h1>Give required namespace a alias name</h1>

<p> (ns conways-game-of-life.core (:require [clojure.pprint :as ppr]))</p>

<p> (def glider (vec (repeat 3 (vec (repeat 6 nil)))))</p>

<p> (ppr/pprint glider)</p>

<p> (ns sonar-parser.core
  (:require [clojure.data.json :as json]))</p>

<p> (defn get-data [url] (json/read-str (slurp url)))</p>

<p>Ref: <a href="http://blog.8thlight.com/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html">http://blog.8thlight.com/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html</a></p>
]]></content>
  </entry>
  
</feed>
