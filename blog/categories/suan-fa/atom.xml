<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 算法 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/suan-fa/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-10-03T10:36:40+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[加班时间汇总算法]]></title>
    <link href="http://leetschau.github.io/blog/2013/01/07/164935/"/>
    <updated>2013-01-07T16:49:35+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/01/07/164935</id>
    <content type="html"><![CDATA[<p>加班时间原始记录在一个excel文件里，每个月的加班时间在一个sheet里，共12个sheet，第13个sheet里存放12个月加班时间的和，如下图所示：</p>

<p>原始记录页： 汇总页：</p>

<p>这里要处理的情况是：原始记录中有些名字是汇总表里没有的，所以不是所有原始记录都被写到汇总中，另外原始记录中有空行。</p>

<p>汇总的VBA算法首先遍历前12个sheet，将结果放在一个名为total的Set中（类似于Java中的map，key-value组成的集合），如果没有此人名字，则创建，若已有，则累加，然后遍历最后一个sheet，其中的每一个名字从total里找对应的值填在表格里：</p>

<p> Sub OTSum()
  Dim Month
  Month = 12
  Set Total = CreateObject(&ldquo;Scripting.Dictionary&rdquo;)
  For shidx = 1 To Month
   rowcnt = Worksheets(shidx).UsedRange.Rows.Count
   For rowidx = 1 To rowcnt
    empname = Worksheets(shidx).Cells(rowidx, 1).Value
    jbTime = Worksheets(shidx).Cells(rowidx, 2).Value
    If Total.exists(empname) Then
     Total.Item(empname) = Total.Item(empname) + jbTime
    Else: Total.Add empname, jbTime
    End If
   Next
  Next
  rowcnt = Worksheets(Month + 1).UsedRange.Rows.Count
  For rowidx = 1 To rowcnt
   empname = Worksheets(Month + 1).Cells(rowidx, 1).Value
   If Total.exists(empname) Then
    Worksheets(Month + 1).Cells(rowidx, 2) = Total.Item(empname)
   End If
  Next
 End Sub</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代码行汇总算法]]></title>
    <link href="http://leetschau.github.io/blog/2011/01/19/083210/"/>
    <updated>2011-01-19T08:32:10+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/01/19/083210</id>
    <content type="html"><![CDATA[<p>原始数据如下图，现需对每一种语言分类汇总各项指标，例如需计算3个项目中所有java语言增加的总行数（Addition列的52881、4828、14621的和）。每一个项目中语言的种类和数量是不可预知的，但针对一种语言进行的各项统计是确定的（这里共进行8项统计，其中前7项要按语言汇总，即做和，第8项RATE对某种语言是固定值，汇总时不要相加，照写即可）。</p>

<p>算法分为3步：</p>

<p>1、将取得的数据依次放入list中，形成一个一维list；</p>

<p>2、顺序遍历该list，获得语言项的下标位置，每种语言的名字是字典的key，下标列表是对应的value；</p>

<p>3、根据上面生成的字典依次对相同语言的对应条目进行做和，最后一项照写；</p>

<p>下面是代码实现，其中 tested 是原始数据在第一步后形成的一维list， index_dict 是第二步后形成的下标列表字典， summary 是最终的汇总数据列表。</p>

<pre><code>tested = ['java','4','5','0.41','xml','3','7','0.23','java','23','42','0.41','xml','63','82','0.23'] 
index_dict = {} 
for item in tested: 
    if item.isalpha(): 
        if not index_dict.has_key(item): index_dict[item] = [] 
        index_dict[item].append(tested.index(item)) 
        tested[tested.index(item)]='-' 
print(index_dict) 
summary=[] 
for item in index_dict: 
    summary.append(item) 
    index_list = [k+1 for k in index_dict[item]] 
    summary.append(sum(int(tested[k]) for k in index_list)) 
    index_list = [k+2 for k in index_dict[item]] 
    summary.append(sum(int(tested[k]) for k in index_list)) 
    summary.append(tested[index_dict[item][0]+3]) 
print(summary) 
</code></pre>

<p>输出是（python 2.6）：</p>

<pre><code>{'xml': [4, 12], 'java': [0, 8]} 
['xml', 66, 89, '0.23', 'java', 27, 47, '0.41']
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在队列中寻找字符串算法]]></title>
    <link href="http://leetschau.github.io/blog/2010/08/10/203539/"/>
    <updated>2010-08-10T20:35:39+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/08/10/203539</id>
    <content type="html"><![CDATA[<p>在一个队列destQ中，从前向后搜索是否有字符串flag，下面是算法实现以及测试程序。回溯功能暂未实现。</p>

<p> private  int findFlag( final LinkedBlockingQueue<Byte> destQ,</p>

<p> final String flag) {</p>

<p> byte [] flagArr = flag.getBytes();</p>

<p> Byte[] destArr = destQ.toArray( new Byte[0]);</p>

<p> int matchCount = 0; // 已匹配的字节数</p>

<p> int flagPos = -1; // 标志末尾的编号</p>

<p> int i = 0;</p>

<p> int  backupIndex = 0; // 用于回溯的索引</p>

<p> while (i &lt;= destQ.size()) {</p>

<p> if (flag.length() &lt;= matchCount) {</p>

<p> flagPos = i;</p>

<p> break ;</p>

<p> } else {</p>

<p> if (destArr[i] == flagArr[matchCount]) {</p>

<p> matchCount++;</p>

<p> } else {</p>

<p> matchCount = 0;</p>

<p> // i = backupIndex;</p>

<p> }</p>

<p> }</p>

<p> i = i + 1;</p>

<p> if (matchCount == 1) {</p>

<p> backupIndex = i;</p>

<p> }</p>

<p> }</p>

<p> return flagPos;</p>

<p> }</p>

<p> @Test</p>

<p> public  void runFindFlag() {</p>

<p> LinkedBlockingQueue<Byte> analyzerBuffer = new LinkedBlockingQueue<Byte>();</p>

<p> for ( int i = 33; i &lt; 123; i++) {</p>

<p> analyzerBuffer.offer( new Byte(( byte ) i));</p>

<p> }</p>

<p> String endFlag = &ldquo;123&rdquo; ;</p>

<p> int endFlagPos = findFlag(analyzerBuffer, endFlag);</p>

<p> List<Byte> cmplXmlStr = new ArrayList<Byte>();</p>

<p> analyzerBuffer.drainTo(cmplXmlStr, endFlagPos);</p>

<p> System. out .println(cmplXmlStr);</p>

<p> }</p>
]]></content>
  </entry>
  
</feed>
