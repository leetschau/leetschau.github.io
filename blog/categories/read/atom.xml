<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Read | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/read/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-04-02T09:35:25+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用输入流读取数据时的阻塞问题]]></title>
    <link href="http://leetschau.github.io/blog/2010/08/20/085649/"/>
    <updated>2010-08-20T08:56:49+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/08/20/085649</id>
    <content type="html"><![CDATA[<p>使用java.io.BufferedInputStream.read(byte[])方法读取Socket中传过来的数据时，如果需要超时退出判断机制，一定要注意B ufferedInputStream.available()的使用。下面的代码片段是一个很标准的读取过程，其中第5行的判断很重要，因为read( byte[] )方法本身是阻塞的，如果自始至终is没有收到任何数据，就会一直阻塞在read()方法上（第6行），导致整个超时判断机制失去作用，而 available()方法的使用避免了这种可能性。</p>

<p> 示例程序代码：</p>

<p> 01      try {   02           long startTime = System.currentTimeMillis();   03           while (someCriteria) {   04                byte[] cache = new byte[1024];   05                if (is.available() > 0) {   06                     int count = is.read(cache);   07                     if (count &lt;= 0) {   08                          if (System.currentTimeMillis() - startTime >= timeout) {   09                               throw new GapiException(&ldquo;Connection Time Out!&rdquo;);   10                          }   11                          continue;   12                     }   13                     // 后续处理   14                }   15                if (System.currentTimeMillis() - startTime >= timeout) {   16                     throw new GapiException(&ldquo;Connection Time Out!&rdquo;);   17                }   18                Thread.sleep(10);   19           }   20      } catch (Exception e) {   21           logger.error(&ldquo;ERROR: &rdquo;, e);   22      }</p>

<p> 程序流程图：</p>
]]></content>
  </entry>
  
</feed>
