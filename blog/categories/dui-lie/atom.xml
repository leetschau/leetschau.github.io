<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 队列 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/dui-lie/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-10-03T10:36:40+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ConcurrentLinkedQueue vs LinkedBlockingQueue]]></title>
    <link href="http://leetschau.github.io/blog/2013/02/04/151243/"/>
    <updated>2013-02-04T15:12:43+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/02/04/151243</id>
    <content type="html"><![CDATA[<p>根据LinkedBlockingQueue实现的接口BlockingQueue的文档，BlockingQueue及其所有实现类都是线程安全的，且可用于多个Producer/Consumer的场景，它的主要用途是Producer-Consumer模型，它提供了4种出/入队列的方法，分别是抛异常、特殊值、阻塞和超时。</p>

<p>LinkedBlockingQueue初始化时可以设置容量，所以BlockingQueue具备一种“流量平衡”能力，即当消费过快以至于队列空时，出队列（消费）操作将阻塞；生产过快以至于队列满时，入队列（生产）操作将阻塞。</p>

<p>BlockingQueue的take()方法在阻塞状态下是不消耗CPU的。</p>

<p>ConcurrentLinkedQueue是一个"wait-free" algorithm（见文档），它的使用场景目前还不清楚。</p>

<p>参考：</p>

<p> <a href="http://stackoverflow.com/questions/1426754/linkedblockingqueue-vs-concurrentlinkedqueue">http://stackoverflow.com/questions/1426754/linkedblockingqueue-vs-concurrentlinkedqueue</a></p>

<p> <a href="http://stackoverflow.com/questions/1426342/need-a-queue-that-can-support-multiple-readers/1426375#1426375">http://stackoverflow.com/questions/1426342/need-a-queue-that-can-support-multiple-readers/1426375#1426375</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[将队列转换为字符串]]></title>
    <link href="http://leetschau.github.io/blog/2010/08/11/085442/"/>
    <updated>2010-08-11T08:54:42+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/08/11/085442</id>
    <content type="html"><![CDATA[<p>LinkedBlockingQueue<Byte> inputQ = new LinkedBlockingQueue<Byte>();</p>

<p> Byte[] destArr = inputQ.toArray( new Byte[0]);</p>

<p> byte [] resultArr = new  byte [destArr. length ];</p>

<p> for ( int i = 0; i &lt; resultArr. length ; i++) {</p>

<p>  resultArr[i] = destArr[i].byteValue();</p>

<p> }</p>

<p> strRes = new String(resultArr);</p>

<p> 转换过程是：队列==>Byte数组==>byte数组==>字符串。下面是应用了此一转换的完整的Result类实现。</p>

<p> /**</p>

<ul>
<li><p>通过字节队列创建一个新的返回结果实例</p></li>
<li></li>
<li><p>@param inputQ</p></li>
<li><p> 结果字节队列</p></li>
<li><p>@param cmdType</p></li>
<li><p> 命令返回类型</p></li>
</ul>


<p> */</p>

<p> public Result( final LinkedBlockingQueue<Byte> inputQ, final  int cmdType) {</p>

<p>  cmdReturnType = cmdType;</p>

<p>  Byte[] destArr = inputQ.toArray( new Byte[0]);</p>

<p>  byte [] resultArr = new  byte [destArr. length ];</p>

<p>  for ( int i = 0; i &lt; resultArr. length ; i ++) {</p>

<p>   resultArr[ i ] = destArr[ i ].byteValue();</p>

<p>  }</p>

<p>  strRes = new String(resultArr);</p>

<p> }</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在队列中寻找字符串算法]]></title>
    <link href="http://leetschau.github.io/blog/2010/08/10/203539/"/>
    <updated>2010-08-10T20:35:39+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/08/10/203539</id>
    <content type="html"><![CDATA[<p>在一个队列destQ中，从前向后搜索是否有字符串flag，下面是算法实现以及测试程序。回溯功能暂未实现。</p>

<p> private  int findFlag( final LinkedBlockingQueue<Byte> destQ,</p>

<p> final String flag) {</p>

<p> byte [] flagArr = flag.getBytes();</p>

<p> Byte[] destArr = destQ.toArray( new Byte[0]);</p>

<p> int matchCount = 0; // 已匹配的字节数</p>

<p> int flagPos = -1; // 标志末尾的编号</p>

<p> int i = 0;</p>

<p> int  backupIndex = 0; // 用于回溯的索引</p>

<p> while (i &lt;= destQ.size()) {</p>

<p> if (flag.length() &lt;= matchCount) {</p>

<p> flagPos = i;</p>

<p> break ;</p>

<p> } else {</p>

<p> if (destArr[i] == flagArr[matchCount]) {</p>

<p> matchCount++;</p>

<p> } else {</p>

<p> matchCount = 0;</p>

<p> // i = backupIndex;</p>

<p> }</p>

<p> }</p>

<p> i = i + 1;</p>

<p> if (matchCount == 1) {</p>

<p> backupIndex = i;</p>

<p> }</p>

<p> }</p>

<p> return flagPos;</p>

<p> }</p>

<p> @Test</p>

<p> public  void runFindFlag() {</p>

<p> LinkedBlockingQueue<Byte> analyzerBuffer = new LinkedBlockingQueue<Byte>();</p>

<p> for ( int i = 33; i &lt; 123; i++) {</p>

<p> analyzerBuffer.offer( new Byte(( byte ) i));</p>

<p> }</p>

<p> String endFlag = &ldquo;123&rdquo; ;</p>

<p> int endFlagPos = findFlag(analyzerBuffer, endFlag);</p>

<p> List<Byte> cmplXmlStr = new ArrayList<Byte>();</p>

<p> analyzerBuffer.drainTo(cmplXmlStr, endFlagPos);</p>

<p> System. out .println(cmplXmlStr);</p>

<p> }</p>
]]></content>
  </entry>
  
</feed>
