<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Socket | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/socket/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-11-11T15:03:30+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Socket Closed异常形成原因]]></title>
    <link href="http://leetschau.github.io/blog/2012/07/23/104342/"/>
    <updated>2012-07-23T10:43:42+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/07/23/104342</id>
    <content type="html"><![CDATA[<p>多个线程中的一个如果调用了socket.close()方法，其他线程在进行读/写时会出现socket close异常，例如：</p>

<p> java.net.SocketException: socket closed</p>

<p> at java.net.SocketInputStream.socketRead0(Native Method)</p>

<p> at java.net.SocketInputStream.read(SocketInputStream.java:129)</p>

<p> at java.net.SocketInputStream.read(SocketInputStream.java:90)</p>

<p> at server. UserListener .run(UserListener.java:36)</p>

<p> at java.lang.Thread.run(Thread.java:662)</p>

<p>下面是对应的代码，父线程在执行完任务后sock.close()关闭了socket，导致south线程中uin（sock的InputStream）运行read()方法时出现socket close异常：</p>

<p>父线程：</p>

<p>  uin = sock.getInputStream();
 uout = sock.getOutputStream();
 Runnable south = new UserListener (uin, nos);
 new Thread(south, &ldquo;south&rdquo;).start();
 &hellip;
 sock.close();</p>

<p>south线程：</p>

<p>  public class UserListener implements Runnable {
  @Override
  public void run() {
   &hellip;
   recv = uin.read(buf); //异常抛出点
   &hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最简单的Socket通信之Python版]]></title>
    <link href="http://leetschau.github.io/blog/2011/03/16/145839/"/>
    <updated>2011-03-16T14:58:39+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/03/16/145839</id>
    <content type="html"><![CDATA[<p>功能很简单，首先运行Server，当启动Client并向Server发送‘hi’时，
Server回答一句问候语，当Client发送其他信息时，Server回答'bye'并关闭连接、退出。</p>

<p>Server端：</p>

<pre><code>import sys, socket 
serv = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
serv.bind(('localhost',7788)) 
serv.listen(2) 
while True: 
    connection,address = serv.accept() 
    try: 
        connection.settimeout(35) 
        buf = connection.recv(1024) 
        if buf=='hi': 
            connection.send('welcome to server!') 
        else: 
            connection.send('bye!') 
            connection.close() 
            sys.exit(0) 
    except socket.timeout: 
        print 'time out!' 
</code></pre>

<p>Client端：</p>

<pre><code>import socket 
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
sock.connect(('localhost', 7788)) 
import time 
time.sleep(2) 
sock.send('hi') 
print sock.recv(1024) 
sock.close() 
</code></pre>

<p>注意Server和Client都在本机运行时，要在不同的软件上运行，
例如Server用WingIDE跑，Client用PyScripter跑。</p>

<p>Server端通信的基本过程是：建立socke对象->bind->listen->connection周期->close，
其中connection周期是：
首先用socket server的accept方法生成一个新的socket对象（习惯上成为connection），
然后用connection的send/rec方法发送/接收数据，
最后调用connection的close方法关闭连接。
由于服务器经常要以“服务”的形式不断处理客户连接，
因此connection周期通常要放在一个循环体里。</p>

<p>Client端通信的基本过程是：建立socke对象->connect->send/recv->close。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[客户端socket连接的106号错误分析]]></title>
    <link href="http://leetschau.github.io/blog/2010/11/18/140732/"/>
    <updated>2010-11-18T14:07:32+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/11/18/140732</id>
    <content type="html"><![CDATA[<p>Python的socket模块提供了基于socket的网络连接方法，分为server端和client端，在python2.6中，使用server需依次调用下面的方法：</p>

<p>socket(), bind(), listen(), accept()，其中socket方法是构造函数，可多次调用accept()方法与多个client通信。使用client依次调用 socket()和connect()方法即可。</p>

<p>如果一个client已经用connect()或者connect_ex()方法连接了，在没有close()的情况下再次 connect()或者connect_ex()，则会出现106号错误： Python: Socket Error 106: &lsquo;Transport endpoint is already connected'，connect()方法抛出106号异常，而connect_ex()方法返回值为106（连接成功的返回值为0），解决方法是每次连接时创建一个新的socket，或者先调用close()关闭后再连接。</p>

<p>用connect_ex((host, port))探测端口是否绑定不是很可靠，除了上述106错误外，还有111,即连接被拒绝，建议使用"nc -z host port"代替，不过需要操作系统有netcat，支持nc指令。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用输入流读取数据时的阻塞问题]]></title>
    <link href="http://leetschau.github.io/blog/2010/08/20/085649/"/>
    <updated>2010-08-20T08:56:49+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/08/20/085649</id>
    <content type="html"><![CDATA[<p>使用java.io.BufferedInputStream.read(byte[])方法读取Socket中传过来的数据时，如果需要超时退出判断机制，一定要注意B ufferedInputStream.available()的使用。下面的代码片段是一个很标准的读取过程，其中第5行的判断很重要，因为read( byte[] )方法本身是阻塞的，如果自始至终is没有收到任何数据，就会一直阻塞在read()方法上（第6行），导致整个超时判断机制失去作用，而 available()方法的使用避免了这种可能性。</p>

<p> 示例程序代码：</p>

<p> 01      try {   02           long startTime = System.currentTimeMillis();   03           while (someCriteria) {   04                byte[] cache = new byte[1024];   05                if (is.available() > 0) {   06                     int count = is.read(cache);   07                     if (count &lt;= 0) {   08                          if (System.currentTimeMillis() - startTime >= timeout) {   09                               throw new GapiException(&ldquo;Connection Time Out!&rdquo;);   10                          }   11                          continue;   12                     }   13                     // 后续处理   14                }   15                if (System.currentTimeMillis() - startTime >= timeout) {   16                     throw new GapiException(&ldquo;Connection Time Out!&rdquo;);   17                }   18                Thread.sleep(10);   19           }   20      } catch (Exception e) {   21           logger.error(&ldquo;ERROR: &rdquo;, e);   22      }</p>

<p> 程序流程图：</p>
]]></content>
  </entry>
  
</feed>
