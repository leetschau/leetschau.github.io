<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-02-02T16:10:00+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Good Tutorial About C++ Syntax and Points]]></title>
    <link href="http://leetschau.github.io/blog/2014/05/29/115513/"/>
    <updated>2014-05-29T11:55:13+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/05/29/115513</id>
    <content type="html"><![CDATA[<p>The whole tutorial <a href="http://www.cplusplus.com/doc/tutorial/">C++ Language</a> is concise and helpful. The section <a href="http://www.cplusplus.com/doc/tutorial/pointers/">Pointers</a> is a good introduction of pointers. It distinguishes many myth of pointers, for example:</p>

<ul>
<li><p>It distinguishes &ldquo;pointer declaration&rdquo; of &ldquo;dereference operation&rdquo;. They use both the same operator &ldquo;*&rdquo;, but are different things.</p></li>
<li><p>Pointer and array are largely the same, but an import difference: pointer can be reassigned, while array variable can&rsquo;t.</p></li>
<li><p>Incrementation of a pointer produce different result regarding to the data type it referenced. Say a pointer p has the address 1000, according to its referenced type, the incrementation results are:</p>

<p>  char * p; p = 1000; p++ is 1001;
  short * p; p = 1000; p++ is 1002;
  long * p; p = 1000; p++ is 1004;</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debug Binary File Reading C++ Codes With Gdb]]></title>
    <link href="http://leetschau.github.io/blog/2014/05/23/171938/"/>
    <updated>2014-05-23T17:19:38+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/05/23/171938</id>
    <content type="html"><![CDATA[<p>We need debug a C++ file, which read and analyze a binary file. We use gdb and xxd in this case. In tmux, split a window horizontally, run gdb in the upper bigger pane, and list file content in lower smaller pane.</p>

<pre><code>$ tmux new -s basic
A-f,-   // split window, I define &lt;prefix&gt; of tmux as A-f in ~/.tmux.conf: set -g prefix M-f
A-f,JJ  // make upper pane larger
$ xxd -l 33 &lt;input-binary-file&gt;.dat   // print first 32 bytes of this file
0000000: 202a 463b 862e d108 2100 ab55 8006 f407   *F;....!..U....
0000010: 0000 0000 0a0e 0401 0102 1800 5201 0501  ............R...
0000020: 15
A-f,k   // jump to upper window
$ cat readfile.cc
#include &lt;fstream&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

typedef unsigned char BYTE;

BYTE *read_section(FILE *istream, int *length);

int main() {
    string filename = "/home/chad/docs/eclipsews/MrParser/doc/ns-output/1296_2014_04_25_10_00_MR.dat";
    char *fn = const_cast&lt;char*&gt;(filename.c_str());
    FILE *rstream = fopen(fn, "rb"); // 打开.dat文件
    BYTE *buffer = NULL;
    int length = 0;
    buffer = read_section(rstream, &amp;length);
    fclose(rstream);
    printf("Read file length: %d\n", length);
    return 0;
}

BYTE *read_section(FILE *istream, int *length) {
    int count = 0;
    size_t ret = 0;
    BYTE buf[128];
    BYTE *buffer = NULL;

    ret = fread(buf, sizeof(char), 8, istream); if (8 != ret) return NULL;
    ret = fread(buf, sizeof(char), 2, istream); if (2 != ret) return NULL;
    *length = buf[1] * 256 + buf[0];
    if ( 0 == *length) return NULL;
    buffer = new BYTE[*length];
    fseek(istream, -10, SEEK_CUR);
    ret = fread(buffer, sizeof(char), *length, istream);
    if (*length != ret) {
        delete [] buffer;
        return NULL;
    }
    return buffer;
}
$ g++ -g readfile.cc -o rr
$ gdb rr
l
// list source code, we want to probe the content of variable "buffer" after the "fread" operation. So we add a breakpoint after that line
b 37
r
(gdb) p/x *buffer@33
$1 = {0x20, 0x2a, 0x46, 0x3b, 0x86, 0x2e, 0xd1, 0x8, 0x21, 0x0, 0xab, 0x55, 0x80, 0x6, 0xf4, 0x7, 0x0, 0x0, 0x0, 0x0, 0xa, 0xe, 0x4, 0x1, 0x1,
  0x2, 0x18, 0x0, 0x52, 0x1, 0x5, 0x1, 0x15}
p/x buffer[0]
$2 = 0x20
c
q
</code></pre>

<p>where l=list, r=run, p/x means &ldquo;print value in hex format&rdquo;, c=continue, q=quit.
You can see the bytes of &ldquo;buffer&rdquo; is exactly the same with the output of xxd command: 0x20, 0x2a, &hellip;, 0x15.</p>

<p>The format of gdb&rsquo;s print see <a href="http://www.delorie.com/gnu/docs/gdb/gdb_55.html">8.4 Output formats</a> for details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Convert MS Visual Studio C++ Project to Makefile]]></title>
    <link href="http://leetschau.github.io/blog/2014/05/21/090511/"/>
    <updated>2014-05-21T09:05:11+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/05/21/090511</id>
    <content type="html"><![CDATA[<p>This morning I converted a Microsoft Visual Studio 2008 C++ solution to a Linux makefile with <a href="http://code.google.com/p/make-it-so/">MakeItSo</a>. The process:</p>

<ol>
<li><p>On a Windows host with VS2008 installed, download MakeItSo_1.2.2.zip from its website, unzip it;</p></li>
<li><p>In the unzipped folder, run <code>MakeItSo.exe -file=c:\docs\myproject\myproj.sln</code>;</p></li>
<li><p>In the root folder of the solution, a Makefile is generated. A <project-name>.makefile is generated at each project folder (where the .vcproj file resides).</p></li>
<li><p>Copy the solution folder to a Linux host with &ldquo;make&rdquo; installed (verified with <code>make --version</code>), run <code>make</code> to build the whole solution or <code>make &lt;project-name&gt;</code> to build a specific project.</p></li>
</ol>


<p>That&rsquo;s it.</p>

<p>Note: Another coverting tool <a href="http://www.codeproject.com/Articles/28908/Tool-for-Converting-VC-Project-to-Linux-Makef">sln2mak</a> is also tried this morning, but failed.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Develop Environment With Vim on Linux]]></title>
    <link href="http://leetschau.github.io/blog/2014/04/29/180645/"/>
    <updated>2014-04-29T18:06:45+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/04/29/180645</id>
    <content type="html"><![CDATA[<h1>ctags</h1>

<h2>Install</h2>

<pre><code>$ sudo apt-get install exuberant-ctags
</code></pre>

<h2>Usage</h2>

<pre><code>$ cd $PROJECT_HOME
$ ctags -R *
$ vi MyApp.cpp
</code></pre>

<p>Some frequently used shortcuts:</p>

<ul>
<li><p>Go to definition: Ctrl-]</p></li>
<li><p>Jump back from definition: Ctrl-t</p></li>
<li><p>C-w C-]: Open the definition in a horizontal split</p></li>
<li><p>C-o/i: jump between items in jump list;</p></li>
<li><p>gf: &ldquo;go to file&rdquo;, open the file under the cursor;</p></li>
<li><p>gd: &ldquo;go to definition&rdquo;, go to the definition of a variable;</p></li>
</ul>


<p>Ref: <a href="http://stackoverflow.com/questions/563616/vim-and-ctags-tips-and-tricks">http://stackoverflow.com/questions/563616/vim-and-ctags-tips-and-tricks</a></p>

<h1>Buffer explorer</h1>

<h2>Install</h2>

<ol>
<li><p>Download bufexplorer-7.4.2.zip from <a href="http://www.vim.org/scripts/script.php?script_id=42">it&rsquo;s website</a>;</p></li>
<li><p>unzip it to ~/.vim/bundle/ (you have to install pathogen before hand);</p></li>
<li><p>restart vim;</p></li>
</ol>


<h2>Usage</h2>

<p>:h buffer-explorer</p>

<p><leader>be, <leader>bs, <leader>bv</p>

<p>I defined my <leader> key to comma(let mapleader=&ldquo;,&rdquo;) in .vimrc, so open buffer explorer window with &ldquo;,be&rdquo;.</p>

<h1>Tagbar</h1>

<p>This plugin is for C/C++ code outline.</p>

<p>Installation: Downlaod majutsushi-tagbar-v2.6.1-0-ge872e67.zip from <a href="http://majutsushi.github.io/tagbar/">it&rsquo;s website</a>, unzip to ~/.vim/bundle/ and restart vim.</p>

<p>:h tagbar</p>

<p>:TagbarToogle to open outline window; try <Enter>, p, <Space> in outline window.</p>

<h1>c.vim</h1>

<p>Download cvim.zip v6.1.1 from its <a href="http://www.vim.org/scripts/script.php?script_id=213">website</a>. Unzip it to ~/.vim/bundle.</p>

<p>Add the following line  to ~/.vimrc to override the default <leader> key:</p>

<pre><code>let g:C_MapLeader  = ','
</code></pre>

<p>Use &ldquo;,rc&rdquo; to save and compile. Use <code>:cn</code>, <code>:cp</code>, <code>:cfirst</code>, <code>:clast</code>, <code>:cc</code>, <code>:cclose</code>, <code>:copen</code> to traverse in quickfix list (see <code>:h quickfix</code> for full list of hotkeys).</p>

<p>Use F9 or &ldquo;,rr&rdquo; to run source file.</p>

<p>Use &ldquo;2. Usage without GUI&rdquo; and &ldquo; 3. Hotkeys&rdquo; in <code>:h csupport</code> for full list of hotkeys.</p>

<h1>Configuration for REPL</h1>

<ol>
<li><p>Add &ldquo;:nnoremap <F5> :<C-U>make %:r &amp;&amp; ./%:r<CR>&rdquo; to ~/.vimrc;</p></li>
<li><p>Open vim, copy the following c++ codes into it:</p>

<p> using namespace std;</p>

<p> int main() {
     cout &lt;&lt; &ldquo;hello C++.\n&rdquo;;
 }</p></li>
<li><p>Save the file, syntastic(search tag syntastic for installation and usage details) will report an error: ‘cout’ was not declared in this scope</p></li>
<li><p>Add &ldquo;#include <iostream>&rdquo; at the beginning of the file, save it, and press <F5>, you can see the result;</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何利用VBA嵌入C++ Builder驱动Office]]></title>
    <link href="http://leetschau.github.io/blog/2006/11/24/091815/"/>
    <updated>2006-11-24T09:18:15+08:00</updated>
    <id>http://leetschau.github.io/blog/2006/11/24/091815</id>
    <content type="html"><![CDATA[<p>下面的代码是点击Button1后，新建一个Excel文档，并在指定的单元格上添加一个超链接。</p>

<p>void __fastcall TForm1::Button1Click(TObject *Sender)
{
 Variant vHandleExcelApp, vHandleWorkbook, vHandleSheet, vHandleCell;
 AnsiString ansi,tmpStr;
 tmpStr = &ldquo;file:///E:\aaa\zOut1\sss.txt&rdquo;; //字符串中“\”要写成“\”
 //this->Edit1->Text = ansi;
 try{
 vHandleExcelApp = Variant::CreateObject(&ldquo;Excel.Application&rdquo;);
 } catch(&hellip;) {
 Application->MessageBox(&ldquo;无法启动Excel&rdquo;, &ldquo;错误&rdquo;, MB_ICONSTOP|MB_OK);
 return;
 }
 vHandleExcelApp.OlePropertySet(&ldquo;Visible&rdquo;, true);
 vHandleExcelApp.OlePropertyGet(&ldquo;WorkBooks&rdquo;).OleFunction(&ldquo;Add&rdquo;,1);
 vHandleWorkbook = vHandleExcelApp.OlePropertyGet(&ldquo;ActiveWorkBook&rdquo;);
 vHandleSheet = vHandleWorkbook.OlePropertyGet(&ldquo;ActiveSheet&rdquo;);
 ansi = &ldquo;research for&rdquo;;
 vHandleSheet.OlePropertyGet(&ldquo;Cells&rdquo;, 2, 1).OlePropertySet(&ldquo;Value&rdquo;, ansi);
 vHandleCell = vHandleSheet.OlePropertyGet(&ldquo;Cells&rdquo;, 2, 1);
 vHandleSheet.OlePropertyGet(&ldquo;Hyperlinks&rdquo;).OleFunction(&ldquo;Add&rdquo;,vHandleCell,tmpStr,&ldquo;the caption here&rdquo;);
}</p>

<p>相应的VBA代码是：</p>

<p>ActiveSheet.Hyperlinks.Add Anchor:=ActiveSheet.Cells(2,1), Address:= &ldquo;E:\MyDoc\using_javadoc.doc&rdquo;, TextToDisplay:=&ldquo;some text here&rdquo;</p>

<p>可见使用OlePropertyGet、OlePropertySet、OleFunction三个函数基本上可以实现从VBA到C++代码的转换。</p>
]]></content>
  </entry>
  
</feed>
