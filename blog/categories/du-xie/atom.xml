<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 读写 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/du-xie/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-02-21T11:06:40+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[依赖项目文本排序（python实现）]]></title>
    <link href="http://leetschau.github.io/blog/2010/12/22/164556/"/>
    <updated>2010-12-22T16:45:56+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/12/22/164556</id>
    <content type="html"><![CDATA[<p>ivy的依赖文件如果条目很多，不排序的话会很乱，例如：</p>

<p> &lt;ivy:install organisation=&ldquo;javax.servlet&rdquo; module=&ldquo;servlet-api&rdquo; revision=&ldquo;2.5&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;junit&rdquo; module=&ldquo;junit&rdquo; revision=&ldquo;4.8.2&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.powermock&rdquo; module=&ldquo;powermock-module-junit4&rdquo; revision=&ldquo;1.4.6&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.snmp4j&rdquo; module=&ldquo;snmp4j&rdquo; revision=&ldquo;1.10.1&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.apache.oro&rdquo; module=&ldquo;jakarta-oro&rdquo; revision=&ldquo;2.0.8&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.easymock&rdquo; module=&ldquo;easymockclassextension&rdquo; revision=&ldquo;2.5.1&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> （ori.txt中这里是空行）</p>

<p>排成这样就比较好看了：</p>

<p> &lt;ivy:install organisation=&ldquo;javax.servlet&rdquo; module=&ldquo;servlet-api&rdquo; revision=&ldquo;2.5&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;junit&rdquo; module=&ldquo;junit&rdquo; revision=&ldquo;4.8.2&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.apache.oro&rdquo; module=&ldquo;jakarta-oro&rdquo; revision=&ldquo;2.0.8&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.easymock&rdquo; module=&ldquo;easymockclassextension&rdquo; revision=&ldquo;2.5.1&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.powermock&rdquo; module=&ldquo;powermock-module-junit4&rdquo; revision=&ldquo;1.4.6&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.snmp4j&rdquo; module=&ldquo;snmp4j&rdquo; revision=&ldquo;1.10.1&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p>实际上就是每行按字母顺序排序，手工排费时费力，下面的脚本就是实现这个功能的，将最上面的文本保存为e:/MyDoc/Project/IvyInstallScripts下的build_old_backup.txt（注意最后一行文字后面要有一个空行）中，运行此脚本，排好的文本保存在build_old_backup.txt中，未排序的原始文本保存在build_old_backup.bak中，如果文件夹下已经有build_old_backup.bak，则会首先删除此bak文件，再执行上面的操作：</p>

<p> import os</p>

<p> if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<p>  #name of the source file</p>

<p>  srcFileName = &lsquo;e:/MyDoc/Project/IvyInstallScripts/build_old_backup&rsquo;</p>

<p>  haveXML = os.path.exists(srcFileName+&lsquo;.txt&rsquo;)</p>

<p>  haveBAK = os.path.exists(srcFileName+&lsquo;.bak&rsquo;)</p>

<p>  if haveXML and haveBAK:</p>

<p>   os.remove(srcFileName+&lsquo;.bak&rsquo;)</p>

<p>  if haveXML:</p>

<p>   os.rename(srcFileName+&lsquo;.txt&rsquo;, srcFileName+&lsquo;.bak&rsquo;)</p>

<p>   haveBAK = True</p>

<p>  if not haveBAK:</p>

<p>   print(&ldquo;no source file, quit now!&rdquo;)</p>

<p>   exit()</p>

<p>  # open the src file</p>

<p>  oriScript = open(srcFileName+&lsquo;.bak&rsquo;,&lsquo;rt&rsquo;)</p>

<p>  #the destination file</p>

<p>  destScript = open(srcFileName+&lsquo;.txt&rsquo;,&lsquo;wt&rsquo;)</p>

<p>  try:</p>

<p>   wholeTxt = []</p>

<p>   for curLine in oriScript:</p>

<pre><code>#print(len(curLine)) 

wholeTxt.append(curLine) 
</code></pre>

<p>   wholeTxt.sort()</p>

<p>   for curLine in wholeTxt:</p>

<pre><code>destScript.write(curLine) 
</code></pre>

<p>  finally:</p>

<p>   oriScript.close()</p>

<p>   destScript.close()</p>

<p>下面是简单版：更为易用，保存为一个.py文件即可。</p>

<p> &ldquo;&rdquo;"</p>

<p>  将文本中的各行按字母顺序排序。使用方法：</p>

<p>  将待排序的文本保存在脚本所在目录下，运行脚本，结果保存在dst.txt文件中。</p>

<p> &ldquo;&rdquo;"</p>

<p> import os</p>

<p> oriScript = open(&lsquo;./ori.txt&rsquo;,&lsquo;rt&rsquo;)</p>

<p> dstScript = open(&lsquo;./dst.txt&rsquo;,&lsquo;wt&rsquo;)</p>

<p> try:</p>

<p>  wholeTxt = []
 for curLine in oriScript:
  wholeTxt.append(curLine)
 noDupList = list(set(wholeTxt)) # delete potential duplicated lines in wholeTxt
 noDupList.sort()
 for curLine in noDupList:
  dstScript.write(curLine)</p>

<p> finally:</p>

<p>  oriScript.close()</p>

<p>  dstScript.close()</p>
]]></content>
  </entry>
  
</feed>
