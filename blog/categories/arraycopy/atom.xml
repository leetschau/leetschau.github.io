<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Arraycopy | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/arraycopy/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-01-23T11:15:02+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自动登录的实现方法]]></title>
    <link href="http://leetschau.github.io/blog/2012/07/23/164732/"/>
    <updated>2012-07-23T16:47:32+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/07/23/164732</id>
    <content type="html"><![CDATA[<h1>基于字节数组的定长队列</h1>

<p>这个队列可以在队尾追加（add）数据，由于是定长的，所以追加数据会将头部的数据“推出”队列。另外该队列可以检查是否包含（contains）某一子字符串，或者更进一步，检查是否包含某个用正则表达式表示的模式。这种数据结构主要用在Telnet Client的自动登录过程中，检查收到的报文中是否有预期的标志，以决定是否发送登录信息（用户名、密码等）。下面是一个实现：</p>

<p> public class ByteQueue {
  private final Logger logger = LoggerFactory.getLogger(this.getClass().getName());
  private final int BUFFER_LENGTH = 32;
  byte[] buffer = new byte[BUFFER_LENGTH];
  public void add(byte[] income, int len) {
   logger.debug(&ldquo;income is: &rdquo; + BytesHandler.bytes2HexString(income));
   byte[] tmp = new byte[BUFFER_LENGTH + len];
   System.arraycopy(buffer, 0, tmp, 0, buffer.length);
   System.arraycopy(income, 0, tmp, buffer.length, len);
   System.arraycopy(tmp, tmp.length - BUFFER_LENGTH, buffer, 0,
     BUFFER_LENGTH);
  }
  public boolean contains(String sub) {
   String bufStr = null;
   try {
    bufStr = new String(buffer, &ldquo;ISO8859-1&rdquo;);
   } catch (UnsupportedEncodingException e) {
    logger.error(&ldquo;bad encoding: ISO8859-1&rdquo;);
   }
   return bufStr.contains(sub);
  }
 }</p>

<p>上述&#8221;ISO8859-1&#8221;编码又名Latin-1，据“ ISO8859-1、UTF-8 与GB2312 ”一文是Java网络传输的标准编码，又据“ Java: Regex on byte array ”一文，这是一个单字节的编码方案，所以可以用字符串的contains方法完成字节的查找。“ 字符在utf-8,gbk,gb2312,iso8859-1下的编码实验 ”的结果很有参考价值。</p>

<p>下面的代码演示了如何使用上面的类完成自动登录：</p>

<p> ByteQueue bq = new ByteQueue();
 while (true) {
  byte[] buf = new byte[128];
  int recv = nis.read(buf);
  if (recv == -1) {
   logger.info(&ldquo;read -1 from client.&rdquo;);
   break;
  }
  logger.debug(&ldquo;client send: &rdquo;
    + BytesHandler.bytes2HexString(buf));
  uout.write(buf, 0, recv);
  uout.flush();
  // execute login script</p>

<p>  String expTest = expQ.peek(); //expQ是预期队列：&#8221;ogin:&ldquo;, &#8220;assword:&#8221;，sendQ是发送队列：&#8221;myusername&rdquo;, &ldquo;mypwd&rdquo;
  if (expTest != null) {
   bq.add(buf, recv); //由于buf是定长数组，其中会有很多0，所以add的第二个参数len标示了有效数据的长度很重要
   if (bq.contains(expTest)) {
    String exp = expQ.poll() + &ldquo;\r\n&rdquo;; // 一定不要忘了加回车！
    String send = sendQ.poll() + &ldquo;\r\n&rdquo;;
    nos.write(send.getBytes(&ldquo;UTF-8&rdquo;));
    nos.flush();
   }
  }
 }</p>

<h1>打印字节数组内容（调试时很有用）</h1>

<p> public static String bytes2HexString(byte[] b) {
  String ret = &ldquo;&rdquo;;
  for (int i = 0; i &lt; b.length; i++) {
   String hex = Integer.toHexString(b[i] &amp; 0xFF);
   if (hex.length() == 1) {
    hex = &lsquo;0&rsquo; + hex;
   }
   ret += hex.toUpperCase();
  }
  return ret;
 }</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arraycopy将数组分为两部分时游标的设置方法]]></title>
    <link href="http://leetschau.github.io/blog/2010/08/10/140800/"/>
    <updated>2010-08-10T14:08:00+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/08/10/140800</id>
    <content type="html"><![CDATA[<p>System.arraycopy是复制数组的一个常用工具，它在游标处如何分为两个是一个需要注意的问题，例如下面的示例代码：</p>

<p>  byte [] src = { 104, 101, 108, 108, 111 };</p>

<p> int endPos = 2;</p>

<p> byte [] dest = new  byte [endPos];</p>

<p> byte [] surplus = new  byte [src. length - endPos];</p>

<p> System. arraycopy (src, 0, dest, 0, dest. length );</p>

<p> System. arraycopy (src, endPos, surplus, 0, src. length - endPos);</p>

<p> 游标（变量endPos）位置为2时，dest数组是{104, 101}，surplus数组是{108, 108, 111}。</p>

<p> 也就是说，编号为游标的元素（从0开始编号）在原数组分割后变为后面数组的第一个元素。</p>
]]></content>
  </entry>
  
</feed>
