<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Buffer | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/buffer/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-11-11T15:03:30+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用minibufferexpl管理vim Buffer]]></title>
    <link href="http://leetschau.github.io/blog/2016/09/15/120809/"/>
    <updated>2016-09-15T12:08:09+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/09/15/120809</id>
    <content type="html"><![CDATA[<p>使用Vundle安装：<code>Plugin 'fholgado/minibufexpl.vim'</code>.</p>

<h1>配置mbe</h1>

<p>隐藏mbe状态栏： TODO</p>

<p>在.vimrc中添加：</p>

<pre><code>cabbrev mt MBEToggle&lt;CR&gt;
cabbrev mru MBEToggleMRU&lt;CR&gt;
cabbrev vb vert sb
</code></pre>

<h1>常用快捷键</h1>

<ul>
<li><p>打开buffer: 用ctrlp或者nerdtree插件；</p></li>
<li><p>删除编号为n的buffer：<code>:bdn</code>;</p></li>
<li><p>切换到编号为n的buffer: <code>:bn</code>;</p></li>
<li><p>在水平分割窗口中打开编号为n的buffer：<code>:sbn</code>;</p></li>
<li><p>在垂直分割窗口中打开编号为n的buffer：<code>:vb n</code>;</p></li>
<li><p>打开/关闭mbe窗口; <code>:mt</code>;</p></li>
<li><p>打开/关闭 <em>MRU</em> (most recently used) 模式：<code>:mru</code></p></li>
</ul>


<h1>Note</h1>

<p>MRU模式开启时最近用过的buffer排在最前面，关闭时buffer list顺序保存不变。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[保存Tmux屏幕输出到文件中]]></title>
    <link href="http://leetschau.github.io/blog/2016/06/24/094511/"/>
    <updated>2016-06-24T09:45:11+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/06/24/094511</id>
    <content type="html"><![CDATA[<p>保存Tmux的屏幕输出分为两步：
首先用<code>capture-pane</code>将屏幕输出保存在buffer里，
然后用<code>save-buffer</code>将buffer内容保存到文件里。</p>

<p>在<code>capture-pane</code>中可以用<code>-S</code>和<code>-E</code>指定要保存的屏幕输出的范围，
当前屏幕的最上一行为坐标原点，标记为0，下面一行坐标是1,依次类推；
原点的上一行坐标是-1，再上一行坐标是-2，依次类推。</p>

<p>用<code>Alt-c</code>进入copy-mode后，屏幕右上角显示当前屏幕在整个pane中的坐标[X/Y]，
其中X代表当前屏幕最高行的坐标，Y代表最早一行屏幕输出的坐标，
根据坐标确定要保存文本的起止坐标就可以保存了。</p>

<p>例如要保存第3个pane中的一段近5000行的输出，
进入copy-mode后按<code>g</code>键，到最早的屏幕输出，右上角显示<code>[5676/5676]</code>,
用<code>Ctrl-f</code>或者<code>J</code>键向下滚动屏幕，
当想要保存的第一行处于屏幕最上一行时，坐标显示为<code>[5557/5676]</code>，
将想要保存的最后一行滚动到屏幕最上一行，坐标显示为<code>[642/5676]</code>，
切换到另一个pane里执行：</p>

<pre><code>tmux capture-pane -S -5557 -E -642 -t 3
tmux save-buffer output.log
</code></pre>

<p>这样这段输出就保存到文件output.log里了，其中<code>-t 3</code>指定了要保存的pane的序号。</p>

<p>如果要保存所有历史输出，可以简写为<code>tmux capture-pane -S -</code>.</p>

<p>除了新开一个pane执行tmux命令，也可以在当前pane用快捷键<code>Alt-a</code>进入tmux命令行状态
即command-prompt，然后执行<code>capture-pane -S -5557 -E -642</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QGIS的坐标系和缓冲区]]></title>
    <link href="http://leetschau.github.io/blog/2015/04/29/114138/"/>
    <updated>2015-04-29T11:41:38+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/04/29/114138</id>
    <content type="html"><![CDATA[<p>一个图层文件(shp）有自己的坐标系，通过【右键->属性->通用->坐标参照系】查看。
直接修改坐标系导致图层对象消失，原因不明。
在图层上【右键->另存为】，在坐标系中搜索2154，选择"EPSG:2154"，保存在另一个shp文件中。</p>

<p>在QGIS窗口右下角状态栏中显示的坐标系只作显示用，与图层自己的坐标系无关。</p>

<p>当生成图层对象的缓冲区（主菜单->矢量->地学数据处理工具->缓冲区分析）时，
其中【缓冲距离】的单位是图层自身坐标系确定的单位，
例如WGS84的单位是degree，具体含义尚不清楚，大致是地球这个球体上两点与球心形成夹角的角度，
&ldquo;EPSG:2154"坐标系的单位是米。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java的Buffer读取操作]]></title>
    <link href="http://leetschau.github.io/blog/2012/03/30/155535/"/>
    <updated>2012-03-30T15:55:35+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/03/30/155535</id>
    <content type="html"><![CDATA[<p>Buffer用于从channel中读（或者向channel写）数据，它有3个标记，分别是capacity, limit &amp; position，其中capacity是此buffer的容量（固定值），buffer初始化时（使用allocate方法）设定；limit是有效数据的边界，即0~limit之间是可读/写的数据，position是下一个应该被读/写的位置。</p>

<p>Buffer有两种模式：写模式和读模式，写模式是向buffer中写数据（例如socketChannel.read(buffer)），读模式是从buffer中读出数据。</p>

<p>写模式下limit总等于capacity，读模式下limit是最近一次写入的数据位置。</p>

<p>使用buffer读写数据的基本过程是一个4步循环：</p>

<ol>
<li><p>向buffer写入数据；</p></li>
<li><p>buffer.flip(); // 把buffer从写模式切换到读模式</p></li>
<li><p>从buffer中读出数据；</p></li>
<li><p>if (buffer.hasRemaining()) {buffer.compact();} else {buffer.clear();} // compact和clear方法将buffer切换回写模式，下面有解释</p></li>
</ol>


<p>以上解释来自于<a href="http://tutorials.jenkov.com/java-nio/buffers.html">Java NIO Buffer</a>。</p>

<h1>compact和clear方法</h1>

<p>compact方法将未读完的数据（position与limit之间的数据）平移到buffer头部，然后将position设到这段数据的尾部，这样后面的写操作将在这段数据后追加（见SocketChannel.read()方法的javadoc），而不会覆盖这段数据，然后将limit设为capacity；clear方法令position=0; limit=capacity;从而为读数据做好准备，详见二者的javadoc。</p>

<h1>wrap方法</h1>

<p> ByteBuffer buffer = ByteBuffer.allocate(10);
 byte[] content = { 27, 91, 75, 116, 117 };
 buffer = ByteBuffer.wrap(content);
 assertEquals(0, buffer.position());
 assertEquals(5, buffer.limit());
 assertEquals(5, buffer.capacity());</p>

<p>以上表明wrap方法会改变ByteBuffer对象的容量（capacity），并将其置为读模式；</p>

<h1>实例演示</h1>

<p>下面以ByteBuffer为例说明Java的buffer读写操作，以及对相关的几个参数的影响；</p>

<p> import java.nio.ByteBuffer;
 public class GetPutByteBuffer {
  public static void main(String[] args) {
   ByteBuffer byteBuffer = ByteBuffer.allocate(10);
   System.out.println(&ldquo;pos=&rdquo; + byteBuffer.position() + &ldquo; limit=&rdquo; + byteBuffer.limit() + &ldquo; capacity=&rdquo; + byteBuffer.capacity());
   // pos=0 limit=10 capacity=10
   byteBuffer.put((byte) 20);
   System.out.println(&ldquo;pos=&rdquo; + byteBuffer.position() + &ldquo; limit=&rdquo; + byteBuffer.limit());
   // pos=1 limit=10
   byteBuffer.put((byte) 33);
   System.out.println(&ldquo;pos=&rdquo; + byteBuffer.position() + &ldquo; limit=&rdquo; + byteBuffer.limit());
   // pos=2 limit=10
   byteBuffer.put((byte) 55);
   byteBuffer.flip();
   System.out.println(&ldquo;pos=&rdquo; + byteBuffer.position() + &ldquo; limit=&rdquo; + byteBuffer.limit());
   // pos=0 limit=3
   System.out.println(byteBuffer.get());
   // 20
   System.out.println(&ldquo;pos=&rdquo; + byteBuffer.position() + &ldquo; limit=&rdquo; + byteBuffer.limit());
   // pos=1 limit=3
   byteBuffer.rewind();
   System.out.println(byteBuffer.get());
   // 20
   System.out.println(&ldquo;pos=&rdquo; + byteBuffer.position() + &ldquo; limit=&rdquo; + byteBuffer.limit());
   // pos=1 limit=3
   System.out.println(&ldquo;the remaining is: &rdquo; + byteBuffer.remaining());
   // the remaining is: 2
   while (byteBuffer.hasRemaining()) {
    System.out.println(byteBuffer.get());
    System.out.println(&ldquo;pos=&rdquo; + byteBuffer.position() + &ldquo; limit=&rdquo; + byteBuffer.limit());
   }
   /<em>
   * 33
   * pos=2 limit=3
   * 55
   * pos=3 limit=3
   </em>/
  }
 }</p>

<p>可以看到buffer的capacity是一个固定值，初始化时设定，pos初始为0，limit初始等于capacity，一次读（get）或写（put）都使pos加一，limit不变，flip使limit=pos，pos=0，接收完数据开始读取时这个动作是必须的，rewind使pos=0，相当于重新开始读数据。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Buffer-related Operations in Vim]]></title>
    <link href="http://leetschau.github.io/blog/2011/10/26/144257/"/>
    <updated>2011-10-26T14:42:57+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/10/26/144257</id>
    <content type="html"><![CDATA[<h1>Build-in Shortcuts</h1>

<p>:enew   open a new buffer in the current window (old buffers still exist);</p>

<p>:e <filename> open a existed file in the current window;</p>

<p>:sp <filename> open a file in a horizontal split window;</p>

<p>:vsp <filename> open a file in a vertical split window;</p>

<p>:new    open a new buffer in a horizontal split window;</p>

<p>:vnew   open a new buffer in a vertical split window;</p>

<p>:ls    list all buffers available. Current buffer is marked as &ldquo;%a&rdquo; and last edited buffer marked as &ldquo;#&rdquo;;</p>

<p>:b[N]   switch to [N]th buffers, [N] is buffer number from :ls command;</p>

<p>:b#    switch to last edited buffer;</p>

<p>:bn    switch to next buffer(based on buffer number);</p>

<p>:bp    switch to previous buffer(based on buffer number);</p>

<p>:bd    close current buffer(if this is the only one buffer, a new one will be created);</p>

<p>:sbn/:sbp  open the next/previous buffer in a horizontal split window;</p>

<p>:vert sbn  open the next buffer in a vertical split window;</p>

<p>:bd[N]   close buffer number [N], [N] is buffer number from :ls command;</p>

<p>:sb[N]   open buffer [N] in a horizontal split window;</p>

<p>:vert sb[N]  open another buffer in a vertical split window;</p>

<p>:vs / C-w v  split window vertically;</p>

<p>:clo / C-w q  close window;</p>

<p>:q    quit vim no matter how many buffers exist, or close window when more than one window exist;</p>

<p>Read :h buffer for more.</p>

<h1>Recommended user defined shortcuts</h1>

<p>In .vimrc:</p>

<p>noremap <silent> <left> <C-w>h
noremap <silent> <right> <C-w>l
noremap <silent> <up> <C-w>k
noremap <silent> <down> <C-w>j
nnoremap <leader>q <C-w>q</p>
]]></content>
  </entry>
  
</feed>
