<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 配置 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/pei-zhi/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-09-10T17:28:18+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[python的ConfigParser模块使用方法]]></title>
    <link href="http://leetschau.github.io/blog/2011/01/13/152557/"/>
    <updated>2011-01-13T15:25:57+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/01/13/152557</id>
    <content type="html"><![CDATA[<p>ConfigParser模块读取的配置文件的基本格式是：分节，节名称用中括号括起来，每节内有key:value对，中间用冒号分隔，冒号前的空格会被忽略掉；</p>

<p>[SectionName1]</p>

<p>name1: value1</p>

<p>name2: value2</p>

<p>[SectionName2]</p>

<p>name3: value3</p>

<p>配置文件中可以有注释，有两种风格，一种是#号开头，一种是分号开头。#号必须在行首，分号可以在行中， 但分号前必须有一个空格 。下面的代码读取build.cfg文件中mail节中to_addr的内容：</p>

<p> import ConfigParser</p>

<p> config = ConfigParser.ConfigParser()</p>

<p> config.read(&lsquo;build.cfg&rsquo;)</p>

<p> to_addr = config.get(&lsquo;mail&rsquo;,&lsquo;to_addr&rsquo;)</p>

<p>build.cfg的内容为：</p>

<p>[mail]</p>

<p>to_addr: <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#108;&#105;&#x63;&#x68;&#x61;&#x6f;&#x31;&#64;&#98;&#x6f;&#x63;&#x6f;&#46;&#x63;&#111;&#109;&#46;&#x63;&#110;">&#108;&#x69;&#x63;&#104;&#97;&#x6f;&#49;&#x40;&#98;&#111;&#99;&#x6f;&#46;&#99;&#111;&#109;&#x2e;&#x63;&#x6e;</a> ;this is comments</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ivy的配置管理]]></title>
    <link href="http://leetschau.github.io/blog/2010/12/03/103731/"/>
    <updated>2010-12-03T10:37:31+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/12/03/103731</id>
    <content type="html"><![CDATA[<p>一个项目的Ivy文件（ivy.xml）主要定义了项目的三部分内容：
 项目本身属性：例如开发项目的组织名称，项目名称、项目版本、项目状态、发布日期等； 项目发布产品的定义：逐条列出项目发布的产品，每个产品条目包括：产品名称、产品类型、产品扩展名等； 项目依赖产品的定义：逐条列出产品运行和发布所需要的依赖包的列表，每个依赖包条目包括：该依赖包的组织名、模块名、版本号以及其他特征说明；
为了增加ivy的管理能力以应对复杂的实际应用环境，Ivy提供了配置（configuration）功能，一个配置包含两方面的内容，首先是属于此配置的产品，其次是属于此配置的依赖包。Ivy的依赖管理不是建立在产品的基础上，而是建立在配置的基础上，例如模块（项目）MA的产品AA需要将模块MB的产品AB（jar包）添加到classpath中才能运行，在Ivy文件中不是声明“AA依赖于AB”，而是需要声明“MA的配置CA依赖MB的配置CB”，也就是在MA的ivy.xml文件中会有：</p>

<p> <dependencies></p>

<p> <dependency org="OB" name="MB" rev="..." conf="CA->CB&#8221;/></p>

<p> <dependency .../></p>

<p> </dependencies></p>

<p>由于一个配置对应一个产品，因此上面的声明实际意思是说：CA对应的AA依赖于CB对应的AB。产品与配置的对应关系在<publications>标签中声明：</p>

<p> <publications></p>

<p> <artifact name="AB" type="jar" ext="jar" conf="CB"/></p>

<p> </publications>
 Ivy查找jar包的工作过程
以上面的定义为例，MA搜索MBjar包的过程是：</p>

<p>第一步：MA根据项目指定的ivysetting.xml文件中的defaultResolver属性找到用哪个resolver解析MA的ivy.xml文件的dependency条目，这里是chain-repo，它的第一个解析器chain-release的解析模式是：&#8221;${release.repo.dir}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]&ldquo;，所以ivy会去</p>

<p>&ldquo;s<a href="ftp://godu:bocogodu@10.0.2.47:22/opt/ArtifactRepo/ReleaseArea/">ftp://godu:bocogodu@10.0.2.47:22/opt/ArtifactRepo/ReleaseArea/</a>[organisation]/[module]&rdquo;</p>

<p>这个路径下寻找jar包，具体到</p>

<p> <dependency org="OB" name="MB" rev="2.1" conf="CA->CB&#8221;/></p>

<p>这一条目，用OB替换[organisation]，用MB替换[module]，变成了</p>

<p>s<a href="ftp://godu:bocogodu@10.0.2.47:22/opt/ArtifactRepo/ReleaseArea/OB/MB%EF%BC%88%E5%90%8E%E9%9D%A2%E7%AE%80%E5%86%99%E4%B8%BA%E2%80%9COB/MB%E2%80%9D%EF%BC%89%EF%BC%9B">ftp://godu:bocogodu@10.0.2.47:22/opt/ArtifactRepo/ReleaseArea/OB/MB%EF%BC%88%E5%90%8E%E9%9D%A2%E7%AE%80%E5%86%99%E4%B8%BA%E2%80%9COB/MB%E2%80%9D%EF%BC%89%EF%BC%9B</a></p>

<p>第二步：找到OB/MB后，根据chain-release下面的ivy pattern的定义，找到下面的ivys文件夹里的ivy-2.1.xml文件，此文件中的<publications>一节中，CB这个配置对应的artifact名称是AB，type是jar，ext是jar，因此chain-release下面的artifact pattern就被翻译成了：</p>

<p>&ldquo;s<a href="ftp://godu:bocogodu@10.0.2.47:22/opt/ArtifactRepo/ReleaseArea/OB/MB/jars/AB-2.1.jar">ftp://godu:bocogodu@10.0.2.47:22/opt/ArtifactRepo/ReleaseArea/OB/MB/jars/AB-2.1.jar</a>&#8220;，这个jar包就被作为MB项目发布的AB这个jar包被MA项目引用了。</p>

<p>如果OB/MB下没有ivys/ivy*.xml文件，则artifact默认值是模块名MB，type是jar，ext是jar，所以当需要向产品库里增加单独的jar包时（不是来自Maven Repository），需要首先确定该包的 org 、 module 、 revision 三个属性，然后将jar包命名为 module - revision .jar放在 org / module /jars目录下即可。</p>

<p>上述ivysettings.xml文件内容如下：</p>

<p>&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?></p>

<p> <ivysettings></p>

<p> <settings defaultResolver="chain-repo" defaultConflictManager="all" /></p>

<p> <property name="release.repo.dir" value= "sftp://godu:bocogodu@10.0.2.47:22/opt/ArtifactRepo/ReleaseArea" /></p>

<p> <property name="test.repo.dir" value="sftp://godu:bocogodu@10.0.2.47:22/opt/ArtifactRepo/TestArea" /></p>

<p> <resolvers></p>

<p> <ibiblio name="public-repo" m2compatible="true" /></p>

<p> <chain name=" chain-repo " returnFirst="true" checkmodified="true"></p>

<p> <sftp name="chain-release"></p>

<p> <artifact pattern=" ${release.repo.dir}/[organisation]/[module]/[type]s/[artifact]-[revision].[ext] " /></p>

<p> <ivy pattern=" ${release.repo.dir}/[organisation]/[module]/[type]s/[artifact]-[revision].xml " /></p>

<p> </sftp></p>

<p> <sftp name="..." checkmodified="true"></p>

<p> <artifact pattern="..." /></p>

<p> <ivy pattern="..." /></p>

<p> </sftp></p>

<p> </chain></p>

<p> </resolvers></p>

<p> </ivysettings></p>

<p>采用这种方式，可以解决以下几种复杂情况。
 一个模块发布多个产品
 例如模块MB发布了一个制作报表工具，这个工具有一套统一的API，只要调用这套API就能制作出各种各样的报表，包含API和XP风格报表实现的产品名为AB_XP（需要第三方包DEP_XP才能运行），包含API和苹果风格报表的产品名为AB_APPLE （需要第三方包DEP_APPLE才能运行），MB的ivy文件应为（这里DEP_XP和DEP_APPLE分别定义在mod_xp和mod_apple的default配置中）：</p>

<p> &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?></p>

<p> <ivy-module version="2.0" ></p>

<p> <info organisation="OB" module="MB" revision="1.0" status="release" publication="20101121175043"/></p>

<p> <configurations></p>

<p> <conf name="CB_XP" visibility="public" description="..."/></p>

<p> <conf name="CB_APPLE" visibility="public" description="..."/>
 </configurations></p>

<p> <publications></p>

<p> <artifact name="AB_XP" type="jar" ext="jar" conf="CB_XP"/></p>

<p> <artifact name="AB_APPLE" type="jar" ext="jar" conf="CB_APPLE"/></p>

<p> </publications></p>

<p> <dependencies></p>

<p> <dependency org="org_1" name="mod_xp" rev="1.0" conf="CB_XP->default&#8221;/></p>

<p> <dependency org="org_2" name="mod_apple" rev="1.0" conf="CB_APPLE->default&#8221;/></p>

<p> </dependencies>
 </ivy-module>
模块MA是一个自动测试工具，测试完成后需要用模块MB提供的工具生成测试结果报告，MA发布两个产品：AA_XP（生成XP风格报表，需引用AB_XP）和AA_APPLE（生成苹果格式的报表，需引用AB_APPLE），则MA的ivy文件应为：</p>

<p> &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?></p>

<p> <ivy-module version="2.0" ></p>

<p> <info organisation="OA" module="MA" revision="1.0" status="release" publication="20101121175043"/></p>

<p> <configurations></p>

<p> <conf name="CA_XP" visibility="public" description="..."/></p>

<p> <conf name="CA_APPLE" visibility="public" description="..."/></p>

<p> </configurations></p>

<p> <publications></p>

<p> <artifact name="AA_XP" type="jar" ext="jar" conf="CA_XP"/></p>

<p> <artifact name="AA_APPLE" type="jar" ext="jar" conf="CA_APPLE"/></p>

<p> </publications></p>

<p> <dependencies></p>

<p> <dependency org="OB" name="MB" rev="1.0" conf="CA_XP->CB_XP&#8221; transitive=&ldquo;true&rdquo;/></p>

<p> <dependency org="OB" name="MB" rev="1.0" conf="CA_APPLE->CB_APPLE&#8221; transitive=&ldquo;true&rdquo;/></p>

<p> </dependencies></p>

<p> </ivy-module></p>

<p>这样模块MA中的ivy进行解析（resolve）的时候，不仅会引用产品AB_XP和AB_APPLE，也会引用DEP_XP和DEP_APPLE，如果将上面<dependency>里的transitive=&ldquo;true&#8221;改为transitive=&#8221;false&#8221;，则只引用AB_XP和AB_APPLE，不引用DEP_XP和DEP_APPLE。
 产品的部分依赖
假设模块MB的产品AB的功能很多，实现所有功能所依赖的第三方包有50个（dep_1~dep_50），模块MA的产品AA只需要使用AB的一个功能，而这个功能只需要dep_15一个三方包，这时如果采用transitive=&#8221;true&#8221;方式引用AB，则会把所有50个三方包都引入到AB的lib中，体积会很大，用配置就可以在AB中为AA专门定制一个conf，使transitive=&#8221;true&#8221;方式下AA只取AB和dep_15，AB的ivy.xml如下：</p>

<p> &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?></p>

<p> <ivy-module version="2.0" ></p>

<p> <info organisation="OB" module="MB" revision="1.0" status="release" publication="20101121175043"/></p>

<p> <configurations></p>

<p> <conf name="AA_runtime" visibility="public" description="only for AA"/></p>

<p> <conf name="default" visibility="public" description="..."/></p>

<p> </configurations></p>

<p> <publications></p>

<p> <artifact name="AB_XP" type="jar" ext="jar" conf="AA_runtime"/></p>

<p> </publications></p>

<p> <dependencies></p>

<p> <dependency org="org_1" name="mod_1" rev="1.0" conf="default->default&#8221;/></p>

<p> &hellip;&hellip;</p>

<p> <dependency org="org_15" name="mod_15" rev="1.0" conf="default,AA_runtime->default&#8221;/></p>

<p> &hellip;&hellip;</p>

<p> <dependency org="org_50" name="mod_50" rev="1.0" conf="default->default&#8221;/></p>

<p> </dependencies></p>

<p> </ivy-module></p>

<p>另外一种解决方法是把dep_15手工加到MA的依赖中，这时可为MB建立一个&#8221;Nontransitive&#8221;配置（习惯上称为master）：仅在<publications>里出现，而不出现在<dependencies>中，实例可参见很多Maven库里第三方包的ivy.xml文件。这样master配置不包含任何依赖，即使写MA的依赖时注明transitive=&ldquo;true&#8221;，也引不到任何MB的依赖包。</p>

<p>使用这种master配置要注意的是：在<dependencies>中所有条目都不能省略conf=&ldquo;&hellip;&#8221;。当MB的被依赖项目之一dep_x只有jar包没有ivy配置时，如果省略conf部分，则该依赖对所有配置生效（包括master），这时MB的master就不完全是&#8221;Nontransitive&#8221;了，而是包括省略conf的条目（dep_x），如果MA依赖MB的master，就会把dep_x也引过来，解决办法就是在MB的<dependencies>的dep_x条目中标明：conf=&#8221;compile-><em>&#8220;（其中compile是用于MB自己编译的配置）。
 依赖配置的通配和后备机制
在依赖配置中，如果被依赖的项目只有jar包，没有ivy配置，或者不清楚被依赖项目的配置情况，可用星号（“</em>”）表示任何配置，例如：conf=&#8221;compile->*&#8221;；</p>

<p>如果被依赖项目可能有master配置，可用后备配置：conf=&ldquo;compile->master(*)&#8221;，即当master配置不存在时，使用任何配置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eclipse编辑器配色的配置文件]]></title>
    <link href="http://leetschau.github.io/blog/2010/11/24/114443/"/>
    <updated>2010-11-24T11:44:43+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/11/24/114443</id>
    <content type="html"><![CDATA[<p>基本编辑器配色：${workspace}.metadata.plugins\org.eclipse.core.runtime.settings\org.eclipse.ui.editors.prefs Java语法配色：${workspace}.metadata.plugins\org.eclipse.core.runtime.settings\org.eclipse.jdt.ui.prefs XML语法配色：${workspace}.metadata.plugins\org.eclipse.core.runtime.settings\org.eclipse.wst.xml.ui.prefs Python语法配色（仅在安装了Pydev插件后有效）：${workspace}.metadata.plugins\org.eclipse.core.runtime.settings\org.python.pydev.prefs
手工配好编辑器颜色后（参见博文“手工设置Eclipse文本编辑器的配色”），将以上文件保存起来，对于一个新的Workspace，用以上文件覆盖自动生成的文件即可。</p>
]]></content>
  </entry>
  
</feed>
