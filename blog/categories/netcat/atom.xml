<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Netcat | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/netcat/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-11-28T08:48:37+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Start a Service and Wait Until It's Up]]></title>
    <link href="http://leetschau.github.io/blog/2014/03/03/145805/"/>
    <updated>2014-03-03T14:58:05+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/03/03/145805</id>
    <content type="html"><![CDATA[<p>In this case the GcpServer is a background service. If the port 5556 is listening, that means the service start successfully.</p>

<pre><code>chmod 755 GcpServerCore/cmd/*.sh
cd GcpServerCore/cmd;./start.sh;cd -
while ! nc -zv localhost 5556; do sleep 5; done
</code></pre>

<p>This solution based on the netcat utility.</p>

<p>Ref: <a href="http://snipplr.com/view/43113/">bash: how to start a service and wait until it&rsquo;s up</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Run Interactive Shell Command in Erlang]]></title>
    <link href="http://leetschau.github.io/blog/2013/08/14/160009/"/>
    <updated>2013-08-14T16:00:09+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/08/14/160009</id>
    <content type="html"><![CDATA[<p>The following simple Erlang netcat client demonstrates the communication between Erlang program and external OS process. The rc.erl start a netcat client to connect to a netcat server, and send some message to the server at a given time.</p>

<ol>
<li><p>Create Erlang server;</p>

<p> -module(rc).
 -export([cmd/1]).
 cmd(Cmd) ->
     Opt = [stream, exit_status, stderr_to_stdout, eof],
     P = open_port({spawn, Cmd}, Opt),
     get_data(P, [], 0).
 get_data(P, Sofar, 3) ->
     port_command(P, &ldquo;abcd&rdquo;),
     get_data(P, Sofar, 4);
 get_data(P, Sofar, Cnt) ->
     receive
         {P, {data, Bin}} ->
             io:format(&ldquo;rec Bin: ~p, Cnt=~p~n&rdquo;, [Bin, Cnt]),
             get_data(P, [Bin|Sofar], Cnt+1);
         {P, eof} ->
             port_close(P),
             receive
                 {P, {exit_status, N}} ->
                     {N, lists:reverse(Sofar)}
             end
     end.</p></li>
<li><p>Start netcat server: run command <code>nc -l 3333</code> at host 10.21.3.31;</p></li>
<li><p>Start netcat client:</p>

<p> $ erl
 &hellip;</p>

<p> 1> c(rc).</p>

<p> {ok,rc}
 2> rc:cmd(&ldquo;nc 10.21.3.31 3333&rdquo;).</p></li>
<li><p>Send message from server to client: press &ldquo;1<CR>2<CR>3<CR>4<CR>^C&rdquo;, client output as follows:</p>

<p> rec Bin: &ldquo;1\n&rdquo;, Cnt=0
 rec Bin: &ldquo;2\n&rdquo;, Cnt=1
 rec Bin: &ldquo;3\n&rdquo;, Cnt=2
 rec Bin: &ldquo;4\n&rdquo;, Cnt=4
 {0,[&ldquo;1\n&rdquo;,&ldquo;2\n&rdquo;,&ldquo;3\n&rdquo;,&ldquo;4\n&rdquo;]}
 3></p></li>
</ol>


<p>When you press <CR> after 3, you can receive &ldquo;abcd&rdquo; from netcat client.</p>

<p>The pattern of Erlang-Shell communication is:</p>

<ul>
<li><p>Use &ldquo;open_port&rdquo; to start a external shell process;</p></li>
<li><p>Use &ldquo;receive&rdquo; clause to receive output of the process;</p></li>
<li><p>Use &ldquo;port_command&rdquo; to send message to process;</p></li>
<li><p>Use &ldquo;port_close&rdquo; to close the shell;</p></li>
</ul>


<p>Notes:</p>

<ol>
<li><p>For non-interactive shell command, os:cmd/1 is a better choice;</p></li>
<li><p>If you want to catch the event that the peer close actively, add &ldquo;eof&rdquo; into option list of open_port; If you want to catch the exit value of the shell process, add &ldquo;exit_status&rdquo; to option list of open_port;</p></li>
<li><p>Not specify &ldquo;in&rdquo; in option list of open_port when you want to send the process some message, or a &ldquo;ebadf&rdquo; exception arises, because &ldquo;in&rdquo; means this process only used for input, and &ldquo;ebadf&rdquo; means the file is not open for reading or writing.</p></li>
<li><p><a href="http://www.cnblogs.com/gibbon/archive/2012/12/26/Erlang.html">Erlang port communicate with python</a> is a good demonstration of erlang calling a python script; Chapter 12 of &ldquo;Programming Erlang&rdquo; also concentrate Erlang interfacing techniques.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[局域网文本传输软件]]></title>
    <link href="http://leetschau.github.io/blog/2013/05/06/170059/"/>
    <updated>2013-05-06T17:00:59+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/05/06/170059</id>
    <content type="html"><![CDATA[<p>有时候两台机器间临时需要传输一些简单的文本，比如网页地址，指令之类的，专门找一个网内聊天软件太麻烦，简单的方法是使用命令行工具，下面是可选的工具。</p>

<h1>利用write或者wall命令</h1>

<p>Linux的内部指令，无需安装，但Windows上没法用。</p>

<p>write适用于多次双向交互（两个人之间聊天的交互方式），格式：write <username> [tty]，其中username是用户名，tty通过运行&#8221;tty&#8221;指令获得，在只有两个用户登录情况下可以省略。当主机A和B需要交互时，B首先SSH登录A（ssh my_name@hostB，据说telnet也行），然后B上运行&#8221;write my_name&#8221;，就进入了聊天状态。</p>

<p>wall是向所有tty广播，例如主机A要向B和C发送消息，需要B和C登录到A上（SSH），然后在A上运行wall，可以加回车写多行文本，写完后输入Ctrl+D，整段文本就被广播到了B和C在A的tty上，可以通过管道向wall输送指令，例如&#8221;cat file_name|wall&#8221;将文件内容广播给其他终端，或者&#8221;df|wall&#8221;将磁盘情况广播给其他终端。</p>

<p>wall和write的主要区别是wall是单向的，write是双向的。</p>

<h1>利用netcat指令</h1>

<p>netcat需要安装，Ubuntu上比较简单：apt-get install netcat，Windows上复杂些，需要下载nc111nt.zip这个文件，下载后报有病毒，但好像是误报。</p>

<p>netcat的信息传输是Server-Client方式，启动Server的方法是&#8221;nc -l server_port&#8221;，server_port可以是任意没被占用的端口，例如nc -l 3456，启动Client的方法是&#8221;nc server_ip server_port&#8221;（例如nc 10.31.2.34 3456），之后不论哪一方输入文本回车后都会被发送到对端，可以先由发送端发送报文，再启动接收端。</p>

<p>要传多行文本（比如一个文本文件），可以用下面的方法：</p>

<p>发送端：cat some.txt|nc -l 3333</p>

<p>接收端：nc 10.21.3.31 3333 > some.txt</p>

<p>可以在Executor里定义一个任务，命令是&#8221;d:\Apps\ConEmu\ConEmu.exe&#8221;，参数是&#8221;d:\Apps\netcat\nc.exe&#8221;，启动nc之后再输入目标的ip地址和端口号。</p>
]]></content>
  </entry>
  
</feed>
