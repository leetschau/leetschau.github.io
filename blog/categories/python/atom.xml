<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-11-11T14:51:43+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Build Data Analysis Toolkit With Anaconda]]></title>
    <link href="http://leetschau.github.io/blog/2016/06/15/190457/"/>
    <updated>2016-06-15T19:04:57+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/06/15/190457</id>
    <content type="html"><![CDATA[<h1>Setup</h1>

<p>Download Anaconda installer (Anaconda3-4.0.0-Linux-x86_64.sh) and install it
to folder ~/apps/anaconda3 (to uninstall, just remove this folder).</p>

<p>Add the following line into ~/.zshenv:</p>

<pre><code>ANACONDA_HOME=$HOME/apps/anaconda3
</code></pre>

<p>Enable Anaconda working environment with
<code>source ~/apps/anaconda3/bin/activate $ANACONDA_HOME</code>.
Leave this environment with <code>source deactivate</code>.</p>

<p>List all environments with <code>conda env list</code>.
If there is a &lsquo;root&rsquo; in the output, you can activate Anaconda as a common
conda env with <code>source activate root</code>.</p>

<p>Create a new Python 2.7 virtual environment with
<code>conda create -n py27 python=2.7</code>, make it the current environment with
<code>source activate py27</code>. You can use this command to switching between any
conda-managed environment without worrying about nested-virtualenv.</p>

<p>If you met an &ldquo;no such file or directory: activate&rdquo; error
when running <code>source activate ...</code>, use the full path
<code>~/apps/anaconda3/bin/activate</code> instead of <code>activate</code>.</p>

<p>Anaconda contains many important Python dev tools, including pip, ipython,
conda (which can be used as a replacement for pip and virtualenv).
If you want use it as the primary Python environment, add <code>$ANACONDA_HOME</code>
before the existing <code>$PATH</code>.</p>

<p>But Anaconda has no Python 2.x, so at least on Ubuntu 14.04
this is not the recommended way.
On Ubuntu 16.04, there is no Python 2.x by default, so use Python 3.5 and pip
in Anaconda3 is practical.</p>

<p>Do not add <code>$ANACONDA_HOME</code> after the <code>$PATH</code>, which will expose some binary
like <code>conda, jupyter</code>, while the other (like python and pip) will be covered
by system equivalent. This will lead inconsistent behavior and failure of
<code>conda</code> and <code>jupyter</code>.</p>

<p>Ref:</p>

<p><a href="http://www.ericmajinglong.com/2014/09/23/5-great-things-about-the-anaconda-distribution/">http://www.ericmajinglong.com/2014/09/23/5-great-things-about-the-anaconda-distribution/</a></p>

<h1>Notebook</h1>

<p>Start jupyter notebook server with <code>jupyter notebook</code>.
It creates a new window in existing browser session with url
&ldquo;<a href="http://localhost:8888/tree">http://localhost:8888/tree</a>&rdquo;.</p>

<p>Click [New -> Python3] at the right side of the page to create a new notebook
session. In the new page, use [File -> Rename] to give it a name.</p>

<p>When you click any of the notebook file <code>*.ipynb</code> (here is chap01ex.ipynb)
in browser, it will be opened in a new tab with url
&ldquo;<a href="http://localhost:8888/notebooks/chap01ex.ipynb">http://localhost:8888/notebooks/chap01ex.ipynb</a>&rdquo;.</p>

<p>Jupyter notebook support all vi-style key shortcuts, which conflicts with
Chrome plugin Vimium. So click the Vimium icon at the right side of the address
bar, and add a rule:</p>

<pre><code>Patterns: https?://localhost:8888/notebooks/*
</code></pre>

<p>Leave the &ldquo;Keys&rdquo; textbox blank, which means disable all keys of Vimium
under this pattern.</p>

<p>For Firefox, in [Tools -> Add-ons -> Extensions -> VimFx -> Blacklist], add
<code>http://localhost:8888/*</code> to disable VimFx key shortcuts on Jupyter web page.</p>

<p>Now you can use jupyter key shortcuts freely.
Use <code>h</code> key list all available shortcuts.
Note that shortcuts listed there are all capital letter,
while actually you should use the corresponding small letter.</p>

<p>Use <code>j</code>/<code>k</code> to select active cell, <Enter> to edit it, <code>c</code> to copy,
<code>v</code> to paste, <code>x</code> to delete it.</p>

<p>Use <code>m</code> to make text in a cell as markdown text, <code>y</code> to code.</p>

<p>For markdown cell, use <Enter> to edit it, use Ctrl-Enter to run it
(turn text from edit mode to markdown preview mode).</p>

<p>Use Alt-Enter to evaluate the current cell and insert a blank cell below.</p>

<p>Use <code>s</code> to save current notebook and setup a &ldquo;checkpoint&rdquo;,
use [File -> Revert to Checkpoint] to discard all changes after that checkpoint.</p>

<p>Use <code>o</code> to toggle output of the current cell,
<code>Shift-o</code> to toggle output scrolling.</p>

<p>Use [File -> Download as -> Python(.py)] to create a runnable Python script
from the current jupyter notebook.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Format Python Code With Autopep8]]></title>
    <link href="http://leetschau.github.io/blog/2016/06/08/191617/"/>
    <updated>2016-06-08T19:16:17+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/06/08/191617</id>
    <content type="html"><![CDATA[<p>Install: <code>pip install --user autopep8</code></p>

<p>Preview: <code>autopep8 -d &lt;target_file&gt;.py</code></p>

<p>Modify: <code>autopep8 -i &lt;target_file&gt;.py</code></p>

<p>More help: <code>autopep8 -h</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[增强版Python REPL]]></title>
    <link href="http://leetschau.github.io/blog/2016/06/05/081046/"/>
    <updated>2016-06-05T08:10:46+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/06/05/081046</id>
    <content type="html"><![CDATA[<h1>bpython</h1>

<ul>
<li><p>语法高亮；</p></li>
<li><p>参数列表提示；</p></li>
<li><p>方便地查看和修改配置文件；</p></li>
<li><p>同时支持Python 2.x和3.x；</p></li>
<li><p>方便地在editor和repl间切换；</p></li>
<li><p>rewind功能方便地在repl里编写多行代码：
在代码块里用快捷键Ctrl-R取消本行，以及之前输入的行</p></li>
<li><p>方便地保存repl中脚本到文件中；</p></li>
<li><p>F1列出所有快捷键</p></li>
</ul>


<h2>Ubuntu 14.04 Unity上的配置</h2>

<p>bpython保存文件的默认快捷键是Ctrl-S，为了解决Ubuntu 14.04 Unity, Tmux环境中，
执行Ctrl-S时出现挂死问题，启动bpython后，F3进入配置文件编辑窗口，将<code>save</code>的值改为F4:</p>

<pre><code>save = F4
</code></pre>

<p>为了解决默认F1启动Gnome terminal帮助，而不是bpython帮助问题，在Terminal菜单
[Edit -> Keyboard Shortcuts -> Contents -> Help]的快捷键用退格键变为"Disabled".
如果还不行，在Unity系统的
[System Settings -> Keyboard -> Shortcuts Launchers -> Launch help browser]的
快捷键也Disable掉。</p>

<h2>For Python3</h2>

<p>Install with <code>sudo pip3 install bpython</code>, start with <code>python3 -m bpython.cli</code>.</p>

<p>另外<a href="https://github.com/jonathanslenders/ptpython">ptpython</a>，功能与bpython类似，
但没有函数的参数列表提示。</p>

<p>IPython notebook也能实现类似的功能，但似乎比较重。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用flake8做Python Linter]]></title>
    <link href="http://leetschau.github.io/blog/2016/05/24/204911/"/>
    <updated>2016-05-24T20:49:11+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/05/24/204911</id>
    <content type="html"><![CDATA[<p>今天写Python脚本时遇到一个问题，重构代码时，修改了一个变量名，
但只改了正常分支中的，忘了改错误处理分支中的，由于没有Linter做未定义变量检查，
bug在本机测试时并没有被发现，直到被push到remote repo，
在Jenkins job里运行几次出错后才被发现。
解决方案是安装flake8以及vim插件。</p>

<p>For Python 2.x: <code>pip install flake8</code>，
vim的syntastic插件不需要配置。</p>

<p>For Python 3.x，首先要安装flake8 for Python 3.x:</p>

<pre><code>sudo apt-get install python3-pip
sudo pip3 install flake8
</code></pre>

<p>命令行中检查文件命令：<code>python3 -m pyflakes syncRecurrences.py</code>.</p>

<p>配置vim语法检查的方法是在.vimrc文件里增加一下配置项：</p>

<pre><code>let g:syntastic_python_python_exec = '/usr/bin/python3'
let g:syntastic_python_flake8_exec = 'python3'
let g:syntastic_python_flake8_args = ['-m', 'flake8']
</code></pre>

<p>配置好后用vim打开python脚本，保存文件后，在未声明的变量行上会出现下面的错误信息：</p>

<pre><code>undefined name 'objId' [F821]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Flask的Python微服务]]></title>
    <link href="http://leetschau.github.io/blog/2016/04/29/104211/"/>
    <updated>2016-04-29T10:42:11+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/04/29/104211</id>
    <content type="html"><![CDATA[<h1>收发JSON报文</h1>

<p>下面基于Flask实现了最简单的JSON报文收发功能，收到请求后打印出内容，
重新组织后返回给客户端。
使用Flask的request.get_json()接收HTTP POST中的JSON报文，
使用json.dumps()发送JSON报文：</p>

<p>创建并启动服务：
```
cat &lt;&lt; EOF > server.py
from flask import Flask, request
import json</p>

<p>app = Flask(<strong>name</strong>)</p>

<p>@app.route(&lsquo;/api/<user>/<uuid>&rsquo;, methods=[&lsquo;GET&rsquo;, &lsquo;POST&rsquo;])
def add_message(user, uuid):
  content = request.get_json()
  print(content)
  return json.dumps({&ldquo;user&rdquo;: user, &ldquo;uuid&rdquo;: uuid})</p>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:
  app.run(host= &lsquo;0.0.0.0&rsquo;, port=3000, debug=True)
EOF</p>

<p>python server.py
```</p>

<p>用httpie和jq测试：
<code>http POST localhost:3000/api/chad/097aa543 head:='{"a1":"bb","c3":"dd"}' body=theBody | jq '.user'</code></p>

<h1>一个简单的Python微服务实现</h1>

<p>下面这个服务接收HTTP请求发送来的shell脚本，执行之，并根据用户需求返回控制台输出。
为了保证服务器的安全，生产环境中的这类服务需要校验客户端身份，
并为传入的命令设置白名单。</p>

<p>服务器接收的url包括mode和uuid两个字段，mode分exec和poll两种情况，
前者要求服务器开始执行Post body中的指令，后者查看当前运行指令的控制台输出。
uuid可以用于验证客户端合法性，例如客户端以"调用者+时间戳"并加密后生成uuid，
服务器验证调用者和时间戳的有效性。</p>

<p>服务端的配置项包括服务监听的端口以及返回控制台输出的行数。</p>

<p>创建并启动服务：
```
cat &lt;&lt; EOF > server.py
from flask import Flask, request
import json
from subprocess import Popen, PIPE
from threading import Thread
from queue import Queue</p>

<p>PORT = 3000
CMD_LINE_NUM = 3</p>

<p>app = Flask(<strong>name</strong>)
output_q = Queue(CMD_LINE_NUM)
cmd_q = []</p>

<p>def save_newest_output(p, queue, cmds):
    while p.poll() is None:
        line = p.stdout.readline().decode().strip()  # blocking read
        if queue.full():
            queue.get()   # abandon old output silently
        queue.put(line)
    cmds.clear()</p>

<p>@app.route(&lsquo;/api/<mode>/<uuid>&rsquo;, methods=[&lsquo;GET&rsquo;, &lsquo;POST&rsquo;])
def run_cmd(mode, uuid):
    if mode == &lsquo;exec&rsquo;:
        if len(cmd_q) > 0:
            return json.dumps({&ldquo;mode&rdquo;: mode, &ldquo;status&rdquo;: &ldquo;busy&rdquo;})
        cmd = request.get_json()[&lsquo;cmd&rsquo;]
        proc = Popen(cmd, shell=True, stdout=PIPE)
        cmd_q.append(proc)
        t = Thread(target=save_newest_output, args=(proc, output_q, cmd_q))
        t.daemon = True
        t.start()
        return json.dumps({&ldquo;mode&rdquo;: mode, &ldquo;status&rdquo;: &ldquo;accepted&rdquo;})
    if mode == &lsquo;poll&rsquo; and len(cmd_q) > 0:
        lines = []
        while not output_q.empty():
            line = output_q.get_nowait()
            lines.append(line)
        return json.dumps({&ldquo;mode&rdquo;: mode,
                           &ldquo;status&rdquo;: &ldquo;running&rdquo;,
                           &ldquo;output&rdquo;: &lsquo;\n&rsquo;.join(lines)
                           })
    return json.dumps({&ldquo;mode&rdquo;: mode, &ldquo;status&rdquo;: &ldquo;finished&rdquo;})</p>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:
    app.run(host=&lsquo;0.0.0.0&rsquo;, port=PORT, debug=True)
EOF
python server.py
```
Shell脚本在一个单独的进程中运行，并由一个独立的Thread读取它的输出，
保证HTTP服务不会被阻塞。</p>

<p>测试客户端：
<code>
cat &lt;&lt; EOF &gt; test.py
from time import sleep
for i in range(28, 49):
    print(i, flush=True)
    sleep(2)
EOF
http POST localhost:3000/api/exec/097aa543 cmd='python3 test.py'    # accepted
http POST localhost:3000/api/exec/097aa543 cmd='python3 test.py'    # busy
http POST localhost:3000/api/poll/097aa543         # realtime output: 30, 31, 32
sleep 10
http POST localhost:3000/api/poll/097aa543         # realtime output: 37, 38, 39
sleep 40
http POST localhost:3000/api/poll/097aa543         # status: finished
http POST localhost:3000/api/exec/097aa543 cmd='python3 test.py'    # accepted
</code></p>

<p>为了保证输出不会被缓存，需要在print函数中增加<code>flush=True</code>，只有Python 3支持，
所以运行测试脚本时需要用<code>python3 test.py</code>.</p>

<p>在Python 3.4.3, Flask 0.10.1上测试通过。</p>

<h1>服务管理</h1>

<p>这里使用<a href="http://supervisord.org/">Supervisor</a>管理Python进程，
相比于Monit, start-stop-daemon等工具，它的优点是不依赖pidfile，配置方便，
提供日志输出，文档写得好。</p>
]]></content>
  </entry>
  
</feed>
