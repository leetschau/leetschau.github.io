<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 同步 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/tong-bu/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-04-18T20:42:59+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Auto Dir Sync Script Based on Total Commander]]></title>
    <link href="http://leetschau.github.io/blog/2012/12/28/143757/"/>
    <updated>2012-12-28T14:37:57+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/12/28/143757</id>
    <content type="html"><![CDATA[<p>The Sync source folder is in e:\mydoc\CalibreLib, destination folder is M:\backup\CalibreLib, where M is the drive letter of an USB disk with label &ldquo;Emacs&rdquo;;</p>

<h1>Giving USB Disk a fixed Drive Letter</h1>

<p>Right click &ldquo;My Compter&rdquo; -> Manage -> Storage -> Disk Management. Right click the USB drive -> Change Drive Letter and Paths, and modify it to M. You can choose any letter between M~Z. A letter before M is not recommended because it could be occupied by virtual drives or CD-ROMs.</p>

<p>Test shows that other USB disk won&rsquo;t use the drive letter &ldquo;M&rdquo;. And this USB disk(&ldquo;Emacs&rdquo;) always use &ldquo;M&rdquo; no matter which USB port it&rsquo;s plugged in;</p>

<h1>Define Sync Configuration in Total Commander</h1>

<ol>
<li><p>Open e:\mydoc\CalibreLib in upper(left) panel in TC, M:\backup\CalibreLib in bottom panel;</p></li>
<li><p>Shift + F12(Commands -> Synchronize Dirs) to show the Sync window of TC;</p></li>
<li><p>Check &ldquo;Asymmetric&rdquo;(because I want a strict mirror of e:\mydoc\CalibreLib, not a copy. see TC doc for detailed explanation) and &ldquo;Subdirs&rdquo;;</p></li>
<li><p>Click the button at the left side of the directory input box and choose &ldquo;add current directories and settings to list&rdquo;. You can verify this by openning file wincmd.ini in TC&rsquo;s installation dir and you can find:</p></li>
</ol>


<p> [SyncOptions]
 BooksLib_L=E:\MyDoc\CalibreLib\
 BooksLib_R=M:\backup\CalibreLib\
 BooksLib_Wcs=<em>.</em>
 BooksLib_Flags=9|61|-9</p>

<p>In &ldquo;Configuration and Switches&rdquo; -> &ldquo;ini file Settings&rdquo; of TC&rsquo;s document file(TOTALCMD.CHM), you can find the explanations about settings above.</p>

<h1>Define a hotkey in AutoHotkey Script</h1>

<p>  #!s:: Run, d:\apps\TotalCmd\TOTALCMD.EXE /S=S:=BooksLib ; Sync Calibre dir to usb disk</p>

<h1>Use this auto sync script</h1>

<ol>
<li><p>Insert USB disk;</p></li>
<li><p>Press Win+Alt+s;</p></li>
<li><p>Sync tool of TC will start comparation automatically;</p></li>
<li><p>When comparation ends, check the result. If it&rsquo;s OK, press Enter to start Synchronize;</p></li>
</ol>


<p>That&rsquo;s it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RMI运行实例]]></title>
    <link href="http://leetschau.github.io/blog/2012/04/25/101848/"/>
    <updated>2012-04-25T10:18:48+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/04/25/101848</id>
    <content type="html"><![CDATA[<p>计算机的远程通信有很多种方法， RPC 的设计目标是让一台主机（客户端）上的程序能够引用另一台主机（服务端）上对象，并运行它的方法，也就是“跨地址空间的进程间通信”， RMI 是RPC的Java语言实现。</p>

<p>本实例包含5个文件：</p>

<p>// ================= Hello.java ====================</p>

<p>package test.rmi;</p>

<p>import java.rmi.Remote;</p>

<p>import java.rmi.RemoteException;</p>

<p>/**</p>

<ul>
<li><p>远程方法调用接口，定义远程调用方法</p></li>
</ul>


<p> */</p>

<p>public interface Hello extends Remote {</p>

<p> String sayHello() throws RemoteException;</p>

<p>}</p>

<p> //=================  HelloServer.java =============================
 package test.rmi;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
/<strong>
 <em><p>服务器端，实现了Hello接口中的方法，用于实现远程调用方法的具体业务逻辑</p>
 </em>/
public class HelloServer extends UnicastRemoteObject implements Hello {
  private static final long serialVersionUID = 1L;
  String name;
  public HelloServer(String s) throws RemoteException {
   super();
   name = s;
  }
  public String sayHello() throws RemoteException {
   return &ldquo;Hello from lc!&rdquo;;
  }
  public static void main(String[] args) {
   /</strong>下面这句话若要加上，则需要进行权限的认证，即增加.policy文件
   * 并且在命令行中使用如下格式
   * java -Djava.security.policy=java.policy test.rmi.HelloServer
   <em>/
   /</em> System.setSecurityManager(new RMISecurityManager()); <em>/
   Registry registry = null;
   try {
    /**启动注册服务器，使用了这个语句就不再需要在命令行环境中
    </em>启动registry服务了
    <em>/
    registry = LocateRegistry.getRegistry();
    /</em> 若没有获得连接，则此句会抛出异常，后面在捕获后进行相关处理 */
    registry.list();
    System.out.println(&ldquo;Register the exist server!&rdquo;); //$NON-NLS-1$
   } catch (RemoteException re) {
    try {
     int port = Integer.parseInt(Configur
        .getString(&ldquo;HelloServer.RegistryServerPort&rdquo;)); //$NON-NLS-1$
     registry = LocateRegistry.createRegistry(port);
     System.out.println(&ldquo;Create Registry Server!&rdquo;); //$NON-NLS-1$
    } catch (Exception e) {
     e.printStackTrace();
    }
   }
   try {
    HelloServer helloServer = new HelloServer(&ldquo;Hello&rdquo;);
    registry.rebind(
       Configur.getString(&ldquo;HelloServer.HelloServerName&rdquo;), helloServer); //$NON-NLS-1$
    System.out.println(&ldquo;HelloServer server start!&rdquo;); //$NON-NLS-1$
   } catch (Exception e) {
    e.printStackTrace();
   }
  }
}</p>

<p>//==================  HelloClient.java ============================
 package test.rmi;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
/<strong>
 * <p>客户端，需要注册服务器并使用jndi</p>
 */
public class HelloClient {
  public static void main(String[] args) {
   /</strong>下面这句话若要加上，则需要进行权限的认证，即增加.policy文件
   * 并且在命令行中使用如下格式
   * java -Djava.security.policy=java.policy test.rmi.HelloServer
   <em>/
   /</em> System.setSecurityManager(new RMISecurityManager()); <em>/
   try {
    /</em> 注册服务器 */
    String hostName = Configur
       .getString(&ldquo;HelloServer.RegistryServerName&rdquo;);
    int port = Integer.parseInt(Configur
       .getString(&ldquo;HelloServer.RegistryServerPort&rdquo;));
    Registry registry = LocateRegistry.getRegistry(hostName, port);
    Hello hello = (Hello) registry.lookup(Configur
       .getString(&ldquo;HelloServer.HelloServerName&rdquo;));
    String message = hello.sayHello();
    System.out.println(message);
   } catch (Exception e) {
    e.printStackTrace();
   }
  }
}</p>

<p>//================= Configur.java =============================
 package test.rmi;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
/<em>*
 * <p>获取系统运行所需要的配置信息，对应的配置文件名称为config.properties</p>
 </em>/
public class Configur {
 private static final String BUNDLE_NAME = &ldquo;test.rmi.config&rdquo;;
 private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle
   .getBundle(BUNDLE_NAME);
 private Configur() {
 }</p>

<p> /<em>*
  * <p>通过key名称获得配置文件的相关信息</p>
  * @param key key名称
  * @return String 配置文件信息
  </em>/
 public static String getString(String key) {
  try {
   return RESOURCE_BUNDLE.getString(key);
  } catch (MissingResourceException e) {
   return &lsquo;!&rsquo; + key + &lsquo;!&rsquo;;
  }
 }
}</p>

<p>//================= config.properties =============================
 HelloServer.RegistryServerPort=1111
HelloServer.HelloServerName=HelloServer
HelloServer.RegistryServerName=10.31.1.71</p>

<p> 源代码目录是e:\MyDoc\JEx\Ex1\src，Eclipse自动生成的class文件在e:\MyDoc\JEx\Ex1\bin（以及包目录）下。 运行方法：</p>

<ol>
<li>E:\MyDoc\JEx\Ex1\bin> rmic test.rmi.HelloServer  （rmic.exe是$JAVA_HOME/bin里的文件）</li>
</ol>


<p> 生成e:\MyDoc\JEx\Ex1\bin\test\rmi\HelloServer_Stub.class文件（没有生成skeleton文件）</p>

<ol>
<li>E:\MyDoc\JEx\Ex1\bin> java test.rmi.HelloServer</li>
</ol>


<p> Create Registry Server!
 HelloServer server start!</p>

<ol>
<li><p>关闭本机的Windows防火墙；</p></li>
<li><p>copy HelloClient.class, HelloServer_Stub.class, Hello.class, Configur.class, config.properties到另一台机器，运行 java test.rmi.HelloClient ，返回&#8221;Hello from lc!&ldquo;。</p></li>
</ol>


<p>要运行Server只需要Hello.class, HelloServer.class, Configur.class, config.properties 4个文件，HelloServer_Stub.class只在客户端需要。</p>

<p>可以看到客户端新建了一个Hello类型的对象，然后调用了这个对象的方法sayHello，而这个对象和方法的定义在另一台主机上。</p>

<p>RMI是一种同步调用方式，也就是说代码运行到&#8221;String message = hello.sayHello()&ldquo;是会阻塞（block），直到服务端返回sayHello的结果，与此相对， JMS 是异步发送消息，客户端发送完消息后不等待结果返回，运行后面的代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文件夹同步软件比较]]></title>
    <link href="http://leetschau.github.io/blog/2011/10/07/141255/"/>
    <updated>2011-10-07T14:12:55+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/10/07/141255</id>
    <content type="html"><![CDATA[<p>比较软件列表
 Toucan: GNU/GPL, 绿色；</p>

<p> Allway Sync免费版: ASF；</p>

<p>GoodSync: GS, proprietary ware;</p>

<p> TotalCommander: TC, proprietary ware;</p>

<p>Microsoft SyncToy: ST;</p>

<p>Super Flexible File Synchronizer Pro v5.54a: SFFS，proprietary ware;</p>

<p> SyncBackPro: proprietary ware, SBP;</p>

<p>Areca: 开源，绿色，适用于“备份”，不适用于“同步”，因为Areca中的“Repository&#8221;相当于同步目标位置，Source相当于同步源，但它会在Repo里自动加一个全数字组成的子目录，它的强大之处是可以像SVN一样记录每次备份的历史，为备份加密，备份前后可以执行脚本；</p>

<p>Free File Sync: 开源，绿色，有多种同步模式，但好像不支持智能盘符； 过滤器
同步软件的过滤器最好具有复杂逻辑判断能力，例如：将文件夹A备份到文件夹B，去除其中>500MB的文件，但其中FA, FB除外（也就是说FA,FB仍然要备份）。</p>

<p>以下是各软件的过滤器比较：</p>

<p>Toucan：可以用&#8221;Rules&#8221;定义；</p>

<p>ASF: 有文件大小定义，但试用后达不到预期目标；</p>

<p>GS: 没有文件大小定义，只有文件名定义；</p>

<p>TC: 没有过滤器功能；</p>

<p>SBP: 似乎有，但似乎很复杂；</p>

<p>SFFS: 过滤器功能很强大，包括Include/Exclude列表、尺寸大小、时间戳等多种方式过滤；</p>

<p> 任务导出/导入
如果没有复杂逻辑筛选功能，但具备任务的导入/导出功能，那么仍然可以满足前面提到的复杂备份要求，办法是手工定义文件排除列表，然后导出任务，这样系统或者软件重装后只要导入先前定义好的任务列表即可。</p>

<p>目前试用的有：</p>

<p>GS: 手工生成排除列表的功能比较直观好用，也具备导入/导出任务功能；</p>

<p>ASF, SFFS也具备导入/导出任务功能；
 智能盘符
GS不具备；</p>

<p>ASF具备；</p>

<p>SFFS可以在路径名中直接写盘符，例如：U52:\Backup\PersonalFinance</p>

<p>还可以勾选如下选项：Edit Profile->Advanced Settings->Job->Right-hand volume must be:&hellip;</p>

<p> 同步记录文件夹
很多同步软件会在同步目标文件夹下生成一些特殊的文件夹，例如GoodSync会生成gs_data文件夹，ASF生成_SYNCAPP文件夹，ST在源和目标文件夹下都生成一个SyncToy*.dat文件，很不好，这方面Toucan和SFFS做的比较好，不生成任何额外的文件夹。
 总结
Toucan是一款全功能（同步、备份、加密）软件，能过滤，能自己写脚本，支持在命令行下运行，不在文件夹下新建记录文件（夹），无需安装，推荐。使用方法详见&#8221;Settings->Help&#8221;，备份Calibre书库用Sync->Mirror方法备份，这种模式下即使目标比源新时也用源覆盖目标，保证绝对的单向备份。</p>
]]></content>
  </entry>
  
</feed>
