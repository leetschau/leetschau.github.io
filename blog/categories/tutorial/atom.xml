<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tutorial | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/tutorial/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-02-21T11:06:40+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Notes of Learn You a Haskell for Great Good]]></title>
    <link href="http://leetschau.github.io/blog/2015/10/01/202107/"/>
    <updated>2015-10-01T20:21:07+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/10/01/202107</id>
    <content type="html"><![CDATA[<p>Notes for <a href="http://learnyouahaskell.com/">Learn You a Haskell for Great Good</a>.</p>

<h1>Modules</h1>

<p>The following code snippet demonstrate how to import and use Haskell submodule.
Save the following codes into a shell script and run it.</p>

<pre><code>#!/bin/bash
mkdir Geometry
cat &lt;&lt; EOF &gt; Geometry/Sphere.hs
module Geometry.Sphere
( volume
, area
) where

volume :: Float -&gt; Float
volume radius = (4.0 / 3.0) * pi * (radius ^ 3)

area :: Float -&gt; Float
area radius = 4 * pi * (radius ^ 2)
EOF

cat &lt;&lt; EOF &gt; app.hs
import Geometry.Sphere
main = print $ volume 3
EOF

runghc app.hs
</code></pre>

<p>The result should be &ldquo;113.097336&rdquo;.</p>

<h1>Making Our Own Types and Typeclasses</h1>

<p>Value constructor is also called &ldquo;data constructor&rdquo;.</p>

<p>Ref:</p>

<p><a href="https://wiki.haskell.org/Constructor">Constructor</a></p>

<p><a href="http://stackoverflow.com/questions/18204308/haskell-type-vs-data-constructor">Haskell Type vs Data Constructor</a></p>

<h1>Applicative Functors</h1>

<p>下面的代码，转换<code>[1,2,3,4]</code>时，可以用<code>map</code>代替<code>fmap</code>，转换<code>Just 4</code>就不行：</p>

<pre><code>Prelude&gt; fmap (replicate 3) [1,2,3,4]
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]

Prelude&gt; map (replicate 3) [1,2,3,4]
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]

Prelude&gt; fmap (replicate 3) (Just 4)
Just [4,4,4]

Prelude&gt; map (replicate 3) (Just 4)
&lt;interactive&gt;:45:20:
    Couldn't match expected type ‘[a]’ with actual type ‘Maybe Integer’
    Relevant bindings include it :: [[a]] (bound at &lt;interactive&gt;:45:1)
    In the second argument of ‘map’, namely ‘(Just 4)’
    In the expression: map (replicate 3) (Just 4)
</code></pre>

<p>map是一个函数，通过一个将a类型变为b类型的函数，
将元素类型为a类型的数组转换为元素类型为b的数组；</p>

<pre><code>Prelude&gt; :t map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>

<p>fmap是一个函数，通过一个将a类型变为b类型的函数，
将一个类型为"f a"的值，变为一个类型为"f b"的值。</p>

<pre><code>Prelude&gt; :t fmap
fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p><code>Maybe</code>是一个实现了(instance)函子(Functor)类型类(class)的类型构造器(type constructor)。
类型构造器类似于Java的泛型，例如“数组” <code>[]</code>就是类型构造器，
“元素为整数的数组” <code>[Int]</code>是一个具体类型，这里的整型 Int就充当了数组类型构造器的参数，
用函数做类比，数组是个“类型函数”，参数是具体类型 Int，返回具体类型 [Int]。</p>

<pre><code>Prelude&gt; :k []
[] :: * -&gt; *
</code></pre>

<p>这里<code>:k</code>表示取数组的kind值，kind可以理解为是类型构造器的类型。
<code>*</code>表示某个具体类型（而不是类型构造器）。</p>

<p><code>Just</code>是一个函数，将a类型值转换为<code>Maybe a</code>类型值，
例如<code>Just 4</code>将Int类型值 (4)，转换为<code>Maybe Int</code>，
或者更准确地表述为：将Num类型值转为<code>Num a =&gt; Maybe a</code>类型。</p>

<pre><code>Prelude&gt; :k Maybe
Maybe :: * -&gt; *
Prelude&gt; :t Just
Just :: a -&gt; Maybe a
Prelude&gt; :t Just 4
Just 4 :: Num a =&gt; Maybe a
</code></pre>

<p>由于<code>Just 4</code>的类型<code>Maybe Integer</code>不符合<code>map</code>第二个参数类型<code>[a]</code>的要求，所以报错。</p>

<pre><code>Prelude&gt; :t replicate 3
replicate 3 :: a -&gt; [a]
Prelude&gt; :t fmap (replicate 3) (Just 4)
fmap (replicate 3) (Just 4) :: Num a =&gt; Maybe [a]
</code></pre>

<p>在上面的计算过程中，<code>(replicate 3)</code>是<code>fmap</code>的第一个参数<code>(a -&gt; b)</code>，
这里由于<code>(replicate 3)</code>类型是<code>(a -&gt; [a])</code>，所以<code>b</code>就是<code>[a]</code>。
<code>(Just 4)</code>是第二个参数<code>f a</code>，代入<code>Just 4</code>的类型<code>Maybe a</code>，
可知<code>Functor f</code>就是<code>Maybe</code>.
所以最终<code>f b</code>就是<code>Maybe [a]</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git初体验]]></title>
    <link href="http://leetschau.github.io/blog/2015/05/10/091733/"/>
    <updated>2015-05-10T09:17:33+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/05/10/091733</id>
    <content type="html"><![CDATA[<p>本文是毛豆网微课程"Git初体验“的文稿。</p>

<h1>Git初体验</h1>

<h2>Git有什么用？</h2>

<p>Git是Linux创造者Linus Torvalds编写的、目前人气最旺的版本控制工具。</p>

<p>那么版本控制是做什么的？</p>

<p>写代码免不了修修改改，比如经过一天的奋斗，你完成了一个”寻找最萌妹子“算法，
刚向死党炫耀，就发现选出来的居然是最萌喵星人，太没面子了，回去仔细研究一番，
发现漏了一层筛选条件，于是通宵达旦修改算法，天蒙蒙亮的时候，你发现自己的方法行不通，
需要回退到修改前的状态，换一种算法实现。但这一晚上修改了4、5个文件，
改动散布在不下十处地方，怎么把代码恢复到修改前的状态？</p>

<p>这个时候，是不是希望有哆啦A梦的时光飞毯，帮你回到昨天晚上？</p>

<p>是的，Git就是你要找的时光飞毯。</p>

<p>当然它的功能不止是在代码历史上跳跃，还有很多更炫酷的功能，但千里之行始于足下，让我们从最基本的功能开始吧！</p>

<h2>用Git做简单的版本控制</h2>

<p>Git最基本的用法是在命令行环境中通过执行Git命令的方式完成的。</p>

<p>比如你NB闪闪的算法保存在一个叫"zuiMeng"的文件夹里，
第一步要做的，是启动命令行环境，用<code>cd</code>命令把"zuiMeng"设置为当前目录，
然后执行：<code>git init</code>，这样你的"zuiMeng"目录就具备回到过去的魔力了。</p>

<p>现在你可以随意修改文件了，修改、删除都随你（当然你要作死把"zuiMeng"这个文件夹都删了Git就帮不了你了），
如果对修改满意，提交你的改动到代码库：</p>

<pre><code>git add -A
git commit -m "commit message"
</code></pre>

<p>&ldquo;commit message"一般是这次修改包含的内容，比如”增加了过滤宠物功能“之类的。</p>

<p>如果对改动不满意呢？
执行<code>git reset --hard HEAD</code>，搞定！
什么？你后悔了，要找回刚才的修改？
这个Git还真能满足你，不过这就不是本课程的范围啦，
记住你现在还是个菜鸟，改代码前多动动脑子想清楚没坏处。</p>

<p>这样周而复始，提交了很多次，这时可以用<code>git log</code>来查看你的提交历史。
如果想回到其中的某一次，首先需要在<code>git log</code>界面中记下目标commit的hash值，
这个值很长，只记下前6位就行了，假设这个值是"ef5a5b"，那么要跳转到这次提交，
执行<code>git checkout ef5a5b</code>，看看你的文件，是不是变回到那次提交时的模样了？</p>

<p>如果想跳回最后一次提交，除了重复上面的过程外，还有更简单的方法：
<code>git checkout master</code>，这是因为"master"是一个特殊标记，代表你的最后一次提交。</p>

<p>好，这就是Git的基本用法了，总结一下：</p>

<ol>
<li><p>初始化代码库：<code>git init</code>;</p></li>
<li><p>修改文件；</p></li>
<li><p>提交改动到代码库：<code>git add -A</code>，<code>git commit</code>；</p></li>
<li><p>查看版本历史：<code>git log</code>；</p></li>
<li><p>回退到历史版本：<code>git checkout &lt;hash&gt;</code>.</p></li>
</ol>


<h2>Git还能做什么？</h2>

<ol>
<li><p>分布式开发</p>

<p> 比如你在北京，刚在广州找到一位创业小伙伴，有了Git，就不用搬到广州去啦，
 也不必像Subversion那样，在公网架设代码库，只要在<a href="https://github.com/">github</a>上创建一个公共代码库，
 走遍天涯海角，你需要就是一个WiFi接入点了。</p>

<p> 如果你不希望大家都能看到你们的代码，推荐把公共代码库放在<a href="https://bitbucket.org/">bitbucket</a>上。</p></li>
<li><p>并行开发</p>

<p> 不管你的团队有多少开发者，大家可以同时开发不同的功能，然后合并在一起。
 当然会存在冲突的风险，这里推荐一个高逼格程序员必备神器<a href="https://github.com/nvie/gitflow">git-flow</a>，
 用它武装你的开发团队吧，从此妈妈再也不用担心我们代码冲突啦~</p></li>
</ol>


<h1>Git FAQ</h1>

<ol>
<li><p>我只会用Windows，能用Git吗？</p>

<p> 没问题！下载<a href="https://msysgit.github.io/">msysgit</a>安装包，一路Next安装好之后就可以用了，除了基本的命令行，还附带了一个图形界面工具，是不是很贴心？</p></li>
<li><p>那些命令记不住，能推荐一款纯图形界面的Git工具吗？</p>

<p> 当然可以。如果用Windows，上面介绍的msysgit的图形界面工具就很好了；如果用Linux，Git自带了gitk工具，Mac俺没用过，自己搜搜吧。</p></li>
<li><p>我英语不好，能给点中文资料吗？</p>

<p> 这个真帮不了你了，虽说Git中文资料蛮丰富的，可你的目标不是变成靠Copy/Paster大法挣千把块钱30岁以后转行产品经理的苦逼码农吧？
 如果你希望通过写代码打开一段崭新的人生，从现在开始阅读官网文档吧，
 我带过那么多小弟小妹被我逼着看文档，现在他们自己混饭吃，没有一个用Baidu找中文文档看的。</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
