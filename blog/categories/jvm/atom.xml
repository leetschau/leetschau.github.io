<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jvm | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/jvm/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-04-18T20:42:59+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[通过dump文件分析Java程序运行状态]]></title>
    <link href="http://leetschau.github.io/blog/2012/05/19/144904/"/>
    <updated>2012-05-19T14:49:04+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/05/19/144904</id>
    <content type="html"><![CDATA[<p>Java程序的快照（dump）分为两种：thread dump, heap dump。前者记录了进程（process）中各线程（Thread）（在CPU中的）运行状态主要用来解决死锁（deadlock）问题，后者记录了Java堆的情况，主要用来分析内存泄露问题。</p>

<p> 生成堆dump（heapdump）文件方法
1. 在启动Java程序时添加参数：-XX:+HeapDumpOnCtrlBreak -XX:HeapDumpPath=<my_dump_path>，完整示例见文末；</p>

<ol>
<li><p>启动程序；</p></li>
<li><p>用jps或者ps指令找到此程序pid，例如17992；</p></li>
<li><p>运行kill -3 <pid>；</p></li>
<li><p>在my_dump_path下可以找到生成的dump文件，文件名为java_pid<pid>.hprof.&lt;date.time>，例如：java_pid17992.hprof.20120519.141323</p></li>
</ol>


<p>启动程序的完整脚本：</p>

<h1>!/bin/sh</h1>

<p>JARS=&ldquo;&rdquo;
for i in ./*.jar; do
 JARS=&ldquo;$JARS&rdquo;:$i
done
JAVA_OPTS=&ldquo;-XX:+HeapDumpOnCtrlBreak -XX:HeapDumpPath=$HOME/backup&rdquo;
exec &ldquo;${JAVA_HOME}/bin/java&rdquo; ${JAVA_OPTS} -cp $JARS com.leechau.mina.echoServer.EchoServer
 分析dump文件</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jvm提供的状态监控指令]]></title>
    <link href="http://leetschau.github.io/blog/2011/12/14/104208/"/>
    <updated>2011-12-14T10:42:08+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/12/14/104208</id>
    <content type="html"><![CDATA[<p>jps
类似于unix的ps指令，为其他监控工具提供进程标识（PID）； jstat
对[1]的补充如下：jstat使用-gc参数时，返回的结果包含如下项目：</p>

<p> S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT</p>

<p> 其中S0C表示Survivor0的容量（Capacity），S0U表示Survivor0已使用的空间（Utilization），单位都是KB （详见 <a href="http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstat.html">http://docs.oracle.com/javase/6/docs/technotes/tools/share/jstat.html</a> ）。</p>

<p>如果不关心值大小，而是已使用占容量百分比，则使用-gcutil参数，另外还有-class和-compiler参数可以监控对应线程类和编译器的行为。 jinfo
jinfo -flags <PID>用来查看某进程（用jps查出进程号PID）的JVM参数；</p>

<p> jstack
jstack -m 29517 jmap
jmap -histo 29517</p>

<p>jmap -heap 29517</p>

<p>[1] 周志明：深入理解JAVA虚拟机，机械工业出版社，2011第4.2.2节。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM的内存管理机制]]></title>
    <link href="http://leetschau.github.io/blog/2011/10/21/171026/"/>
    <updated>2011-10-21T17:10:26+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/10/21/171026</id>
    <content type="html"><![CDATA[<p>JVM使用的内存分为两部分：堆（Heap）和栈（Stack），简单理解，堆可以看做是数据区，栈可以看做是指令区；下面详细说明二者的区别。</p>

<p>堆中存放的是对象实例（但不包括对象的方法，因为方法是指令，放在栈里），new出来的对象都放在堆里，对象不再被使用（不可达）时由GC（垃圾回收）机制回收，而无需代码显式释放，堆由于是在运行时动态分配的，因此存取速度比较慢；</p>

<p>栈中存放基本数据类型（primitive types: byte, int, float, long, char, boolean, etc）、常量、指令（例如对象的方法）和对象的引用地址（对象实例在堆中分配以后，需要在栈中保存一个4字节的堆内存地址，也就是所谓的对象句柄，用来确定该对象实例在堆中的位置）。栈中数据存取的速度比堆快，仅次于寄存器，但它必须在编译期间指定，且由于它采用FIFO(first in, first out)方式分配内存，因此不存在内存回收问题，因此GC是仅工作在堆上的。</p>

<p>堆又可以分为3个部分：年轻代（Young Generation,YG）、老代（Old Generation,OG）和永久代（Permanent Generation,PG），新创建的对象都放在YG里，经过几次GC后仍然生存的就被放到了OG里，PG里放的是类信息以及相关元数据（详见[1]）；YG的GC最频繁，PG的GC最少，这样可以极大地提高JVM的性能；</p>

<p>[1] 维基百科对JVM的堆的说明：<a href="http://en.wikipedia.org/wiki/Java_Virtual_Machine#Heap">http://en.wikipedia.org/wiki/Java_Virtual_Machine#Heap</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM选项的含义]]></title>
    <link href="http://leetschau.github.io/blog/2011/10/21/164132/"/>
    <updated>2011-10-21T16:41:32+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/10/21/164132</id>
    <content type="html"><![CDATA[<p>如下这段代码是启动GODU的脚本，其中的JAVA_OPTS中的各个参数是什么意思呢？</p>

<p> JAVA_OPTS=&ldquo; -Xms512m -Xmx1024m -XX:PermSize=128m -XX:MaxPermSize=128m -Dfile.encoding=GBK&rdquo;
TC_INSTALL_DIR=/opt/godu/terracotta-2.7.2
TC_CONFIG_PATH=&ldquo;${GODU_HOME}/conf/tc-config.xml&rdquo;
set &ndash; -q
. &ldquo;${TC_INSTALL_DIR}/bin/dso-env.sh&rdquo;
exec &ldquo;${JAVA_HOME}/bin/java&rdquo; -Dservice_name=godu1.2.1 ${TC_JAVA_OPTS} \
 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8400 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false \
 -Djava.awt.Window.locationByPlatform=true \
 ${JAVA_OPTS} \
 -cp $JARS com.boco.godu.app.AppMain 1234</p>

<p> -Xms512m : 给JVM的堆（Heap）分配初始内存512MB，也是堆内存的下限；</p>

<p> -Xmx1024m : 指定JVM堆内存的上限是1024MB，当这个值偏小时程序可能会出现java.lang.OutOfMemory错误，此错误来自JVM，不是Throwable的，无法用try&hellip;catch&hellip;捕捉；</p>

<p> -XX:PermSize=128m : 给JVM的永久生存对象（见笔记“JVM的内存管理机制”）分配的初始内存为128MB，也是下限值；</p>

<p> -XX:MaxPermSize=128m : 指定JVM给永久生存对象分配内存的上限是128MB， 当这个值偏小时程序可能会出现java.lang.OutOfMemory:PermGen space错误，同样无法用try&hellip;catch&hellip;捕捉；</p>
]]></content>
  </entry>
  
</feed>
