<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 依赖 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/yi-lai/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-04-30T16:15:37+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[依赖管理常用vim脚本]]></title>
    <link href="http://leetschau.github.io/blog/2010/12/23/111308/"/>
    <updated>2010-12-23T11:13:08+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/12/23/111308</id>
    <content type="html"><![CDATA[<p>为依赖条目加上配置说明 效果示例 ：</p>

<p>转换前：
 <dependency org="saxpath" name="saxpath" rev="1.0-FCS"/></p>

<p> <dependency org="aopalliance" name="aopalliance" rev="1.0"/></p>

<p> <dependency org="org.hibernate" name="hibernate-core" rev="3.3.2.GA"/></p>

<p>转换后：</p>

<p> <dependency org="saxpath" name="saxpath" rev="1.0-FCS" conf="compile->master"/></p>

<p> <dependency org="aopalliance" name="aopalliance" rev="1.0" conf="compile->master"/></p>

<p> <dependency org="org.hibernate" name="hibernate-core" rev="3.3.2.GA" conf="compile->master"/></p>

<p> 方法 ：在_vimrc文件里加上如下代码：
 function Add_Conf()</p>

<p>  &ldquo;为ivy的dependency条目加上conf=&rdquo;&hellip;"</p>

<p>  %s/\/>/ conf=&ldquo;compile->master&rdquo;\/></p>

<p> endfunction</p>

<p> command AddConf call Add_Conf()</p>

<p> map <F8> <ESC>:AddConf<CR></p>

<p> 将依赖条目变为下载条目</p>

<p> 效果示例 ：</p>

<p>转换前：</p>

<p> <dependency org="saxpath" name="saxpath" rev="1.0-FCS" conf="compile->master"/></p>

<p> <dependency org="aopalliance" name="aopalliance" rev="1.0" conf="compile->master"/></p>

<p> <dependency org="org.hibernate" name="hibernate-core" rev="3.3.2.GA" conf="compile->master"/></p>

<p>转换后：</p>

<p> &lt;ivy:install organisation=&ldquo;saxpath&rdquo; module=&ldquo;saxpath&rdquo; revision=&ldquo;1.0-FCS&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo;/></p>

<p> &lt;ivy:install organisation=&ldquo;aopalliance&rdquo; module=&ldquo;aopalliance&rdquo; revision=&ldquo;1.0&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo;/></p>

<p> &lt;ivy:install organisation=&ldquo;org.hibernate&rdquo; module=&ldquo;hibernate-core&rdquo; revision=&ldquo;3.3.2.GA&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo;/></p>

<p> 方法 ：在_vimrc文件里加上如下代码：</p>

<p> function Dep_to_Install()</p>

<p>  &ldquo; 将ivy的dependency条目转换为脚本安装条目</p>

<p>  %s/dependency/ivy:install/g</p>

<p>  %s/org=/organisation=/g</p>

<p>  %s/name=/module=/g</p>

<p>  %s/rev=/revision=/g</p>

<p>  %s/conf=&ldquo;compile->master&rdquo;/from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo;/g</p>

<p> endfunction</p>

<p> command Dep2Inst call Dep_to_Install()</p>

<p> map <F9> <ESC>:Dep2Inst<CR></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[依赖项目文本排序（python实现）]]></title>
    <link href="http://leetschau.github.io/blog/2010/12/22/164556/"/>
    <updated>2010-12-22T16:45:56+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/12/22/164556</id>
    <content type="html"><![CDATA[<p>ivy的依赖文件如果条目很多，不排序的话会很乱，例如：</p>

<p> &lt;ivy:install organisation=&ldquo;javax.servlet&rdquo; module=&ldquo;servlet-api&rdquo; revision=&ldquo;2.5&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;junit&rdquo; module=&ldquo;junit&rdquo; revision=&ldquo;4.8.2&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.powermock&rdquo; module=&ldquo;powermock-module-junit4&rdquo; revision=&ldquo;1.4.6&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.snmp4j&rdquo; module=&ldquo;snmp4j&rdquo; revision=&ldquo;1.10.1&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.apache.oro&rdquo; module=&ldquo;jakarta-oro&rdquo; revision=&ldquo;2.0.8&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.easymock&rdquo; module=&ldquo;easymockclassextension&rdquo; revision=&ldquo;2.5.1&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> （ori.txt中这里是空行）</p>

<p>排成这样就比较好看了：</p>

<p> &lt;ivy:install organisation=&ldquo;javax.servlet&rdquo; module=&ldquo;servlet-api&rdquo; revision=&ldquo;2.5&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;junit&rdquo; module=&ldquo;junit&rdquo; revision=&ldquo;4.8.2&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.apache.oro&rdquo; module=&ldquo;jakarta-oro&rdquo; revision=&ldquo;2.0.8&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.easymock&rdquo; module=&ldquo;easymockclassextension&rdquo; revision=&ldquo;2.5.1&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.powermock&rdquo; module=&ldquo;powermock-module-junit4&rdquo; revision=&ldquo;1.4.6&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p> &lt;ivy:install organisation=&ldquo;org.snmp4j&rdquo; module=&ldquo;snmp4j&rdquo; revision=&ldquo;1.10.1&rdquo; from=&ldquo;${from.resolver}&rdquo; to=&ldquo;${to.resolver}&rdquo; /></p>

<p>实际上就是每行按字母顺序排序，手工排费时费力，下面的脚本就是实现这个功能的，将最上面的文本保存为e:/MyDoc/Project/IvyInstallScripts下的build_old_backup.txt（注意最后一行文字后面要有一个空行）中，运行此脚本，排好的文本保存在build_old_backup.txt中，未排序的原始文本保存在build_old_backup.bak中，如果文件夹下已经有build_old_backup.bak，则会首先删除此bak文件，再执行上面的操作：</p>

<p> import os</p>

<p> if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<p>  #name of the source file</p>

<p>  srcFileName = &lsquo;e:/MyDoc/Project/IvyInstallScripts/build_old_backup&rsquo;</p>

<p>  haveXML = os.path.exists(srcFileName+&lsquo;.txt&rsquo;)</p>

<p>  haveBAK = os.path.exists(srcFileName+&lsquo;.bak&rsquo;)</p>

<p>  if haveXML and haveBAK:</p>

<p>   os.remove(srcFileName+&lsquo;.bak&rsquo;)</p>

<p>  if haveXML:</p>

<p>   os.rename(srcFileName+&lsquo;.txt&rsquo;, srcFileName+&lsquo;.bak&rsquo;)</p>

<p>   haveBAK = True</p>

<p>  if not haveBAK:</p>

<p>   print(&ldquo;no source file, quit now!&rdquo;)</p>

<p>   exit()</p>

<p>  # open the src file</p>

<p>  oriScript = open(srcFileName+&lsquo;.bak&rsquo;,&lsquo;rt&rsquo;)</p>

<p>  #the destination file</p>

<p>  destScript = open(srcFileName+&lsquo;.txt&rsquo;,&lsquo;wt&rsquo;)</p>

<p>  try:</p>

<p>   wholeTxt = []</p>

<p>   for curLine in oriScript:</p>

<pre><code>#print(len(curLine)) 

wholeTxt.append(curLine) 
</code></pre>

<p>   wholeTxt.sort()</p>

<p>   for curLine in wholeTxt:</p>

<pre><code>destScript.write(curLine) 
</code></pre>

<p>  finally:</p>

<p>   oriScript.close()</p>

<p>   destScript.close()</p>

<p>下面是简单版：更为易用，保存为一个.py文件即可。</p>

<p> &ldquo;&rdquo;"</p>

<p>  将文本中的各行按字母顺序排序。使用方法：</p>

<p>  将待排序的文本保存在脚本所在目录下，运行脚本，结果保存在dst.txt文件中。</p>

<p> &ldquo;&rdquo;"</p>

<p> import os</p>

<p> oriScript = open(&lsquo;./ori.txt&rsquo;,&lsquo;rt&rsquo;)</p>

<p> dstScript = open(&lsquo;./dst.txt&rsquo;,&lsquo;wt&rsquo;)</p>

<p> try:</p>

<p>  wholeTxt = []
 for curLine in oriScript:
  wholeTxt.append(curLine)
 noDupList = list(set(wholeTxt)) # delete potential duplicated lines in wholeTxt
 noDupList.sort()
 for curLine in noDupList:
  dstScript.write(curLine)</p>

<p> finally:</p>

<p>  oriScript.close()</p>

<p>  dstScript.close()</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UML中关联(association)和依赖(dependency)的区别]]></title>
    <link href="http://leetschau.github.io/blog/2010/06/17/110050/"/>
    <updated>2010-06-17T11:00:50+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/06/17/110050</id>
    <content type="html"><![CDATA[<h2>下面是从网上搜集的一些关联(association)和依赖(dependency)区别的看法： </h2>

<h2>1. </h2>

<p>Dependency Relationship</p>

<p>Draw a dependency relationship between two classes, or between a class and an interface, to show that the client class depends on the supplier class/interface to provide certain services, such as:</p>

<p>?The client class accesses a value (constant or variable) defined in the supplier class/interface.</p>

<p>?Operations of the client class invoke operations of the supplier class/interface.</p>

<p>?Operations of the client class have signatures whose return class or arguments are instances of the supplier class/interface.</p>

<p>A dependency relationship is a dotted line with an arrowhead at one end:The arrowhead points to the supplier class.</p>

<p>Association Relationship</p>

<p>An association provides a pathway for communication. The communication can be between use cases and actors, between two classes or between a class and an interface. Associations are the most general of all relationships and consequentially the most semantically weak. If two objects are usually considered independently, the relationship is an association</p>

<hr />

<h2>2. </h2>

<p>Martin Fowler</p>

<p>If you have an association from Class A to Class B then that means every instance of class A has some kind of link to class B. Now exactly what people mean by &ldquo;some kind of link&rdquo; varies, it may be a conceptual link, a method of the form getA or a field inside class A. But the usual notion is that the link exists at all times (although if the lower bound is 0 it may be empty). This link can be used by any method of A and, if exposed, by other classes too.</p>

<p>With a parameter the connection between A and B only exists within the scope of the method that took the parameter. No other method can use the connection. As such that, for most people I come across, means that it is not an association.</p>

<p>The dependency means that if you change the interface of B then you may have to change A. An association usually implies a dependency, but not vice-versa, as the parameter example suggests.</p>

<hr />

<h2>3. </h2>

<p>Robert C. Martin
However, association is not free of semantics. An association is a data relationship. i.e. the implementation must use some sort of data variable to implement it. Typically this is done with some kind of member variable or instance variable that refers to the associate. In C++ we might create a pointer variable, in Java a reference variable. Or we might use some kind of string that represents the associate in a dictionary somewhere.</p>

<p>In order for a message to be send between two objects, an association must exist between their two classes; and that association must be navigable in the direction that the message was sent.</p>

<hr />

<h2>4. </h2>

<p>quote:</p>

<blockquote><p>What is the difference between Association and Dependency?</p>

<p>My understanding so far was:</p>

<p>If an object of class A has a reference to an object of class B in its
attribute structure, it is association.</p></blockquote>

<p>Robert C. Martin&rsquo;s answer:</p>

<p>Er, well, uh &ndash; hmmm.</p>

<p>That&rsquo;s as good a definition as any I suppose. There are so many different colloquialisms and slangs for UML that I guess it hardly matters any more.</p>

<p>There was a time when an association was the channel between classes over which messages were sent. No message, no association. But that rule has been relaxed by so much conventional usage that I don&rsquo;t think it can hold any more.</p>

<p>Nowadays we seem to use association and aggregation interchangeably to represent a data field (except, of course, that everybody has their own private definition for what the white diamond means.) Dependency if very commonly used to represent an argument passed to a function. This was not the original intent of UML, but it&rsquo;s the way things have turned out.</p>

<p>There was a time when dependency meant that a class knew about another, but did not send messages. Data structures had dependencies on their members because they didn&rsquo;t send them messages, whereas classes had associations with their members because they did send them messages. But that nice separation has gotten so badly muddled that it has become useless.</p>

<p>Perhaps you can read from my tone that I&rsquo;m pretty disillusioned with UML. Too bad. It could have been a standard. Now, I think its just going to be a confusing compendium of confounding conventions.</p>

<hr />

<h2>5. </h2>

<p>//
From UML 2.0 Superstructure Final Adopted Specification:
&ldquo;An association describes a set of tuples whose values refer to typed instances.&rdquo; (p. 97)
&ldquo;A dependency is a relationship that signifies that a single or a set of model elements requires other model elements for their specification or implementation.&rdquo; (p. 124)</p>

<hr />

<h2>6. </h2>

<p>依赖是比关联弱的关系，关联代表一种结构化的关系，体现在生成的代码中，以java为例：
 若类A单向关联指向类B，则在类A中存在一个属性B b。
若类A依赖类B，则不会有这个属性，类B的实例可能存在于某个方法调用的参数中，或某个方法的局部变量中。</p>

<hr />

<h2>7. </h2>

<p> 关联有双向与单向之分，类A与类B双向关联可以是A与B相互可以作为对方的一个attribute，单向的话，就指其中一个类作为另一个类中的 attribute；依赖就只有单向的，不存在attribute的问题，例如类A依赖类B，表示在类A中有三种类B的使用方法：一是类B是全局的，二是类B在类A中实例化，三是类B作为参数被传递</p>

<hr />

<h2>8. </h2>

<p>关联是一种结构关系，表现为一个对象能够获得另一个对象的实例引用并调用它的服务（即使用它）；依赖是一种使用关系，表现为一个对象仅仅是调用了另一个对象的服务。</p>
]]></content>
  </entry>
  
</feed>
