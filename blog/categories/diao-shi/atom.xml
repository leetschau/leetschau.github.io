<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 调试 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/diao-shi/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-08-27T13:25:34+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Eclipse中监视对象变化]]></title>
    <link href="http://leetschau.github.io/blog/2011/10/19/180654/"/>
    <updated>2011-10-19T18:06:54+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/10/19/180654</id>
    <content type="html"><![CDATA[<p>调试遗留代码时经常遇到的一个问题是由于对代码不了解，一个变量（Java里经常表现为对象的字段，尤其是全局(static)字段）经常在自己不知道的地方被改变，如果能够在这个对象被改变的时候停住，则非常有利于理解代码的运行流程非常有好处，在Eclipse中设置这样的断点很容易，就是在这个字段声明的行加断点，这样在Breakpoints View里就可以看到这个对象在何种情况下暂停了。如下图是对userPriMap字段添加监视断点。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于ivy的源代码调试方法]]></title>
    <link href="http://leetschau.github.io/blog/2011/03/09/111841/"/>
    <updated>2011-03-09T11:18:41+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/03/09/111841</id>
    <content type="html"><![CDATA[<p>项目PORJ_TEST是项目PROJ的测试项目。在它的ivy中引用了PROJ的jar包。由于PROJ正处于开发阶段，源代码更改频繁， 在运行PROJ_TEST中的测试时，需要进入PROJ的jar包内部设置断点、调试源代码。传统的方法是在PROJ_TEST的Build Path中添加PROJ项目，但这样显然与ivy中定义的引用发生了冲突，且容易在打包时出现问题，怎样让ivy引用的jar包也能提高源代码？方法如下：
PROJ项目的ivy.xml文件（ivy配置文件）：</p>

<p> <ivy-module version="2.0" ></p>

<p> <info organisation="..." module="proj" revision="alpha" status="integration"/></p>

<p> <configurations></p>

<p> <conf name="master" visibility="public" description="contains only the artifact published by this module itself, with no transitive dependencies"/></p>

<p> <conf name="test" visibility="public" description="used for the test project of gapi" extends="compile"/></p>

<p> <conf name="compile" visibility="private" description="used for compile the artifact only"/></p>

<p> <conf name="sources" visibility="public" description="contains the source artifact of this module"/></p>

<p> </configurations></p>

<p> <publications></p>

<p> <artifact name="gapi" type="jar" ext="jar" conf="master"/></p>

<p> <artifact name="gapi" type="source" ext="jar" conf="sources"/></p>

<p> </publications></p>

<p> <dependencies></p>

<p> <dependency .../></p>

<p> <dependency .../></p>

<p> </dependencies></p>

<p> </ivy-module></p>

<p> PROJ项目的build.xml文件（Ant构建脚本）：</p>

<p> &lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?></p>

<p> <project name="PROJ" basedir="./" default="publish_jar" xmlns:ivy="antlib:org.apache.ivy.ant"></p>

<p> <property name="src.dir" value="${basedir}/src" /></p>

<p> <property name="build.dir" value="${basedir}/build" /></p>

<p> <property name="build.class.dir" value="${build.dir}/class" /></p>

<p> <property name="build.dist.dir" value="${build.dir}/dist" /></p>

<p> <property name="build.javadoc.dir" value="${build.dir}/javadocs" /></p>

<p> <property name="build.lib.dir" value="${build.dir}/lib" /></p>

<p> <property name="vendor.name" value="LC_COM" /></p>

<p> <property name="product.name" value="proj" /></p>

<p> <property name="publish.resolver" value="test-repo" /></p>

<p> <tstamp></p>

<p> <format property="build.date" pattern="yyyyMMdd" /></p>

<p> <format property="build.time" pattern="HH:mm:ss" /></p>

<p> </tstamp></p>

<p> <path id="lib.path"></p>

<p> <fileset dir="${build.lib.dir}"></p>

<p> <include name="**/*.jar"/></p>

<p> </fileset></p>

<p> </path></p>

<p> <target name="clean"></p>

<p> <delete dir="${build.dir}"/></p>

<p> </target></p>

<p> <target name="init" depends="clean"></p>

<p> <mkdir dir="${build.dir}"/></p>

<p> <mkdir dir="${build.class.dir}"/></p>

<p> <mkdir dir="${build.dist.dir}"/></p>

<p> <mkdir dir="${build.lib.dir}"/></p>

<p> &lt;ivy:settings file=&ldquo;../ivysettings.xml&rdquo;/></p>

<p> &lt;ivy:resolve/></p>

<p> &lt;ivy:retrieve pattern=&ldquo;${build.lib.dir}/[artifact]-[revision].[ext]&rdquo;/></p>

<p> </target></p>

<p> <target name="compile" depends="init"></p>

<p> &lt;javac srcdir=&ldquo;${src.dir}&rdquo; destdir=&ldquo;${build.class.dir}&rdquo;</p>

<p> classpathref=&ldquo;lib.path&rdquo; encoding=&ldquo;GBK&rdquo; debug=&ldquo;true&rdquo;/></p>

<p> </target></p>

<p> <target name="create_jar" depends="compile"></p>

<p> <jar destfile="${build.dist.dir}/${product.name}-${ivy.revision}-jar.jar" basedir="${build.class.dir}"></p>

<p> <manifest></p>

<p> <attribute name="Vendor" value="${vendor.name}" /></p>

<p> <attribute name="Product-Name" value="${product.name}" /></p>

<p> <attribute name="Version" value="${ivy.revision}" /></p>

<p> <attribute name="Build-Date" value="${build.date}" /></p>

<p> <attribute name="Build-Time" value="${build.time}" /></p>

<p> </manifest></p>

<p> </jar></p>

<p> <jar destfile="${build.dist.dir}/${product.name}-${ivy.revision}-source.jar" basedir="${src.dir}"></p>

<p> <manifest></p>

<p> <attribute name="Vendor" value="${vendor.name}" /></p>

<p> <attribute name="Product-Name" value="${product.name}" /></p>

<p> <attribute name="Version" value="${ivy.revision}" /></p>

<p> <attribute name="Build-Date" value="${build.date}" /></p>

<p> <attribute name="Build-Time" value="${build.time}" /></p>

<p> </manifest></p>

<p> </jar></p>

<p> </target></p>

<p> <target name="publish_jar" depends="create_jar"></p>

<p> &lt;ivy:publish artifactspattern=&ldquo;${build.dist.dir}/[artifact]-[revision]-[type].[ext]&rdquo;</p>

<p> resolver=&ldquo;${publish.resolver}&rdquo; status=&ldquo;integration&rdquo; overwrite=&ldquo;true&rdquo;/></p>

<p> <echo message="publish complete."/></p>

<p> </target></p>

<p> </project></p>

<p>PROJ_TEST项目的ivy.xml文件：</p>

<p> <ivy-module version="2.0" ></p>

<p> <info organisation="..." module="proj_test" revision="alpha" status="integration" publication="20101121175043"/></p>

<p> <configurations></p>

<p> <conf name="master" visibility="public" description="contains only the artifact published by this module itself, with no transitive dependencies"/></p>

<p> <conf name="compile" visibility="private" description="used for compile the artifact only"/></p>

<p> <conf name="test" visibility="public" description="used for the test project of gapi" extends="compile"/></p>

<p> </configurations></p>

<p> <publications></p>

<p> <artifact name="gapi_test" type="jar" ext="jar" conf="master"/></p>

<p> </publications></p>

<p> <dependencies></p>

<p> <dependency org="..." name="proj" rev="alpha" conf="compile->master,test&#8221; changing=&ldquo;true&rdquo;/></p>

<p> <dependency .../></p>

<p> <dependency .../></p>

<p> </dependencies></p>

<p> </ivy-module></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eclipse带参数调试的方法]]></title>
    <link href="http://leetschau.github.io/blog/2010/06/04/110230/"/>
    <updated>2010-06-04T11:02:30+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/06/04/110230</id>
    <content type="html"><![CDATA[<p>下面是体现带参数调试的一个代码demo，首先输出参数的数量，然后依次输出每个参数。
public class ArgsEx {
 public static void main(String[] args) {
 int argNum = args.length;
 System.out.println(&ldquo;args number is = &rdquo;+argNum);
 for (int i = 0; i &lt; args.length; i++) {
 System.out.println(args[i]);
 }
 }
}
在Eclipse主菜单【Run->Debug Configurations】下，首先根据自己的工程类型（一般是Java Application）新建一个&#8221;New Launch Configuration&#8221;，右边面板上首先设置这个configuration的名字（Name），【Main】标签页下设置要调试的工程和main函数的位置（一般就是默认给出的），【Arguments】标签页下的【Program Arguments】下写上参数，如果有多个参数，每行写一个。【Run】菜单下的【Debug Configurations】和【Run Configurations】是互相联系的，二者保持一致，即在Debug Configurations中修改会导致Run Configurations做同样的变化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Ultraedit调试tk程序]]></title>
    <link href="http://leetschau.github.io/blog/2009/11/18/155015/"/>
    <updated>2009-11-18T15:50:15+08:00</updated>
    <id>http://leetschau.github.io/blog/2009/11/18/155015</id>
    <content type="html"><![CDATA[<p>tk没有自己的编译环境，Ultraedit中仅3步就可以打造一个tk调试环境：
1. 为UE添加tcl/tk语法高亮支持：从UE的网站上下载tcl/tk的wordfile；
2. 添加编译命令到菜单中：UE主菜单【高级->工具配置】出现“工具配置窗口：</p>

<p>在【命令】标签页中：</p>

<p>点击按钮“插入”</p>

<p>【菜单项目】：运行tk程序</p>

<p>【命令行】：wish85 %n%e（%n表示当前文件名（不含扩展名），%e表示当前文件名的扩展名）</p>

<p>【工作目录】：%p（当前文件的路径）</p>

<p>在【输出】标签页中：
 选择【Output to List Box】（运行结果显示在输出窗口中，此窗口在【窗口->输出窗口】或者【视图->视图/列表->输出窗口】处设置开闭，其他几项是输出到指定的文件中）和【Capture Output】（否则输出不会被捕捉到）</p>

<ol>
<li>为菜单项添加快捷键：【高级->配置->键盘映射】中找到【高级－用户工具1】，在【按下新的键】中设置自己喜欢的热键，例如F6。</li>
</ol>


<p>参考博文《如何用UltraEdit编译和运行java程序》。</p>

<p>注：UEv16中，标签页也是可浮动的，感觉不方便，在【配置->Application Layout->File Tabs->Operation】中取消勾选【Dockable Tabs】。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何用eclipse调试HLA代码]]></title>
    <link href="http://leetschau.github.io/blog/2006/05/21/150009/"/>
    <updated>2006-05-21T15:00:09+08:00</updated>
    <id>http://leetschau.github.io/blog/2006/05/21/150009</id>
    <content type="html"><![CDATA[<p>体系问题：在 HLA 中，哪些是源码，哪些是库？
 以《计算机仿真中的 HLA 技术》的代码为例，包括批处理和 bin 、 config 、 doc 、 lib 、 src 五个子目录，其中 doc 是说明文档， src 是 bin 中 class 文件的源代码，都不在体系之内。 Config 用来存放 fed 和 props 文件，作为 HLA 系统的重要参数文件；然后分析核心部分：我们看 manager.bat 中的内容： javaw -cp bin;lib\prti.jar;lib\jgl3.1.0.jar;lib\swingall.jar org.mitre.hla.book.manager.Manager
 org.mitre.hla.book.manager.Manager 是要执行的文件，也就是需要 HLA 开发者自己编写代码的部分，其源代码在 src 下都可以找到，也可以用上面提到的 jad 反编译一下看看，这样的文件都在 bin 下，其他 -cp 中的 jar 文件就是提供 Manager 运行必需的库了，它们都放在 lib 下。
 小结： 开发 HLA 系统时， (1) ：将别人提供的 RTI 软件放在 lib 文件夹下，（如《计…… HLA 技术》中用的是瑞典 Pitch AB 公司开发的 pRTI 的预览版，这个 RTI 软件一般是一些 jar 文件，如本书中是 Lib 文件夹下的 prti.jar 。） (2) ：将自己编写的 HLA 体系运行代码（主要由 Manager.java （联邦管理器）及其附属类说明文件、代表各个联邦成员的文件组成）编译后放在 bin 文件夹下； (3) ：将配置 HLA 系统的 fed 文件和 props 文件放在 config 文件夹下即可。
 如何在 Eclipse 中建立 HLA 调试环境？
 第一步：建立工程并添加引用库。新建一个 Java Project （假设名为 HLADemo ），可以在新建工程的 Libraries 页中点 Add External JARs 加入前面提到的 RTI 库文件，也可以建好工程后在 Project->Properties->Java Build Path->Libraries 中加；
 第二步：导入源代码。假设代码都在 src 文件夹下，在 Eclipse 中右击 HLADemo ，选择 Import->File System ，将 src 文件夹下的内容加入到工程中。
 第三步：加入 config 部分。将 config 文件夹拷贝到 workspace 中的工程文件夹下，然后在 Eclipse 中右击 HLADemo ，选择 Import->File System ，将 config 文件夹加入到工程中。
 如何在 Eclipse 中运行 HLA ？
 第一步：启动 RTI 环境。在《计…… HLA 技术》中是双击 rti.bat ，由于这个属于 HLA 的 RTI 提供者的职责，所以开发者不需要关心运行机理；
 第二步：启动联邦管理器。打开 Manager.java ，运行之即可。
 第三步：启动其它联邦成员。打开相应的文件，运行之即可。
 如何在 Eclipse 中加库？
 选中代表 HLA 的工程，在 Project->Properties->Java Build Path->Libraries 中加。
 如果库文件带有源码
 将源码所在目录的路径加入到 Project->Properties->Java Build Path->Libraries->Source attachment 中即可。例如： Libraries 中有一个库为 prti.jar ，用 winRAR 打开，其中有 a 和 c 两个子目录，下面的目录结构分别为： a\b*.class 和 c\d*.class ，可以在任意位置新建一个 src 目录，也在下面建立 a 和 c 两个子目录，下面的目录结构分别为： a\b*.java 和 c\d*.java ，将 Source attachment 中的目录指定到… \src 即可。在代码区中，如果某个类的类型显示为 a.b.AnyClass ，则在该类上右键 ->Open Delaration 就能看到该类在库文件中的定义。另：如果库没有源码，可以将 *.class 解压出来之后用 jad 反编译。
 如何在 Eclipse 中调试 HLA ？
 同运行方法类似，只是打开相应文件后，将“运行”命令改为“调试”，就可以用单步执行或者设置断点的方式调试自己的代码了。</p>
]]></content>
  </entry>
  
</feed>
