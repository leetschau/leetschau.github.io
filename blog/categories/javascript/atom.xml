<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-02-02T16:10:00+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Frequent Used Commands in Mongodb Shell]]></title>
    <link href="http://leetschau.github.io/blog/2014/12/29/193156/"/>
    <updated>2014-12-29T19:31:56+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/12/29/193156</id>
    <content type="html"><![CDATA[<p>The foloowing codes demonstrate the creation &copy;, query &reg;, update (U) and delete (D) operations on mongodb collections.</p>

<p>It also shows how to rename collections and keys of documents.</p>

<pre><code>$ mongo
db.fairs.insert({'name': 'bikeShow', 'time': '2014.12.24', 'location': 'Beijing', 'products': ['bike', 'car', 'truck']})
db.fairs.insert({'name': 'clothShow', 'time': '2014.2.14', 'location': 'Shanghai', 'products': ['silk', 'wood', 'paper']})
db.fairs.insert({'name': 'MyFruits', 'time': '2011.4.18', 'location': 'Guangzhou', 'products': ['berry', 'apple', 'banana']})

db.newfairs.find({}, {name: 1})
db.newfairs.find({}, {'name.chn': 1})

db.fairs.renameCollection('newfairs')

db.newfairs.update({}, {$rename: {'time': 'date'} }, {multi: true} )
db.newfairs.update({}, {$rename: {'name': 'names'} }, {multi: true} )
db.newfairs.update({}, {$rename: {'names': 'name.chn'} }, {multi: true} )
db.newfairs.update({}, {$unset: {'date': ""}}, {multi: true})
db.newfairs.remove({})
db.newfairs.drop()
exit
</code></pre>

<p>You can&rsquo;t use <code>{$rename: {'name': 'name.chn'}}</code> directly for &ldquo;$rename must not be on the same path&rdquo;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[遍历Javascript对象属性的方法]]></title>
    <link href="http://leetschau.github.io/blog/2014/12/29/151419/"/>
    <updated>2014-12-29T15:14:19+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/12/29/151419</id>
    <content type="html"><![CDATA[<p>启动node.js命令行，创建一个最简单的对象，然后遍历其属性：</p>

<pre><code>$ node
&gt; var myobj = {k1: "p1", k2: 'p2'}

&gt; for (var key in myobj) {
... console.log(key);
... console.log(myobj.key);
... console.log(myobj[key]);
... }
k1
undefined
p1
k2
undefined
p2
&gt; myobj.k1
'p1'

&gt; var ak = 'k4'
undefined
&gt; myobj.ak = 'p4'
'p4'
&gt; myobj
{ k1: 'p1',
  k2: 'p2',
  ak: 'p4' }
&gt; myobj[ak] = 'p4'
'p4'
&gt; myobj
{ k1: 'p1',
  k2: 'p2',
  ak: 'p4',
  k4: 'p4' }

&gt; myobj[nk] = 'p5'
ReferenceError: nk is not defined
    at repl:1:8
    at REPLServer.self.eval (repl.js:110:21)
    ...
&gt; myobj['nk'] = 'p5'
'p5'
&gt; myobj
{ k1: 'p1',
  k2: 'p2',
  ak: 'p4',
  k4: 'p4',
  nk: 'p5' }
</code></pre>

<p>点操作符 (myobj.key) 和中括号 (myobj[key]) 都能用于获取和添加对象属性，
二者的区别在于，点操作符后面的属性名称按照字面量处理，
中括号中的属性名称按照变量名处理。</p>

<p>如果想通过变量名读写对象属性，必须用中括号操作符，
如果想不写引号直接引用属性名称，必须用点操作符。</p>

<p>搜索&#8221;javascript object dot square bracket&#8221;查找相关文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Development Environment Setup]]></title>
    <link href="http://leetschau.github.io/blog/2014/11/04/145629/"/>
    <updated>2014-11-04T14:56:29+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/11/04/145629</id>
    <content type="html"><![CDATA[<h1>vim</h1>

<ol>
<li><p>Install nvm;</p></li>
<li><p>Install node with nvm;</p></li>
<li><p>Install jshint with npm, which is a tool in node: <code>npm install -g jshint</code>;</p></li>
<li><p>Check syntax with <code>jshint myfile.js</code>;</p></li>
<li><p>Check html syntax with Tidy, which is installed on Ubuntu with <code>apt-get install tidy</code>;</p></li>
</ol>


<p>Ref: <a href="http://stackoverflow.com/questions/473478/vim-jslint">VIM + JSLint?</a></p>

<h1>Eclipse</h1>

<p>Eclipse&rsquo;s javascript development tools JSDT is part of WTP (web tools platform),
which is a built-in plugin of &ldquo;Eclipse JEE&rdquo; (Eclipse for Java EE Developers).</p>

<p>Its editor has auto syntax checker. Config it in [Window -> Preferences -> JavaScript -> Editor].
Config its code style (tab size, for example) at [Window -> Preferences -> JavaScript -> Code Style -> Formatter].</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DMShell Up and Running]]></title>
    <link href="http://leetschau.github.io/blog/2014/10/28/182614/"/>
    <updated>2014-10-28T18:26:14+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/10/28/182614</id>
    <content type="html"><![CDATA[<p>The dmshell is a web server accepting a shell command string, and run it on web server host.</p>

<h1>Setup DataBase</h1>

<h2>Fix Derby Server Startup Failed</h2>

<p>When start Derby server with <code>/home/chad/apps/jdk1.6.0_45/db/bin/startNetworkServer</code>, the following error raised:</p>

<blockquote><p>access denied (&ldquo;java.net.SocketPermission&rdquo; &ldquo;localhost:1527&rdquo; &ldquo;listen,resolve&rdquo;)</p></blockquote>

<p>Solution:</p>

<p>Find out system&rsquo;s JRE. On my laptop, it&rsquo;s /usr/lib/jvm/java-7-openjdk-amd64/jre
Add the following codes into file lib/security/java.policy in this folder:</p>

<pre><code>grant {
    permission java.net.SocketPermission "localhost:1527", "listen";
};
</code></pre>

<p>Ref: <a href="http://stackoverflow.com/questions/21154400/unable-to-start-derby-database-from-netbeans-7-4">http://stackoverflow.com/questions/21154400/unable-to-start-derby-database-from-netbeans-7-4</a></p>

<h2>Create Database and Table</h2>

<p>Run ~/apps/jdk1.6.0_45/db/bin/ij and run following commands:</p>

<pre><code>connect 'jdbc:derby://localhost:1527/dmdb;create=true';
create table shellstatus (id int not null generated by default as identity (start with 1, increment by 1), shellname varchar(40), starttime timestamp, endtime timestamp,status int);
</code></pre>

<p>Then you can use <code>select * from shellstatus;</code> to list all data in this table.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Closure in Different Languages]]></title>
    <link href="http://leetschau.github.io/blog/2014/08/20/104236/"/>
    <updated>2014-08-20T10:42:36+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/08/20/104236</id>
    <content type="html"><![CDATA[<p>The following code snippets compare closures in several languages.</p>

<p>First is closure in javascript. Here I use <a href="https://github.com/creationix/nvm">nvm</a> to run javascript code.</p>

<pre><code>$ cat closure.js
function extent() {
    var n = 0;
    return function() {
        n++;
        console.log("n=" + n);
    }
}

extent()();
extent()();
f = extent();
console.log("-----");
//console.log(extent.uniqueId());
f();
f();

$ nvm alias default 0.10
$ nvm run closure.js
Running node v0.10.30
n=1
n=1
-----
n=1
n=2
</code></pre>

<p>In above example, the closure is <code>function() { n++; console.log... }</code>. It&rsquo;s bound to variable &ldquo;f&rdquo;. The local variable &ldquo;n&rdquo; is &ldquo;closed&rdquo; into closure. Its lifetime is the same with &ldquo;f&rdquo;. So after the first execution of f, its inner state is saved.</p>

<p>For Python, nested function can only access variables in outer scope, but can&rsquo;t reassign (modify) them. So I use list as a workaround. In Python 3, there is a new keyword &ldquo;nonlocal&rdquo; to remove this restriction.</p>

<pre><code>$ cat closure.py2.py
def extent():
    n = [0]
    def afun():
        n[0] += 1
        print('n=' + str(n[0]))
    return afun

extent()()
extent()()
print('-----')
f = extent()
f()
f()
print("type of f is %s, its id is %d" % (type(f), id(f)))

$ python closure.py2.py 
n=1
n=1
-----
n=1
n=2
type of f is &lt;type 'function'&gt;, its id is 140403684898408

$ cat closure.py3.py
def extent():
    n = 0
    def afun():
        nonlocal n
        n += 1
        print('n=' + str(n))
    return afun

extent()()
extent()()
f = extent()
print('----')
f()
f()
print("type of f is %s, its id is %d" % (type(f), id(f)))

[0] python3 closure.py3.py
n=1
n=1
----
n=1
n=2
type of f is &lt;class 'function'&gt;, its id is 139914425096528
</code></pre>

<p>The Ruby environment used here is <a href="http://rvm.io/">RVM</a>. Ruby version is 2.1.2.</p>

<pre><code>$ rvm use 2.1.2 --default
$ cat closure.rb
def extent
    n = 0
    lambda {
        n += 1
        printf "n=%d\n", n
    }
end

extent().call()
extent().call()
f = extent()
puts '------'
f.call()
f.call()
puts "class of f is #{f.class.name}, its id is #{f.object_id}"

$ ruby closure.rb
n=1
n=1
------
n=1
n=2
class of f is Proc, its id is 6724520
</code></pre>

<p>Two versions of Scala, define functions via &ldquo;def&rdquo; and &ldquo;val&rdquo; give different results:</p>

<pre><code>$ diff *.scala
1c1
&lt; def extent = {
---
&gt; val extent = {

$ cat closure-def.scala
def extent = {
    var n = 0
    () =&gt; {
        n += 1
        println("n=" + n)
    }
}

extent()
extent()
val f = extent
println("------")
f()
f()
println(s"Class of f is ${f.getClass}, its id is ${f.hashCode}")

$ scala closure-def.scala
n=1
n=1
------
n=1
n=2
Class of f is class Main$$anon$1$$anonfun$extent$1, its id is 8970973

$ cat closure-val.scala 
val extent = {
    var n = 0
    () =&gt; {
        n += 1
        println("n=" + n)
    }
}

extent()
extent()
val f = extent
println("------")
f()
f()
println(s"Class of f is ${f.getClass}, its id is ${f.hashCode}")
$ scala closure-val.scala 
n=1
n=2
------
$ scala closure-val.scala 
n=1
n=2
------
n=3
n=4
Class of f is class Main$$anon$1$$anonfun$1, its id is 8970973
</code></pre>
]]></content>
  </entry>
  
</feed>
