<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Map | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/map/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-06-04T20:48:19+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VIM的键映射]]></title>
    <link href="http://leetschau.github.io/blog/2011/10/31/111849/"/>
    <updated>2011-10-31T11:18:49+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/10/31/111849</id>
    <content type="html"><![CDATA[<h1>ESC键</h1>

<p>在vim中ESC是一个重度使用的键，但不幸的是这个键离手的默认位置比较远（最初设计VIM的键盘与现在的键盘不同，那个时候的ESC键基本上处在现在TAB键的位置上），按一次就得看一下键盘，严重影响VIM这种神器的使用者的风范，解决这个问题最好的方法不是刻苦训练手的机械记忆，首先训练比较花时间，其次孔子他老人家教导我们君子不器，我们怎么能把自己（的一部分）训练成机器呢？最后也是最重要的理由是：即使能训练出来，手在键盘上来回飞舞还是比较花时间， 基于以上理由，我决定采用如下键映射方法解决这个问题。
在$vim/_vimrc里加上：</p>

<pre><code>imap ;; &lt;ESC&gt; 
cmap ;; &lt;ESC&gt;
</code></pre>

<p>这样，在插入和命令行模式下，只要连按两个分号就相当于按了一次ESC键。那么，如果在插入模式下确实需要输入;;怎么办呢？只要在输入第一个;之后停顿一下，再输入就行了，详见“:h timeout”。对上述代码的详细解释见附1和附2。</p>

<p>上面是用;;代替ESC键，其实在还有别的很多替代方案，比如用jj代替ESC也比较常见，详见“ Avoid the escape key ”， 但我觉得都没有;;方案方便、安全、有效。</p>

<h1>Ctrl键</h1>

<p>比较普遍的方案是用Capslock键代替Ctrl键，这个vim自己就搞不定了，比较好的方法是用另一个神器：Autohotkey完成这个功能，下面的ahk代码实现Capslock键代替Ctrl键，而原来Capslock键的功能用Shift+Capslock实现；</p>

<pre><code>#IfWinActive VIM ; if in vim 
+Capslock::Capslock ; make shift+Caps-Lock the Caps Lock toggle 
Capslock::Control ; make Caps Lock the control button 
#IfWinActive  ; end if in vim 
</code></pre>

<p>详见“ MovingTheCtrlKey ”。</p>

<p>附1：键映射与模式</p>

<p>所谓键映射，就是将一个按键（或者组合按键）转换为另一个按键（或者组合按键）。为什么要转换呢？主要是为了提高效率，比如原始键位置太远，或者要输入的东西太多，或者需要两手同时操作。由于vim有多种模式，就出现了一个键映射在什么模式下有效的问题。以上面的ESC键为例，VIM一共有5种模式（详见:h map-modes）：normal, insert, operator-pending, visual, command-line，需要按ESC的只有insert和command-line两种，其他3种模式中jj往往表示光标移动，若映射会造成操作不便。map系列指令的第一个字母表示模式，上述五个模式分别用n, i, o, v, c表示（详见“:h map-overview”），所以imap表示仅在insert模式下这个映射有效。</p>

<p>附2：map与noremap的区别</p>

<p>若有“map A B”和“map B C”，则“map A B”最终的效果是执行C，这就是映射定义的嵌入与递归问题（详见“:h noremap”），不论是否存在“map B C”，“noremap A B”都执行B。结合附1的说明，nnoremap就是normal模式下的noremap指令；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Map的putAll方法验证]]></title>
    <link href="http://leetschau.github.io/blog/2011/09/24/145213/"/>
    <updated>2011-09-24T14:52:13+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/09/24/145213</id>
    <content type="html"><![CDATA[<p>下面的程序验证了Map的putAll方法的行为特性，代码如下：</p>

<p> import java.util.HashMap;</p>

<p> public class Map_putAllTest {</p>

<p>  public static void main(String[] args){</p>

<p>  //两个map具有不同的key</p>

<p>  HashMap map1=new HashMap();</p>

<p>  map1.put(&ldquo;1&rdquo;, &ldquo;A&rdquo;);</p>

<p>  HashMap map2 = new HashMap();</p>

<p>  map2.put(&ldquo;2&rdquo;, &ldquo;B&rdquo;);</p>

<p>  map2.put(&ldquo;3&rdquo;, &ldquo;C&rdquo;);</p>

<p>  map1.putAll(map2);</p>

<p>  System.out.println(map1);</p>

<p>  //两个map具有重复的key</p>

<p>  HashMap map3=new HashMap();</p>

<p>  map3.put(&ldquo;1&rdquo;, &ldquo;A&rdquo;);</p>

<p>  HashMap map4 = new HashMap();</p>

<p>  map4.put(&ldquo;1&rdquo;, &ldquo;B&rdquo;);</p>

<p>  map4.put(&ldquo;3&rdquo;, &ldquo;C&rdquo;);</p>

<p>  map3.putAll(map4);</p>

<p>  System.out.println(map3);</p>

<p>  }</p>

<p> }</p>

<p>保存为F:\Map_putAllTest.java，编译和运行结果如下：</p>

<p> F:>javac Map_putAllTest.java</p>

<p> 注意：Map_putAllTest.java 使用了未经检查或不安全的操作。</p>

<p> 注意：要了解详细信息，请使用 -Xlint:unchecked 重新编译。</p>

<p> F:>java Map_putAllTest</p>

<p> {3=C, 2=B, 1=A}</p>

<p> {3=C, 1=B}</p>

<p> F:></p>

<p>上例说明A.putAll(B)方法就是将B的内容全部放入A中，如果有重复的key1，则用B中key1对应的value（B.get(key1)）覆盖A中key1对应的value。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用map实现两个list的元素对位运算]]></title>
    <link href="http://leetschau.github.io/blog/2011/04/19/165249/"/>
    <updated>2011-04-19T16:52:49+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/04/19/165249</id>
    <content type="html"><![CDATA[<p>例如[1,2]与[11,25]的对位相加得到[12,27]，对位相减得[-10, -23]，对位相乘得[11,50]等。</p>

<p>最简单的例子：</p>

<p> aa = [3,50]</p>

<p> bb = [16,7]</p>

<p> aa = map(lambda x,y: x+y, aa,bb)</p>

<p> print aa</p>

<p> #output: [19, 57]</p>

<p>累积运算的例子：</p>

<p> acc = [0,0,0,0]</p>

<p> for i in range(3):</p>

<p>  inc = [i<em>3,i+5]</em>2</p>

<p>  acc = map(lambda x,y: x + y, acc, inc)</p>

<p> print acc</p>

<p> #output: [9, 18, 9, 18]</p>

<p> acc = [0,0,0,0]</p>

<p> for i in range(3):</p>

<p>  inc = [i<em>3,i+5]</em>2</p>

<p>  acc = map(lambda x,y: x - y, acc, inc)</p>

<p> print acc</p>

<p> #output: [-9, -18, -9, -18]</p>
]]></content>
  </entry>
  
</feed>
