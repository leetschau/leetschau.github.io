<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Reflection | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/reflection/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-04-09T20:50:36+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SortCompare.time的反射版本]]></title>
    <link href="http://leetschau.github.io/blog/2013/01/18/113138/"/>
    <updated>2013-01-18T11:31:38+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/01/18/113138</id>
    <content type="html"><![CDATA[<p>&ldquo;Algorithms&rdquo; by Robert Sedgewick, p256, SortCompare.time():</p>

<p> public static double time(String alg, Double[] a) throws SecurityException,
   NoSuchMethodException, ClassNotFoundException,
   IllegalArgumentException, IllegalAccessException,
   InvocationTargetException {
  Stopwatch timer = new Stopwatch();
  String originClassName = new Object(){}.getClass().getEnclosingClass().getName();
  String packageName = originClassName.substring(0,
    originClassName.lastIndexOf(&ldquo;.&rdquo;));
  String className = packageName.concat(&ldquo;.&rdquo; + alg);
  Class&lt;?> clazz = Class.forName(className);
  Method sortMethod = clazz.getDeclaredMethod(&ldquo;sort&rdquo;, Comparable[].class);
  Object[] param = { a };
  sortMethod.invoke(null, param);
  return timer.elapsedTime();
 }</p>

<p>这里面注意的有两点，一是在static方法里获取所在类名的方法，二是如何用反射调用参数为数组的方法（见笔记 用反射机制在运行时创建对象并执行方法 ）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用反射机制在运行时创建对象并执行方法]]></title>
    <link href="http://leetschau.github.io/blog/2012/10/30/113230/"/>
    <updated>2012-10-30T11:32:30+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/10/30/113230</id>
    <content type="html"><![CDATA[<h1>根据类名创建对象</h1>

<p>要求：根据运行时得到的类名（字符串）创建对象。</p>

<h2>创建的对象没有参数</h2>

<p> Class&lt;?> clazz = Class.forName(&ldquo;com.foo.BarClass&rdquo;);
 Object date = clazz.newInstance();</p>

<h2>创建对象需要参数</h2>

<p> Class&lt;?> clazz = Class.forName(&ldquo;com.foo.MyClass&rdquo;);
 Constructor&lt;?> constructor = clazz.getConstructor(String.class, Integer.class);
 Object instance = constructor.newInstance(&ldquo;stringparam&rdquo;, 42);</p>

<p>参考：<a href="http://stackoverflow.com/questions/9886266/is-there-a-way-to-instantiate-a-class-by-name-in-java">is there a way to instantiate a class by name in java?</a></p>

<h1>执行方法调用</h1>

<p>对于实例方法，也就是非static方法，用"obj.method()&ldquo;方式调用，获得对象后可以按普通对象执行；对于静态（static）方法，需要用"ClassName.method()"方式调用，需要用到Java反射机制中的Method类，调用方法如下：</p>

<p> String className = &ldquo;edu.princeton.cs.algs4.Selection&rdquo;;
 Class&lt;?> clazz = Class.forName(className);
 System.out.println(&ldquo;Loaded class: &rdquo; + clazz);
 Method m = clazz.getDeclaredMethod(&ldquo;meth&rdquo;, new Class[] { int.class, int.class });
 System.out.println(&ldquo;Got method: &rdquo; + m);
 Object returnValue = m.invoke(null, 1, 5); // equals to &ldquo;Selection.meth(1,5);&rdquo;
 System.out.println(&ldquo;Return value of this method: &rdquo; + returnValue);</p>

<p>被调用的Selection.meth()方法：</p>

<p> public static int meth(int i, int j) {
  System.out.println(&ldquo;result=&rdquo; + (i + j + 10));
  return i + j + 10;
 }</p>

<p>这里要注意的是：</p>

<ol>
<li><p>className必须是包含包名的full name，</p></li>
<li><p>对于静态方法，m.invoke的第一个参数是null，如果是实例方法，第一个参数是执行这个方法的对象obj；</p></li>
</ol>


<h2>如何调用参数是数组的方法</h2>

<p>例如有下面一个方法：</p>

<p> public static void sort(Comparable[] a) {
  int N = a.length;
  for (int i = 0; i &lt; N; i++) {
   for (int j = i; j > 0 &amp;&amp; less(a[j], a[j-1]); j&ndash;) {
    exch(a, j, j-1);
   }
   assert isSorted(a, 0, i);
  }
  assert isSorted(a);
 }</p>

<p>用反射调用这个方法要注意参数列表的写法：</p>

<p> Double[] a = new Double{1000];</p>

<p> Class&lt;?> clazz = Class.forName(className);
 Method sortMethod = clazz.getDeclaredMethod(&ldquo;sort&rdquo;, Comparable[].class);
 Object[] param = { a };
 sortMethod.invoke(null, param);</p>

<p>最后一行如果写为invoke(null, a)会报"wrong number of arguments error"，原因是第3行的声明表明sort方法的参数只有一个，但Method.invoke方法的声明是：</p>

<p> Object invoke(Object obj, Object&hellip; args)</p>

<p>实际上就是invoke(Object obj, Object[] args)，这样invoke(null, a)方法会给sort方法注入1000个参数（而不是a这个数组本身），解决方法就是专门声明param={a}，然后invoke(null, param)。</p>

<p>参考：<a href="http://stackoverflow.com/questions/8189782/wrong-number-of-arguments-error-when-invoking-a-method">http://stackoverflow.com/questions/8189782/wrong-number-of-arguments-error-when-invoking-a-method</a></p>
]]></content>
  </entry>
  
</feed>
