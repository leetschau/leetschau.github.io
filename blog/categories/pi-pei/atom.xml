<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 匹配 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/pi-pei/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-11-11T14:51:43+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[查找匹配括号]]></title>
    <link href="http://leetschau.github.io/blog/2011/09/24/174706/"/>
    <updated>2011-09-24T17:47:06+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/09/24/174706</id>
    <content type="html"><![CDATA[<p>源代码分析时经常要找匹配的括号，Notepad2中实现这个功能的方法是：光标放在一个括号处，【Edit->Special->Find Matching Brace】，要选择到匹配括号处，用【 Edit->Special->Select to Matching Brace 】。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Groovy正则表达式复杂逻辑判断实例]]></title>
    <link href="http://leetschau.github.io/blog/2011/07/23/103345/"/>
    <updated>2011-07-23T10:33:45+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/07/23/103345</id>
    <content type="html"><![CDATA[<p>下面的两个pattern（p1和p2）分别代表了(A or B) and (C or D)和(A and B) or (C and D)的跨行匹配结果，当然还可以用正则表达式构建更复杂的pattern，但这个实例证明了Groovy具备跨行匹配复杂逻辑表达式的能力。</p>

<p> 值得注意的是，多行匹配文本时需要在匹配字符串前加“(?ms)”。</p>

<p> 该实例同时演示了Groovy闭包的使用方法。
 源代码</p>

<p> msg1 = &lsquo;&rsquo;&lsquo;one two three four</p>

<p> five six'&lsquo;&rsquo;</p>

<p> msg2 = &lsquo;&rsquo;&lsquo;Jan Feb Mar</p>

<p> Apr May Jun'&lsquo;&rsquo;</p>

<p> msg3 = &lsquo;&rsquo;&lsquo;one two three</p>

<p> Apr May Jun'&lsquo;&rsquo;</p>

<p> msg4 = &lsquo;&rsquo;&lsquo;Jan Feb Mar</p>

<p> four five six'&lsquo;&rsquo;</p>

<p> p1 = / (?ms) (two|Feb).*(five|May)/</p>

<p> p2 = / (?ms) (two.<em>five)|(Feb.</em>May)/</p>

<p> msgs = [msg1, msg2, msg3, msg4]</p>

<p> patterns = [p1, p2]</p>

<p> patterns.each { pattern-></p>

<p> println &lsquo;pattern is: &rsquo;+pattern</p>

<p> msgs.each { msg-></p>

<p> println &lsquo;msg is: &rsquo;+msg</p>

<p> println &lsquo;match result is:&rsquo;</p>

<p> matcher = msg =~ pattern</p>

<p> if (matcher)</p>

<p> println &ldquo;true&rdquo;</p>

<p> else</p>

<p> println &ldquo;false&rdquo;</p>

<p> println &lsquo;&mdash;&rsquo;</p>

<p> }</p>

<p> println &lsquo;===&rsquo;</p>

<p> }
 运行结果
 pattern is: (?ms)(two|Feb).*(five|May)</p>

<p> msg is: one two three four</p>

<p> five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: one two three</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> four five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<hr />

<p> pattern is: (?ms)(two.<em>five)|(Feb.</em>May)</p>

<p> msg is: one two three four</p>

<p> five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: one two three</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> false</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> four five six</p>

<p> match result is:</p>

<p> false</p>

<hr />

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VIM的跨行查找和匹配数量]]></title>
    <link href="http://leetschau.github.io/blog/2010/09/17/105145/"/>
    <updated>2010-09-17T10:51:45+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/09/17/105145</id>
    <content type="html"><![CDATA[<p>跨行用\n表示，例如 用4\n56可以匹配到：</p>

<p> 4</p>

<p> 56</p>

<p>中，查询一段文本中pattern出现的次数，类似于UltraEdit中的“Count All”功能，用:%s/pattern//gn， 例如统计文档中有多少空格分隔的单词可以使用：:%s/[^ ]+//gn（ []中^开头后跟一个字符表示该字符的补集，例如[^a]表示除a外的所有字符），实际上是利用了s命令的n参数。</p>
]]></content>
  </entry>
  
</feed>
