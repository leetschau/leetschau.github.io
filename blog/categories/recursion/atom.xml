<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Recursion | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/recursion/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-11-11T15:03:30+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[On Tail Recursion]]></title>
    <link href="http://leetschau.github.io/blog/2013/05/23/155951/"/>
    <updated>2013-05-23T15:59:51+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/05/23/155951</id>
    <content type="html"><![CDATA[<p>The essential advantage of tail recursion comparing with ordinary recursion is the efficiency. Why time &amp; space cost of tail recursion is linear while ordinary recursion is more? Chapter 5 of &ldquo;Learn You Some Erlang for Great Good&rdquo; by Fred Hebert gives a very concise and intuitive answer: tail recursion is &ldquo;alone&rdquo;. Following is an example of factorial algorithms to show the difference between these two.</p>

<p>Ordinary Recursion:</p>

<p> fac(N) when N > 0 -> N * fac(N-1).</p>

<p>Tail Recursion:</p>

<p> tail_fac(N, Acc) when N > 0 -> tail_fac(N-1, N*Acc).</p>

<p>So you see, ordinary recursion is &ldquo;func(state N) -> do something transformation of func(state N-1)&rdquo;, while tail recursion is &ldquo;func(state N) -> func(state N-1)&rdquo;. This is exact meaning of &ldquo;alone&rdquo; above.</p>
]]></content>
  </entry>
  
</feed>
