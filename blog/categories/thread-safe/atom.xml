<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Thread-safe | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/thread-safe/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-04-15T10:58:04+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Stream和BlockingQueue的线程安全问题]]></title>
    <link href="http://leetschau.github.io/blog/2012/08/10/094240/"/>
    <updated>2012-08-10T09:42:40+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/08/10/094240</id>
    <content type="html"><![CDATA[<p>一般认为Stream（包括InputStream和OutputStream）不是线程安全的（如 这篇 ），但下面的程序运行多次后未观察到OutputStream.write()方法的原子性被破坏的现象：每个线程向文件输出长度为1000的字符组（从A到），20个线程并发没有出现字符组交错输出。</p>

<p>StreamQueueTest.java
 package streamVsQueue;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStream;
public class StreamQueueTest {
 public static void main(String[] args) {
  OutputStream out = null;
  try {
   out = new FileOutputStream(&ldquo;concurrentout.txt&rdquo;, false);
  } catch (FileNotFoundException e) {
   e.printStackTrace();
  }
  for (int i = 0; i &lt; 20; i++) {
   IntCounter cc = new IntCounter(i, out);
   new Thread(cc).start();
  }
 }
}</p>

<p>IntCounter.java</p>

<p> package streamVsQueue;
import java.io.IOException;
import java.io.OutputStream;
public class IntCounter implements Runnable {
 private final int cnt;
 OutputStream out;
 public IntCounter(int i, OutputStream oup) {
  cnt = i;
  out = oup;
 }
 @Override
 public void run() {
  int bytelen = 1000;
  byte[] buf = new byte[bytelen];
  for (int i = 0; i &lt; bytelen; i++) {
   buf[i] = (byte) (65 + cnt);
  }
  try {
   out.write(buf);
  } catch (IOException e) {
   e.printStackTrace();
  }
 }
}</p>

<p>至于BlockingQueue，文档明确说明是线程安全的，各个读取操作都有内部锁，所以就不测试了，安全起见，新版本的GODU就用这个数据结构吧。</p>
]]></content>
  </entry>
  
</feed>
