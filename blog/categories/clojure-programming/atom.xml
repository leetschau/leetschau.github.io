<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clojure Programming | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/clojure-programming/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-05-10T10:22:47+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Notes About Conway's Game of Life in `Clojure Programming`]]></title>
    <link href="http://leetschau.github.io/blog/2013/10/11/093307/"/>
    <updated>2013-10-11T09:33:07+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/10/11/093307</id>
    <content type="html"><![CDATA[<h1>indexed-step</h1>

<ul>
<li><p>(-> (iterate indexed-step glider) (nth 8) pprint) is equals to (pprint (nth (iterate indexed-step glider) 8));</p></li>
<li><p>(iterate f x) means &ldquo;Return a lazy sequence of x, (f x), (f (f x)) etc, f must be free of side-effects&rdquo;;</p></li>
</ul>


<p>So (indexed-step glider) returns the next state of the board &ldquo;glider&rdquo; based on its current state.</p>

<p>(nth (iterate indexed-step glider) 8) is the 8th step of the transformation. If you want to see the 4th step just modify 8 to 4 in above code snippet.</p>

<p>(->> (iterate indexed-step glider) (take 5) ppr/pprint), equals to (ppr/pprint (take 5 (iterate indexed-step glider))), displays every step of the transformation from origin state to the first translational position.</p>

<p>The result of above code can be verified visually at [<a href="http://www.bitstorm.org/gameoflife/">http://www.bitstorm.org/gameoflife/</a>] (use mouse button to add/remove seed in the panel).</p>

<h1>index-free-step</h1>

<ul>
<li>&ldquo;map&rdquo;, &ldquo;partition&rdquo; and &ldquo;concat&rdquo; create a lazy seq;</li>
</ul>


<p>Why add a (repeat nil) to board in &ldquo;index-free-step&rdquo;?</p>

<h1>step</h1>

<ul>
<li>&ldquo;frequencies&rdquo; receives a collection, returns a map, the key is the item of the collection, the value is the number of times this item appear. So:</li>
</ul>


<p> (frequencies [1 2 3 2 3 4]) => {1 1, 2 2, 3 2, 4 1}</p>

<ul>
<li><p>(mapcat f coll) &lt;=> (apply concat (map f coll));</p></li>
<li><p>&ldquo;for&rdquo; is the Cartesian product. So:</p></li>
</ul>


<p> (for [x [:a :b] y [1 2]] [x y]) => ([:a 1] [:a 2] [:b 1] [:b 2])</p>

<p> (for [[x y] {1 1, 2 2, 3 2, 4 1}] [x y]) => ([1 1] [2 2] [3 2] [4 1])</p>

<p>and &ldquo;(for [[x y] (frequencies [1 2 3 2 3 4]) :when (= y 2)] x)&rdquo; select items which appear 2 times in collection.</p>

<p>Translate example 3-7 to plain text is:</p>

<ol>
<li><p>The live cells are a subset of all neighbours of original live cells;</p></li>
<li><p>Every cell in the neighbour area are expressed as variable &ldquo;loc&rdquo;, while the number of its neighbour is expressed as &ldquo;n&rdquo;;</p></li>
<li><p>To a cell &ldquo;loc&rdquo;, if one of the following conditions are met, it is alive:</p></li>
<li><p>It has 3 neighbours, expressd as (= n 3);</p></li>
<li><p>It has 2 neighbours and it is alive, expressed as (and (= n 2) (cells loc))</p></li>
</ol>


<p>Example 3-7:</p>

<p> (defn step
  [cells]
  (set (for [[loc n] (frequencies (mapcat neighbours cells))
     :when (or (= n 3) (and (= n 2) (cells loc)))]
    loc)))</p>

<h1>stepper</h1>

<ul>
<li><p>To hex-step, the board and cells are all hexagonal, which means every cell has 6 neighbours;</p></li>
<li><p>To every cell (loc) in the neighbour area, if it is alive(tested with (cells loc) in the &ldquo;for&rdquo; function), it&rsquo;s liveness is determined with &ldquo;survive?&rdquo; function: (survive? n); otherwise it&rsquo;s determined with &ldquo;(birth? n)&rdquo;;</p></li>
<li><p>Test 4 step oscillator:</p></li>
</ul>


<p> (def init #{[0 0] [1 1] [1 3] [0 4]})
 (= (-> (iterate hex-step init) (nth 4)) init)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes of `reduce-by` in `Clojure Programming`]]></title>
    <link href="http://leetschau.github.io/blog/2013/10/06/091558/"/>
    <updated>2013-10-06T09:15:58+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/10/06/091558</id>
    <content type="html"><![CDATA[<p>In page 120 of &ldquo;Clojure Programming&rdquo;.</p>

<p>(reduce-by :customer #(+ %1 (:total %2)) 0 orders) =></p>

<p>key-fn: :customer</p>

<p>f: #(+ %1 (:total %2))</p>

<p>init: 0</p>

<p>coll: orders</p>

<p>user=> (doc reduce)</p>

<hr />

<p>clojure.core/reduce
([f coll] [f val coll])
 f should be a function of 2 arguments. If val is not supplied,
 returns the result of applying f to the first 2 items in coll, then
 applying f to that result and the 3rd item, etc. If coll contains no
 items, f must accept no arguments as well, and reduce returns the
 result of calling f with no arguments. If coll has only 1 item, it
 is returned and f is not called. <strong>If val is supplied, returns the
 result of applying f to val and the first item in coll, then
 applying f to that result and the 2nd item, etc. If coll contains no
 items, returns val and f is not called.</strong></p>

<p>According to above definition, summaries is the second argument of reduce ({}), x is the first element of coll (orders).</p>

<p>user=> (doc assoc)</p>

<hr />

<p>clojure.core/assoc
([map key val] [map key val &amp; kvs])
 assoc[iate]. When applied to a map, returns a new map of the
 same (hashed/sorted) type, that contains the mapping of key(s) to
 val(s). When applied to a vector, returns a new vector that
 contains val at index. Note - index must be &lt;= (count vector).</p>

<p>The run the following script in repl:</p>

<p>(def orders</p>

<p> [{:product &ldquo;Clock&rdquo;, :customer &ldquo;Wile Coyote&rdquo;, :qty 6, :total 300}</p>

<p>{:product &ldquo;Dynamite&rdquo;, :customer &ldquo;Wile Coyote&rdquo;, :qty 20, :total 5000}</p>

<p>{:product &ldquo;Shotgun&rdquo;, :customer &ldquo;Elmer Fudd&rdquo;, :qty 2, :total 800}</p>

<p>{:product &ldquo;Shells&rdquo;, :customer &ldquo;Elmer Fudd&rdquo;, :qty 4, :total 100}</p>

<p>{:product &ldquo;Hole&rdquo;, :customer &ldquo;Wile Coyote&rdquo;, :qty 1, :total 1000}</p>

<p>{:product &ldquo;Anvil&rdquo;, :customer &ldquo;Elmer Fudd&rdquo;, :qty 2, :total 300}</p>

<p>{:product &ldquo;Anvil&rdquo;, :customer &ldquo;Wile Coyote&rdquo;, :qty 6, :total 900}])</p>

<p>(defn reduce-by</p>

<p> [key-fn f init coll]</p>

<p> (println &ldquo;key-fn:&rdquo; key-fn)</p>

<p> (println &ldquo;f:&rdquo; f)</p>

<p> (println &ldquo;init:&rdquo; init)</p>

<p> (println &ldquo;coll:&rdquo; coll)</p>

<p> (println &ldquo;==========&rdquo;)</p>

<p> (reduce (fn [summaries x]</p>

<p>   (let [k (key-fn x)]</p>

<pre><code>(println "summaries:" summaries)

(println "k:" k)

(println "x:" x)

(println "(key-fn x):" (key-fn x))

(println "value for k:" (f (summaries k init) x))

(println "---------")

(assoc summaries k (f (summaries k init) x))))
</code></pre>

<p>   {} coll))</p>

<p>(reduce-by :customer #(+ %1 (:total %2)) 0 orders)</p>

<p>And the output:</p>

<p>key-fn: :customer</p>

<p>f: #&lt;core$eval1500$fn<strong>1501 startclojure.core$eval1500$fn</strong>1501@10d78ec></p>

<p>init: 0</p>

<p>coll: [{:total 300, :customer Wile Coyote, :qty 6, :product Clock} {:total 5000, :customer Wile Coyote, :qty 20, :product Dynamite} {:total 800, :customer Elmer Fudd, :qty 2, :product Shotgun} {:total 100, :customer Elmer Fudd, :qty 4, :product Shells} {:total 1000, :customer Wile Coyote, :qty 1, :product Hole} {:total 300, :customer Elmer Fudd, :qty 2, :product Anvil} {:total 900, :customer Wile Coyote, :qty 6, :product Anvil}]</p>

<hr />

<p>summaries: {}</p>

<p>k: Wile Coyote</p>

<p>x: {:total 300, :customer Wile Coyote, :qty 6, :product Clock}</p>

<p>(key-fn x): Wile Coyote</p>

<p>value for k: 300</p>

<hr />

<p>summaries: {Wile Coyote 300}</p>

<p>k: Wile Coyote</p>

<p>x: {:total 5000, :customer Wile Coyote, :qty 20, :product Dynamite}</p>

<p>(key-fn x): Wile Coyote</p>

<p>value for k: 5300</p>

<hr />

<p>summaries: {Wile Coyote 5300}</p>

<p>k: Elmer Fudd</p>

<p>x: {:total 800, :customer Elmer Fudd, :qty 2, :product Shotgun}</p>

<p>(key-fn x): Elmer Fudd</p>

<p>value for k: 800</p>

<hr />

<p>summaries: {Elmer Fudd 800, Wile Coyote 5300}</p>

<p>k: Elmer Fudd</p>

<p>x: {:total 100, :customer Elmer Fudd, :qty 4, :product Shells}</p>

<p>(key-fn x): Elmer Fudd</p>

<p>value for k: 900</p>

<hr />

<p>summaries: {Elmer Fudd 900, Wile Coyote 5300}</p>

<p>k: Wile Coyote</p>

<p>x: {:total 1000, :customer Wile Coyote, :qty 1, :product Hole}</p>

<p>(key-fn x): Wile Coyote</p>

<p>value for k: 6300</p>

<hr />

<p>summaries: {Elmer Fudd 900, Wile Coyote 6300}</p>

<p>k: Elmer Fudd</p>

<p>x: {:total 300, :customer Elmer Fudd, :qty 2, :product Anvil}</p>

<p>(key-fn x): Elmer Fudd</p>

<p>value for k: 1200</p>

<hr />

<p>summaries: {Elmer Fudd 1200, Wile Coyote 6300}</p>

<p>k: Wile Coyote</p>

<p>x: {:total 900, :customer Wile Coyote, :qty 6, :product Anvil}</p>

<p>(key-fn x): Wile Coyote</p>

<p>value for k: 7200</p>

<hr />

<p>Verified on Eclipse Juno SR2 with Counterclockwise plugin, Mint 14 Xfce, 2013-10-6.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes of `Clojure Programming`]]></title>
    <link href="http://leetschau.github.io/blog/2013/09/17/112520/"/>
    <updated>2013-09-17T11:25:20+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/09/17/112520</id>
    <content type="html"><![CDATA[<h1>swap-pairs, p86</h1>

<p>user=> (apply list (range 10))
(0 1 2 3 4 5 6 7 8 9)</p>

<p>user=> (drop 1 (apply list (range 10)))
(1 2 3 4 5 6 7 8 9)</p>

<p>user=> (take-nth 2 (drop 1 (apply list (range 10))))
(1 3 5 7 9)</p>

<p>user=> (take-nth 2 (apply list (range 10)))
(0 2 4 6 8)</p>

<p>user=> (interleave &lsquo;(1 3 5 7 9) &rsquo;(0 2 4 6 8))
(1 0 3 2 5 4 7 6 9 8)</p>

<p>user=> (def list1 (take-nth 2 (drop 1 (apply list (range 10)))))</p>

<h1>&lsquo;user/list1</h1>

<p>user=> (def list2 (take-nth 2 (apply list (range 10))))</p>

<h1>&lsquo;user/list2</h1>

<p>user=> (def empty-list (empty (apply list (range 10))))</p>

<h1>&lsquo;user/empty-list</h1>

<p>user=> (def total-list (interleave list1 list2))</p>

<h1>&lsquo;user/total-list</h1>

<p>user=> (into empty-list total-list)
(8 9 6 7 4 5 2 3 0 1)</p>

<h1>map-map, p86</h1>

<p>hash-map is unsorted collections, while sorted-map is sorted. So you can see the output of the hash-map is unsorted, while that of sorted-map is sorted.</p>

<p>The synopsis of &ldquo;for&rdquo; is &ldquo;(for [k1 v1 k2 v2 &hellip;] (return-value))&rdquo;. So when f is inc, m is (hash-map :z 5 :c 6 :a 0), to &ldquo;(for [[k v] m] [k (f v)])&rdquo;, [k v] is [:z 5], [:c 6] and [&ldquo;:a&rdquo; 0], and the return value is &ldquo;[k (f v)]&rdquo;, thus [:z (inc 5)], [:c (inc 6)] and [:a (inc 0)].</p>

<h1>seq function, p87</h1>

<p>&ldquo;seq&rdquo; function produces a sequence over its argument. But the exact type is different based on the type of its arguments:</p>

<p>user=> (type (seq &lsquo;(1 3 2)))
clojure.lang.PersistentList</p>

<p>user=> (type (seq [1 3 2]))
clojure.lang.PersistentVector$ChunkedSeq
user=> (type (seq {:a 1 :b 2}))
clojure.lang.PersistentArrayMap$Seq</p>

<p>user=> (type (seq #{1 3 2}))
clojure.lang.APersistentMap$KeySeq</p>

<p>user=> (type (seq nil))
nil</p>

<h1>destructuring a lazy seq, p95</h1>

<p> (let [[x &amp; rest] (random-ints 50)] (str (str x) &ldquo; - &rdquo; (str (first rest)) &ldquo; - &rdquo; (second rest)))</p>

<p>realizing random number
realizing random number
realizing random number
&ldquo;23 - 37 - 10&rdquo;</p>

<h1>reduce-by, p118</h1>

<p>See Notes of &ldquo;reduce-by&rdquo; in &ldquo;Clojure Programming&rdquo; ;</p>

<p>pprint can be used directly in clojure repl. If you want use it in a script, write your namespace declaration like this:</p>

<p> (ns startclojure.core (:require clojure.pprint))</p>

<p>Then you can use it as (clojure.pprint/pprint val);</p>

<h1>assoc-in, get-in vs assoc, get, p120</h1>

<p>=> (assoc-in {} [:a :b] 321)</p>

<p>{:a {:b 321}}</p>

<p>=> (assoc {} [:a :b] 321)</p>

<p>{[:a :b] 321}</p>

<p>=> (get-in {:a {:b 321}} [:a :b])</p>

<p>321</p>

<p>=> (get {:a {:b 321}} [:a :b])</p>

<p>nil</p>

<p>=> (get {[:a :b] 321} [:a :b])</p>

<p>321</p>

<p>=> ({[:a :b] 321} [:a :b])</p>

<p>321</p>

<p>=> (get-in {[:a :b] 321} [:a :b])</p>

<p>nil</p>

<p>=> (get-in {:a 23} :a)</p>

<p>IllegalArgumentException &hellip;</p>

<p>=> (get {:a 23} :a)</p>

<p>23</p>
]]></content>
  </entry>
  
</feed>
