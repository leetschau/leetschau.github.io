<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 网络 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/wang-luo/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-10-01T21:14:19+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux中网络相关的配置文件]]></title>
    <link href="http://leetschau.github.io/blog/2012/09/28/165932/"/>
    <updated>2012-09-28T16:59:32+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/09/28/165932</id>
    <content type="html"><![CDATA[<h1>/etc/hosts</h1>

<pre><code>10.31.1.71 servername1
10.31.1.52 servername2
</code></pre>

<p>当本机连接servername1时，通过这个文件将主机名映射为ip地址，相当于本机本部的DNS服务，对该文件的详细说明见Richard Petersen &ldquo;Linux: The Complete Reference&rdquo; p723: Identifying Hostnames: /etc/hosts。</p>

<h1>/etc/sysconfig/network</h1>

<p>用于定义主机的整体网络配置。</p>

<p> # /etc/sysconfig/network-scripts/ifcfg-eth0</p>

<p>专门定义eth0的属性，如果有多个网卡， network-scripts下可能还有ifcfg-eth1,ifcfg-eth2等几个文件。</p>

<h1>设置网卡eth0的IP地址</h1>

<pre><code>ifconfig &lt;eth0&gt; 10.31.1.251 netmask 255.255.255.0 up 
</code></pre>

<p>其中eth0是网卡名称，要根据ifconfig中列出的具体的网卡名字确定。</p>

<h1>修改主机名</h1>

<pre><code>hostname newHostname 
</code></pre>

<p>查询当前主机名：hostname</p>

<p>参见<a href="http://serverfault.com/questions/260034/what-is-the-difference-between-these-two-network-configuration-files">What is the difference between these two network configuration files?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mina学习笔记]]></title>
    <link href="http://leetschau.github.io/blog/2010/05/28/110522/"/>
    <updated>2010-05-28T11:05:22+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/05/28/110522</id>
    <content type="html"><![CDATA[<p>1 Mina 在客户端和服务端的工作流程是什么？
 1.1 客户端通信过程
 1. 通过 SocketConnector 同服务器端建立连接
 2. 链接建立之后 I/O 的读写交给了 I/O Processor 线程， I/O Processor 是多线程的
 3. 通过 I/O Processor 读取的数据经过 IoFilterChain 里所有配置的 IoFilter ， IoFilter 进行消息的过滤，格式的转换，在这个层面可以制定一些自定义的协议
 4. 最后 IoFilter 将数据交给 Handler 进行业务处理，完成了整个读取的过程
 5. 写入过程也是类似，只是刚好倒过来，通过 IoSession.write 写出数据，然后 Handler 进行写入的业务处理，处理完成后交给 IoFilterChain ，进行消息过滤和协议的转换，最后通过 I/O Processor 将数据写出到 socket 通道
 2 IoAcceptor 与 IoConnector 的区别是什么？
 2.1 Acceptor
 作为服务器端的连接接受者， SocketAcceptor 用来监听端口，同客户端建立连接，连接建立之后的 I/O 操作全部交给 IoProcessor 进行处理
 IoAcceptor acceptor = new NioSocketAcceptor();
 acceptor.bind( new InetSocketAddress(PORT) );
 2.2 Connector
 作为连接客户端， SocketConector 用来和服务器端建立连接，连接成功，创建 IoProcessor Thread （不能超过指定的 processorCount ）， Thread 由指定的线程池进行管理， IoProcessor 利用 NIO 框架对 IO 进行处理，同时创建 IoSession 。连接的建立是通过 Nio 的 SocketChannel 进行。
 NioSocketConnector connector = new NioSocketConnector(processorCount);
 ConnectFuture future = connector.connect(new InetSocketAddress(HOSTNAME, PORT)); 建立一个 I/O 通道
 3 IoService 与 IoSession 的区别是什么？
 IoSession 是用来保持 IoService 的上下文，一个 IoService 在建立 Connect 之后建立一个 IoSession （一个连接一个 session ）， IoSession 的生命周期从 Connection 建立到断开为止。
 IoSession 做两件事情：
 1. 通过 IoSession 可以获取 IoService 的所有相关配置对象 ( 持有对 IoService ， Processor 池， SocketChannel ， SessionConfig 和 IoService.IoHandler 的引用 )
 2. 通过 IoSession.write 是数据写出的入口</p>

<p> 详见： jjvv 在 javaeye 上的博文： MINA 原理
 <a href="http://www.javaeye.com/topic/599925">http://www.javaeye.com/topic/599925</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java网络通信程序（一对多）]]></title>
    <link href="http://leetschau.github.io/blog/2010/05/07/111652/"/>
    <updated>2010-05-07T11:16:52+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/05/07/111652</id>
    <content type="html"><![CDATA[<p>在前文“Java网络通信程序（一对一）”基础上，实现了一个服务器为多个客户端提供服务的功能，本文基于[1]之10.3.9节例10-4和10-5，修正了一些变量递增错误，删去了两个无用的变量。本文使用的客户端程序与前文完全相同。
MultiTalkServer.java倒数第6行代码表明代码中可以直接使用同一目录下其他public类（这里是ServerThread类），无需import。
[1] 陈明：Java语言程序设计，清华大学出版社，2009.6</p>

<p> MultiTalkServer.java
import java.io.<em>;
import java.net.</em>;
public class MultiTalkServer{
 static int clientNum = 1;
 public static void main(String args[]) throws IOException {
 ServerSocket serverSocket = null;
 boolean listening = true;
 try {
  serverSocket = new ServerSocket(4700);
  System.out.println(&ldquo;MultiTalkServer Started.\n&rdquo;);
 }
 catch (IOException e){
  System.out.println(&ldquo;Could not listen to port 4700.&rdquo;);
  System.exit(-1);
 }
 while (listening) {
  new ServerThread(serverSocket.accept(), clientNum).start(); //直接引用同一文件夹下的其他公共类
  clientNum++;
 }
 serverSocket.close();
 }
}</p>

<p> ServerThread.java
import java.io.<em>;
import java.net.</em>;
 public class ServerThread extends Thread {
 Socket socket = null;
 int clientNum;
 public ServerThread(Socket socket, int num){
 this.socket = socket;
 clientNum = num;
 }
 public void run(){
 try{
  String line;
  BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream()));
  PrintWriter os = new PrintWriter(socket.getOutputStream());
  System.out.println(&ldquo;Connected to Client #&rdquo;+clientNum+&ldquo;.&rdquo;);
  System.out.println();
  do{
  line = is.readLine();
  System.out.println(&ldquo;Client #&rdquo;+clientNum+&ldquo; says: &rdquo;+line);
  System.out.println(&ldquo; To Client&rdquo;+clientNum+&ldquo;: you said: &rdquo;+line);
  System.out.println();
  os.println(&ldquo;You said: &rdquo;+line);
  os.flush();
  } while (! line.equals(&ldquo;bye&rdquo;));
  os.close();
  is.close();
  socket.close();
 }
 catch (Exception e){
  System.out.println(&ldquo;Error:&rdquo;+e);
 }
 }
}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java网络通信程序（一对一）]]></title>
    <link href="http://leetschau.github.io/blog/2010/05/07/110500/"/>
    <updated>2010-05-07T11:05:00+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/05/07/110500</id>
    <content type="html"><![CDATA[<p>本文是基于[1]之10.3.8节的阅读笔记，文末的两个java程序改自该节例10-2和10-3。</p>

<p> Client/Server结构的Java程序由两个独立的程序组成，每个程序的核心功能都由4个对象相互协作实现：
 1 Socket，这是网络通信的核心；
 2 信息发送者：是一个PrintWriter对象，与Socket的输出流绑定，负责发送信息，见Server程序第26行，Client程序第12行；
 3 信息接收者：是一个BufferedReader对象，首先与Socket的输入流绑定，然后将输入的字节流转换为字符流，见Server程序第25行，Client程序第13行；
 4 用户输入处理器：这个对象处理本地用户的输入，将输入字符串以合适的形式保存或者展现，不涉及网络，服务端程序代码见27行，客户端见11行；
之所以接收者需要加一层字节流到字符流的转换（用InputStreamReader实现），是因为网络传输的字节而非字符。</p>

<p> 这类程序的基本结构由4个步骤组成：
 1 创建Socket，Server端可分为两个子步骤（见程序第8-23行），第一步是创建一个ServerSocket对象，第二步是用它的accept方法在某一端口监听，等待客户端连接（程序运行到这里进入等待状态，也就是书中所谓的“阻塞”，在未收到客户端连接之前，不运行后面的代码）；Client端比较简单（见程序第8行），创建一个Socket对象就OK了；
 2 为Socket配置信息发送和接收者，服务端程序代码见25、26行，客户端见12、13行；
 3 开始进行信息传递，代码见第29-36行（服务端）和15-22行（客户端），服务端运行到第30行is.readLine()等待socket的输入流，进入等待状态，与此同时客户端运行到第17行sin.readLine()等待用户输入，例如用户输入'aa'并回车，则程序执行到第20行is.readLine()（第20行）进入等待socket输入流状态，同时服务端收到了客户端os.flush()发送的信息并打印出来（第30行），得到用户输入（第32行）后向客户端发送（第35行），本次通信完成，客户端得到了socket的输出流后打印出来（第20行），本次通信完成。以上就此一次完整的do while循环内容。
 4 通信结束，关闭Socket，见第37-46行（服务端）和24-31行（客户端）。</p>

<p>[1] 陈明：Java语言程序设计，清华大学出版社，2009.6</p>

<p> TalkServer.java（服务端程序）
01 import java.io.<em>;
02 import java.net.</em>;
03
04 public class TalkServer {
05
06 public static void main(String[] args) {
07 try{
08  ServerSocket server = null;
09  try{
10  server = new ServerSocket(4700);
11  System.out.println(&ldquo;Server Started.&rdquo;);
12  }
13  catch(Exception e){
14  System.out.println(&ldquo;Can not listen to:&rdquo;+e);
15  }
16  Socket socket = null;
17  try{
18  socket = server.accept();
19  System.out.println(&ldquo;Connected to Client.&rdquo;);
20  }
21  catch(Exception e){
22  System.out.println(&ldquo;Error:&rdquo;+e);
23  }
24  String line;
25  BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream()));
26  PrintWriter os = new PrintWriter(socket.getOutputStream());
27  BufferedReader sin = new BufferedReader(new InputStreamReader(System.in));
28  System.out.println();
29  do{
30  System.out.println(&ldquo;Client &rdquo;+is.readLine());
31  System.out.println(&ldquo;To Client:&rdquo;);
32  line = sin.readLine();
33  System.out.println();
34  os.println(line);
35  os.flush();
36  } while(! line.equals(&ldquo;bye&rdquo;));
37  os.close();
38  is.close();
39  socket.close();
40  server.close();
41 }
42 catch (Exception e){
43  System.out.println(&ldquo;Error:&rdquo;+e);
44 }
45 }
46 }
 TalkClient.java（客户端程序）
01 import java.io.<em>;
02 import java.net.</em>;
03
04 public class TalkClient {
05
06 public static void main(String[] args) {
07 try {
08 Socket socket = new Socket(&ldquo;127.0.0.1&rdquo;,4700);
09 System.out.println(&ldquo;Connected to Server.&rdquo;);
10 System.out.println();
11 BufferedReader sin = new BufferedReader(new InputStreamReader(System.in));
12 PrintWriter os = new PrintWriter(socket.getOutputStream());
13 BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream()));
14 String readline;
15 do{
16  System.out.print(&ldquo;To Server:&rdquo;);
17  readline = sin.readLine();
18  os.println(readline);
19  os.flush();
20  System.out.println(&ldquo;Server says:&rdquo;+is.readLine());
21  System.out.println();
22 }
23 while (! readline.equals(&ldquo;bye&rdquo;));
24 os.close();
25 is.close();
26 }
27 catch(Exception e){
28 System.out.println(&ldquo;Error&rdquo;+e);
29 }
30 }
31 }</p>
]]></content>
  </entry>
  
</feed>
