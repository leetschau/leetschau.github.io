<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-10-01T21:14:19+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[能够进行多段文本匹配的NFA改良算法]]></title>
    <link href="http://leetschau.github.io/blog/2013/03/31/231152/"/>
    <updated>2013-03-31T23:11:52+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/03/31/231152</id>
    <content type="html"><![CDATA[<p>下面的代码基于NFA算法实现了在多段字符串中匹配正则表达式，对比NFA算法可以看到它将pc由局部变量提升为类成员，以保存中间匹配状态，另外在匹配成功后将pc恢复到null状态。实际使用中，此类还应该增加一个"reset"方法，将pc值置为null，以便用户可以显式要求重新开始匹配。</p>

<p> public class MultiSegmentNFA {
  private final Digraph G; // digraph of epsilon transitions
  private final String regexp; // regular expression
  private final int M; // number of characters in regular expression
  private Bag<Integer> pc = null;
  public MultiSegmentNFA(String regexp) {
   &hellip; // same as NFA
  }
  public boolean recognizes(String target) {
   if (pc == null) {
    DirectedDFS dfs = new DirectedDFS(G, 0);
    pc = new Bag<Integer>();
    for (int v = 0; v &lt; G.V(); v++)
     if (dfs.marked(v))
      pc.add(v);
   }
   for (int i = 0; i &lt; target.length(); i++) {
    Bag<Integer> match = new Bag<Integer>();
    for (int v : pc) {
     if (v == M)
      continue;
     if ((regexp.charAt(v) == target.charAt(i))
       || regexp.charAt(v) == &lsquo;.&rsquo;)
      match.add(v + 1);
    }
    DirectedDFS dfs = new DirectedDFS(G, match);
    pc = new Bag<Integer>();
    for (int v = 0; v &lt; G.V(); v++)
     if (dfs.marked(v))
      pc.add(v);
    if (pc.size() == 0)
     return false;
   }
   for (int v : pc)
    if (v == M) {</p>

<pre><code> pc = null; 
 return true;

} 
</code></pre>

<p>   return false;
  }</p>

<p>  public static void main(String[] args) {
   LinkedList<String> msgs = new LinkedList<String>();
   msgs.offer(&ldquo;welcome lonely logoout&rdquo;);
   msgs.offer(&ldquo;to flog&rdquo;);
   msgs.offer(&ldquo;into a fog&rdquo;);
   String token = &ldquo;outto&rdquo;;  // 这个目标由第1和第2个字符串拼接而成
   String pat = &ldquo;(.<em>&rdquo; + token + &ldquo;.</em>)&rdquo;;
   MultiSegmentNFA mnfa = new MultiSegmentNFA(pat);
   String target = msgs.poll();
   while (target != null) {
    if (mnfa.recognizes(target)) {
     break;
    }
    target = msgs.poll();
   }
   if (target == null) {
    System.out.println(&ldquo;cannot find &rdquo; + token + &ldquo; in msgs.&rdquo;);
   } else {
    System.out.println(&ldquo;find pat in &lt;&rdquo; + target + &ldquo;>&rdquo;);
   }
  }
 }</p>

<p>Note: Java的Pattern类使用的就是基于NFA的搜索算法，见JDK 6文档java.util.regex.Pattern的"Comparison to Perl 5"一节。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NFA算法笔记]]></title>
    <link href="http://leetschau.github.io/blog/2013/03/31/215259/"/>
    <updated>2013-03-31T21:52:59+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/03/31/215259</id>
    <content type="html"><![CDATA[<p>NFA(Nondeterministic finite-state automata)是一种在字符串中寻找正则表达式匹配的算法，优点是查找文本的指针不回退，适用于在网络传输的报文中寻找正则表达式描述的目标（因为网络传输中报文是被分段接收的，且分段的方式不确定），在Robert的"Algorithms"第5.4节"Regular Expressions"中有详细介绍。</p>

<p>NFA算法可以分为定义和执行两部分，定义阶段和执行阶段。</p>

<p>定义阶段是将要查找的正则表达式（String类型）转换为一个有向图（Digraph类型），该图中的边是所有可以进行的空转换（见p795倒数第2行），定义阶段在书中"Building an NFA corresponding to an RE"一节，图示见p803，代码见p802），在代码表现为以一个正则表达式字符串为参数的NFA构造函数；</p>

<p>执行阶段就是判断待处理的文本中是否含有目标正则表达式（见"Simulating an NFA"一节，图示见p798），整个过程是一个循环过程，每次循环待处理文本指针前进一个字符，这次循环由两步组成，首先根据当前正则表达式指针所处位置（最初位置都是0）算出所有空转换可达位置（借助深度优先算法DirectedDFS，可达位置保存在变量pc中），然后将所有可达位置上的字符与待处理文本指针处的字符比较，如果一样则把正则表达式指针的后一位保存在变量match中。然后以match为初始位置重新构造DirectedDFS对象，进而得到可达位置集合pc，然后从中筛选匹配上的位置，如此循环，直到待处理文本指针到达文本尾部，如果pc中有正则表达式长度的那个元素（代表匹配成功的位置，书中代码用类成员M表示），说明匹配正则表达式成功，否则失败。</p>

<p>需要说明的是，从所有可达状态pc中筛选匹配上位置并放入match中之前，需要先将值为M的元素去掉，以用"(A<em>B|AC)D"匹配"AABDC"为例，当目标文本指针等于4时，即指向"AABDC"的最后一个字符C时，pc中已经包含了最终状态11（正则串"((A</em>B|AC)D)&ldquo;的长度），因为AABD符合&rdquo;(A<em>B|AC)D"，但最后的C导致整个文本不匹配"(A</em>B|AC)D"，所以结果仍然是匹配失败。</p>

<p>测试代码如下：</p>

<p> String token = &ldquo;(A<em>B|AC)D&rdquo;;
 String regexp = &ldquo;(&rdquo; + token + &ldquo;)&rdquo;;
 // when test if target string &ldquo;contains&rdquo; regex, regexp = &ldquo;(.</em>&rdquo; + token + &ldquo;.*)&rdquo;
 NFA nfa = new NFA(regexp);
 String target = &ldquo;AABDC&rdquo;;
 if (nfa.recognizes(target)) {
  System.out.println(&ldquo;match: &rdquo; + target);
 } else {
  System.out.println(&ldquo;not match: &rdquo; + target);
 }</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计算成本图像演示方法的改进]]></title>
    <link href="http://leetschau.github.io/blog/2013/01/27/132736/"/>
    <updated>2013-01-27T13:27:36+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/01/27/132736</id>
    <content type="html"><![CDATA[<p>本文在笔记 BinarySearchST计算成本的测试代码 的基础上，尝试将成本计算和图像演示等功能封装在一个单独的类中，尽量降低对被测试类的改动。</p>

<h1>测试方法</h1>

<ol>
<li><p>在被测类中增加一个成员及其getter；</p></li>
<li><p>在FrequencyCounter类中增加：st.getVisitTimes().drawCostCurve();</p></li>
</ol>


<h1>两个实例</h1>

<h2>BinarySearchST</h2>

<p> public class BinarySearchST<Key extends Comparable<Key>, Value> {
  private final VisitTimeCounter vtc = new VisitTimeCounter();
  public VisitTimeCounter getVisitTimes() {
   return vtc;
  }
  public int rank(Key key) {
   int lo = 0, hi = N - 1;
   while (lo &lt;= hi) {
    int m = lo + (hi - lo) / 2;
    vtc.addVisitTimes();
    int cmp = key.compareTo(keys[m]);
    if (cmp &lt; 0)
     hi = m - 1;
    else if (cmp > 0)
     lo = m + 1;
    else
     return m;
   }
   return lo;
  }
  public void put(Key key, Value val) {
   if (val == null) {
    delete(key);
    return;
   }
   int i = rank(key);
   if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) {
    vtc.putComplete();
    vals[i] = val;
    return;
   }
   if (N == keys.length)
    resize(2 * keys.length);
   for (int j = N; j > i; j&ndash;) {
    keys[j] = keys[j - 1];
    vals[j] = vals[j - 1];
    vtc.addVisitTimes();
   }
   keys[i] = key;
   vals[i] = val;
   N++;
   vtc.putComplete();
   assert check();
  }
 }</p>

<p>对原版BinarySearchST类的修改包括增加了一个成员（vtc）和它的getter，在rank和put中各加了一个vtc.addVisitTimes()表示查询和插入操作中对数组的访问，以及put中两处vtc.putComplete()，表示在命中和未命中两种情况下将本次put的访问次数存入数组记录中。</p>

<p>下面是VisitTimeCounter类：</p>

<p> public class VisitTimeCounter {
  private int visitTimesInsidePut = 0; // 一次put操作当中的数组访问次数
  private final List<Integer> visitTimesInAllPut = new ArrayList<Integer>(); // 各次put的访问次数汇总保存在这里
  public void addVisitTimes() {
   visitTimesInsidePut++;
  }
  public void putComplete() {
   visitTimesInAllPut.add(visitTimesInsidePut);
   visitTimesInsidePut = 0;
  }
  public void drawCostCurve() {
   int maxComp = 0;
   for (Integer i : visitTimesInAllPut) {
    if (i > maxComp) {
     maxComp = i;
    }
   }
   StdOut.println(&ldquo;matrix scale: &rdquo; + visitTimesInAllPut.size() + &ldquo;, &rdquo;
     + maxComp);
   VisualAccumulator va = new VisualAccumulator(visitTimesInAllPut.size(),
     maxComp);
   for (int t = 0; t &lt; visitTimesInAllPut.size(); t++) {
    va.addDataValue(visitTimesInAllPut.get(t));
   }
  }
 }</p>

<p>FrequencyCounter类中演示成本只需要一条语句：</p>

<p> BinarySearchST&lt;String, Integer> st = new BinarySearchST&lt;String, Integer>(); // copy from original codes</p>

<p> st.getVisitTimes().drawCostCurve();</p>

<h2>BST</h2>

<p>即二叉查找树（binary search tree），原版代码见algs4-package.jar的BST.java类。</p>

<p> public class BST<Key extends Comparable<Key>, Value> {
  private final VisitTimeCounter vtc = new VisitTimeCounter();
  public VisitTimeCounter getVisitTimes() {
   return vtc;
  }
  public void put(Key key, Value val) {
   if (val == null) {
    delete(key);
    return;
   }
   root = put(root, key, val);
   vtc.putComplete();
   assert check();
  }
  private Node put(Node x, Key key, Value val) {
   if (x == null)
    return new Node(key, val, 1);
   int cmp = key.compareTo(x.key);
   vtc.addVisitTimes();
   if (cmp &lt; 0)
    x.left = put(x.left, key, val);
   else if (cmp > 0)
    x.right = put(x.right, key, val);
   else
    x.val = val;
   x.N = 1 + size(x.left) + size(x.right);
   return x;
  }
  private int rank(Key key, Node x) {
   if (x == null)
    return 0;
   int cmp = key.compareTo(x.key);
   vtc.addVisitTimes();
   if (cmp &lt; 0)
    return rank(key, x.left);
   else if (cmp > 0)
    return 1 + size(x.left) + rank(key, x.right);
   else
    return size(x.left);
  }
 }</p>

<p>查找成本体现在rank方法中，插入时每次访问的记录体现在private Node put方法中，总次数的记录体现在public void put方法中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BinarySearchST计算成本的测试代码]]></title>
    <link href="http://leetschau.github.io/blog/2013/01/26/231249/"/>
    <updated>2013-01-26T23:12:49+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/01/26/231249</id>
    <content type="html"><![CDATA[<p>下面是在原有BinarySearchST类上的修改，增加了两个成员（visitTimes与visitTime）和一个方法（getComparisionTimes），查找的成本主要体现在rank方法中的“cmp=key.compareTo(keys[m])”，在这一句后面加上visitTime++来标记访问次数增加了一次；写入的成本体现在put方法的两个位置，当key已经在keys中时，本次put的总成本是visitTime+1，当key不在keys数组中时（增加一个新元素），每移动一个元素，visitTime要加1，注意每次put操作记录结束后，除了要将次数存入visitTimes数组，还要将visitTime清零。</p>

<p>另外下面的代码省略了与原BinarySearchST类相同的成员和方法。</p>

<p> public class BinarySearchST<Key extends Comparable<Key>, Value> {
  private final List<Integer> visitTimes = new ArrayList<Integer>(); // 每次put访问数组的次数的集合
  int visitTime = 0; // 一次put操作中访问数组的次数计数器
  public Value get(Key key) {
   if (isEmpty())
    return null;
   int i = rank(key);
   visitTime++;
   if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0)
    return vals[i];
   return null;
  }
  public int rank(Key key) {
   int lo = 0, hi = N - 1;
   while (lo &lt;= hi) {
    int m = lo + (hi - lo) / 2;
    int cmp = key.compareTo(keys[m]);
    visitTime++;
    if (cmp &lt; 0)
     hi = m - 1;
    else if (cmp > 0)
     lo = m + 1;
    else {
     return m;
    }
   }
   return lo;
  }
  public void put(Key key, Value val) {
   if (val == null) {
    delete(key);
    return;
   }
   int i = rank(key);
   if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) {
    vals[i] = val;
    visitTimes.add(visitTime + 1); // 查找了visitTime次，写入的成本是1
    visitTime = 0;
    return;
   }
   if (N == keys.length)
    resize(2 * keys.length);
   for (int j = N; j > i; j&ndash;) {
    keys[j] = keys[j - 1];
    vals[j] = vals[j - 1];
    visitTime++;
   }
   keys[i] = key;
   vals[i] = val;
   N++;
   visitTimes.add(visitTime);
   visitTime = 0;
   assert check();
  }
  public List<Integer> getComparisionTimes() {
   return visitTimes;
  }
 }</p>

<p>计算成本的图像演示代码FrequencyCounter类见笔记 SequentialSearchST算法成本的图形演示 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SequentialSearchST算法成本的图形演示]]></title>
    <link href="http://leetschau.github.io/blog/2013/01/24/155123/"/>
    <updated>2013-01-24T15:51:23+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/01/24/155123</id>
    <content type="html"><![CDATA[<p>中文版238页图3.1.3演示了SequentialSearchST算法中每次写入单词数量（put方法中）时需要进行的比较次数，也就是此算法的成本，但书中没有生成此图的代码，下面是我自己的实现（第一个是新增的类，后两个是修改的类）：</p>

<p> package edu.princeton.cs.algs4;
 public class VisualAccumulator {
  private double total;
  private int N;
  public VisualAccumulator(int trials, double max) {
   StdDraw.setXscale(0, trials);
   StdDraw.setYscale(0, max);
   StdDraw.setPenRadius(.005);
  }
  public void addDataValue(double val) {
   N++;
   total += val;
   StdDraw.setPenColor(StdDraw.DARK_GRAY);
   StdDraw.point(N, val);
   StdDraw.setPenColor(StdDraw.RED);
   StdDraw.point(N, total / N);
   StdOut.println(&ldquo;Red point value:&rdquo; + total / N);// 平均比较次数
  }
  public double mean() {
   return total / N;
  }
  @Override
  public String toString() {
   return &ldquo;Mean (&rdquo; + N + &ldquo; values): &rdquo; + String.format(&ldquo;%7.5f&rdquo;, mean());
  }
  public static void main(String[] args) {
   int T = 300;
   VisualAccumulator a = new VisualAccumulator(T, 1.0);
   for (int t = 0; t &lt; T; t++) {
    a.addDataValue(StdRandom.random());
   }
   StdOut.println(a);
  }
 }</p>

<p> public class SequentialSearchST&lt;Key, Value> {
  private final List<Integer> compareTimes = new ArrayList<Integer>();
  public List<Integer> getComparisionTimes() {
   return compareTimes;
  }
  public void put(Key key, Value val) {
   int compareTime = 0;
   if (val == null) {
    compareTimes.add(1);
    delete(key);
    return;
   }
   for (Node x = first; x != null; x = x.next) {
    compareTime++;
    if (key.equals(x.key)) {
     x.val = val;
     compareTimes.add(compareTime);
     return;
    }
   }
   first = new Node(key, val, first);
   N++;
   compareTimes.add(compareTime);
  }
  public static void main(String[] args) {
   StdIn2.setInputFile(&ldquo;data/tale.txt&rdquo;);
   SequentialSearchST&lt;String, Integer> st = new SequentialSearchST&lt;String, Integer>();
   for (int i = 0; !StdIn2.isEmpty(); i++) {
    String key = StdIn2.readString();
    st.put(key, i);
   }
   List<Integer> comparisionTimes = st.getComparisionTimes();
   VisualAccumulator va = new VisualAccumulator(comparisionTimes.size(), 1.0);
   for (int t = 0; t &lt; comparisionTimes.size(); t++) {
    va.addDataValue(comparisionTimes.get(t));
   }
   for (String s : st.keys())
    StdOut.println(s + &ldquo; &rdquo; + st.get(s));
  }
 }</p>

<p> public class FrequencyCounter {
  public static void main(String[] args) {
   StdIn2.setInputFile(&ldquo;data/tale.txt&rdquo;);
   int distinct = 0, words = 0;
   int minlen = 8; // this is the first parameter
   SequentialSearchST&lt;String, Integer> st = new SequentialSearchST&lt;String, Integer>();
   while (!StdIn2.isEmpty()) {
    String key = StdIn2.readString();
    if (key.length() &lt; minlen)
     continue;
    words++;
    if (st.contains(key)) {
     st.put(key, st.get(key) + 1);
    } else {
     st.put(key, 1);
     distinct++;
    }
   }
   String max = &ldquo;&rdquo;;
   st.put(max, 0);
   for (String word : st.keys()) {
    if (st.get(word) > st.get(max))
     max = word;
   }
   StdOut.println(max + &ldquo; &rdquo; + st.get(max));
   StdOut.println(&ldquo;distinct = &rdquo; + distinct);
   StdOut.println(&ldquo;words = &rdquo; + words); // 以上是原始版本的代码，修改了获取输入的方法
   List<Integer> comparisionTimes = st.getComparisionTimes(); // 获取原始成本数据
   int maxComp = 0;
   for (Integer i : comparisionTimes) {
    if (i > maxComp) {
     maxComp = i;
    }
   } // 获得原始成本最大值，以确定画布的Y轴高度
   VisualAccumulator va = new VisualAccumulator(comparisionTimes.size(), maxComp);
   for (int t = 0; t &lt; comparisionTimes.size(); t++) {
    va.addDataValue(comparisionTimes.get(t));
   } // 画图
  }
 }</p>

<p>以上VisualAccumulator是完整的类，SequentialSearchST只写出了新增的属性compareTimes及其get方法，和修改后的put和main方法；FrequencyCounter类中修改后的main方法，</p>
]]></content>
  </entry>
  
</feed>
