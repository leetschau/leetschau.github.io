<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 搜索 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/sou-suo/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-05-26T17:50:21+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Evernote中搜索笔记的方法]]></title>
    <link href="http://leetschau.github.io/blog/2011/12/14/105928/"/>
    <updated>2011-12-14T10:59:28+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/12/14/105928</id>
    <content type="html"><![CDATA[<p>如果要精确匹配，用双引号括起来，例如在搜索框里输入“start.suffix”，会搜出包含单独的start的笔记，要搜只含“start.suffix”的笔记，应该在搜索框里输入“"start.suffix"”；</p>

<p>搜索多个关键词可以用空格隔开；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Everything搜索笔记]]></title>
    <link href="http://leetschau.github.io/blog/2011/10/07/100515/"/>
    <updated>2011-10-07T10:05:15+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/10/07/100515</id>
    <content type="html"><![CDATA[<p>搜索选项
Search目录下有4个选项，分别是Match Case, Match Whole Word, Match Path和Enable Regex，其中的Match Path是指当搜索目标为C:\时，所有C盘下的文件都会被找到。
 在特定目录中查找
Everything认为多个关键词之间的空格表示 AND 关系，所以可以用这个约定实现特定目录中的查找： （全部或者部分） 路径名&lt;空格>keyword 。</p>

<p>例如对于F:\warez\Develop\Java\java_ee_sdk-5_01-solaris-i586.bin文件，如下方法都能找到：</p>

<p> java solaris</p>

<p> java solaris bin</p>

<p> f:\warez solaris</p>

<p> java<em>solaris</em></p>

<p> java* solaris</p>

<p>但 java*solaris 是查不到的，因为这个表达式要求文件名必须以solaris结尾。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在队列中寻找字符串算法]]></title>
    <link href="http://leetschau.github.io/blog/2010/08/10/203539/"/>
    <updated>2010-08-10T20:35:39+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/08/10/203539</id>
    <content type="html"><![CDATA[<p>在一个队列destQ中，从前向后搜索是否有字符串flag，下面是算法实现以及测试程序。回溯功能暂未实现。</p>

<p> private  int findFlag( final LinkedBlockingQueue<Byte> destQ,</p>

<p> final String flag) {</p>

<p> byte [] flagArr = flag.getBytes();</p>

<p> Byte[] destArr = destQ.toArray( new Byte[0]);</p>

<p> int matchCount = 0; // 已匹配的字节数</p>

<p> int flagPos = -1; // 标志末尾的编号</p>

<p> int i = 0;</p>

<p> int  backupIndex = 0; // 用于回溯的索引</p>

<p> while (i &lt;= destQ.size()) {</p>

<p> if (flag.length() &lt;= matchCount) {</p>

<p> flagPos = i;</p>

<p> break ;</p>

<p> } else {</p>

<p> if (destArr[i] == flagArr[matchCount]) {</p>

<p> matchCount++;</p>

<p> } else {</p>

<p> matchCount = 0;</p>

<p> // i = backupIndex;</p>

<p> }</p>

<p> }</p>

<p> i = i + 1;</p>

<p> if (matchCount == 1) {</p>

<p> backupIndex = i;</p>

<p> }</p>

<p> }</p>

<p> return flagPos;</p>

<p> }</p>

<p> @Test</p>

<p> public  void runFindFlag() {</p>

<p> LinkedBlockingQueue<Byte> analyzerBuffer = new LinkedBlockingQueue<Byte>();</p>

<p> for ( int i = 33; i &lt; 123; i++) {</p>

<p> analyzerBuffer.offer( new Byte(( byte ) i));</p>

<p> }</p>

<p> String endFlag = &ldquo;123&rdquo; ;</p>

<p> int endFlagPos = findFlag(analyzerBuffer, endFlag);</p>

<p> List<Byte> cmplXmlStr = new ArrayList<Byte>();</p>

<p> analyzerBuffer.drainTo(cmplXmlStr, endFlagPos);</p>

<p> System. out .println(cmplXmlStr);</p>

<p> }</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用VIM查找特定字符串]]></title>
    <link href="http://leetschau.github.io/blog/2010/08/02/144347/"/>
    <updated>2010-08-02T14:43:47+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/08/02/144347</id>
    <content type="html"><![CDATA[<p>分析文本的时候经常出现的一个场景是：在关键字key的后面使用了一个变量，现在需要知道如何定义这个变量，但不知道它的名字，也不知道定义它的位置，一般采用的方法是先查找key，找到这个变量的名字，如str，然后再查找str，一般最开始处的str就是定义的位置。但有时str可能很长，对于UltraEdit这样的软件这个动作很简单，选中str，然后F3即可，但VIM没有这个功能，实现这个动作相对稍微麻烦些：
 1、用/key找到str；
 2、拷贝这个str（注1）；
 3、/&lt;ctrl+r>0查找选中的字符串；即先输入/，然后ctrl+r，然后输入0（原因见博文“VIM的寄存器”）。
 注1：
 不论中英文字符串，都是用标点或者空格作为word之间的分隔符，对于英文字符串，词与词之间有空格，用ynw比较好（其中n是词的个数，标点算一个词，例如project.classpath是3个word），用y3w就可以拷贝到寄存器中，中文字符串词间无空格，可用ynl拷贝（l是向右移动命令，n表示移动次数，即字数）。</p>
]]></content>
  </entry>
  
</feed>
