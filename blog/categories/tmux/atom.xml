<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tmux | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/tmux/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-11-11T15:03:30+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[启动Console后自动进入tmux]]></title>
    <link href="http://leetschau.github.io/blog/2016/10/16/174235/"/>
    <updated>2016-10-16T17:42:35+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/10/16/174235</id>
    <content type="html"><![CDATA[<p>如果希望启动Console后自动进入tmux环境，可以将这个Console的起始命令设置为
自动attach到一个名为<code>default</code>的tmux session里。</p>

<p>这么做的好处是每次启动Console后，就进入了<code>default</code> session，避免每次手工attach tmux,
坏处是这个Console彻底与tmux绑定，除了修改profile，无法进入没有tmux的状态
（因为退出tmux也就退出了Console）。</p>

<p>所以推荐的做法是除了系统自带的Console软件（Ubuntu上是<code>gnome-terminal</code>），
再安装一个专门用来配合tmux的Console软件，我用的是<code>terminator</code>，
大多数情况下使用terminator + tmux，只有在ssh到其他服务器上使用tmux的时候，
启动系统自带的Console，</p>

<p>配置terminator启动自动进入tmux session <em>default</em>:</p>

<p>在terminator的 <em>Preferences -> Profiles -> Command</em> 标签页中：
check <em>Run a custom command instead of my shell</em>，
并输入 <em>Custom command</em>: <code>tmux new -A -s default</code>
（确认已经预先安装了<code>tmux</code>）。</p>

<p>但是这样配置导致无法创建新的tmux session，所以暂时不使用这种方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在vim中执行shell命令的插件]]></title>
    <link href="http://leetschau.github.io/blog/2016/07/02/024310/"/>
    <updated>2016-07-02T02:43:10+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/07/02/024310</id>
    <content type="html"><![CDATA[<p>需要做一个vim工具，基本功能是通过一个快捷键，把选中的内容（或者当前行）发送到指定的tmux pane中，并执行。</p>

<h1>实现过程</h1>

<p>目录结构：当前工作目录下有 sendcmd.vim 和 test.md 两个文件，
前者包含实现功能的 vim 函数，后者是包含要执行命令行的数据文件。</p>

<p>开发环境：tmux window 1 做sendcmd.vim开发，window 2 上下拆分为两个pane
，上面 (ptop) 是命令行，下面的 pane (pbottom) 中用 vim 打开数据文件test.md.</p>

<p>每次修改并保存sendcmd.vim后，在test.md中执行<code>:so sendcmd.vim</code>，
然后把光标移动到要执行的命令所在的行上按<code>F3</code>键就可以看到命令被发送到ptop里的
执行效果了。</p>

<h2>格式探测</h2>

<p>这一步要解决的问题是：怎样的字符串，才能被<code>tmux send-keys</code>正确地传送出去，
并能正确的执行。</p>

<p>首先要保证运行<code>tmux send-keys</code>不报错，如果报错，
将第5行的输出拷贝到一个单独的命令行中运行，解决错误。</p>

<p>这一步通过后，如果命令被传送到<code>ptop</code>后报错，根据错误日志解决之。</p>

<p>sendcmd.vim：</p>

<pre><code>
function! SendCmd()
  let curline = getline(".")
  echom curline
  let cmd = "tmux send-keys -t top '" . curline . "' Enter"
  echom cmd
  echom system(cmd)
endfunction

nnoremap &lt;F3&gt; :call SendCmd()&lt;CR&gt;
</code></pre>

<p>说明：</p>

<ul>
<li>为什么第4行中<code>curline</code>要用单引号（而不是双引号）包裹？</li>
</ul>


<p>因为要执行的命令中可能包含变量（如es, idx等），双引号包裹的变量会被求值，
而我们的要求是这些变量不能被求值，要等到被发送到ptop后再被求值。由于这个原因，
第4行包裹外层<code>tmux send-keys</code>的命令就只能用双引号包裹。</p>

<ul>
<li>vimscript如何连接字符串？</li>
</ul>


<p>同样参考第4行，用点（ . ）连接。</p>

<ul>
<li><code>tmux send-keys -t top</code> 可以将keys从下面的pane发给上面，
也可以从左侧发到右侧，但如果是在右侧pane里执行这个语句，则会被发给自己。</li>
</ul>


<p>test.md：</p>

<pre><code>es=http://192.168.100.231:9200
api=http://192.168.100.231:8000
idx=production
type=Fair

# get elasticsearch version
http $es | jq '.version.number'

# list all indices
http -b GET $es'/_cat/indices?v'
http -b GET $es'"'"'/_cat/indices?v'"'"'

# list all types of a index
http -b GET $es/$idx/_mapping|jq ".$idx.mappings|keys"

# list all properties of a type
http -b GET $es/$idx/_mapping|jq ".$idx.mappings.$type.properties|keys"

# get objects count in a type
http -b GET $es/$idx/$type/_count|jq '.count'
http -b GET $es/$idx/$type/_count|jq '"'"'.count'"'"'

# query result count
http -b POST $es/$idx/$type/_search query:='{"bool":{"must":[{"query_string":{"query":"五金机械"}}]}}' | jq '.hits.total'
http -b POST $es/$idx/$type/_search query:=''{"bool":{"must":[{"query_string":{"query":"五金机械"}}]}}''
http -b POST $es/$idx/$type/_search query:='"'"'{"bool":{"must":[{"query_string":{"query":"五金机械"}}]}}'"'"'
http -b POST $es/$idx/$type/_search query:='"'"'{"bool":{"must":[{"query_string":{"query":"五金机械"}}]}}'"'"' | jq '"'"'.hits.total'"'"'
</code></pre>

<p>通过不断尝试后，发现用<code>'"'"'</code>代替<code>'</code>就能正确的发送并执行，
见第10,11行，20,21行，24~27行。</p>

<p>下面以第10行为例分析其结构：</p>

<ol>
<li><p>第一个单引号与外层的单引号结合，包裹它们中间的内容<code>http -b GET $es</code>，
保证里面的特殊字符（<code>$</code>）不会被求值；</p></li>
<li><p>中间的<code>"'"</code>是一组，实现被<code>tmux</code>发送后，最终执行的命令行里仍有一个单引号
（<code>$es</code>后面的单引号）；</p></li>
<li><p>最后的单引号，与后面的<code>'"'"'</code>中最左边的单引号组合，
包裹中间的内容<code>/_cat/indices?v</code>，如果没有这一组单引号，
里面的问好就会被求值，导致命令无法执行。</p></li>
</ol>


<p>这一步实现了在第11、21、27行上按<code>F3</code>键可以正确执行。</p>

<h2>整合进vim function</h2>

<p>这一步将前面的测试结果放进vim函数中，实现在第10、20、24行上能够正确执行。</p>

<p>sendcmd.vim：
<code>
function! SendCmd()
  let curline = getline(".")
  echom curline
  let escstr = substitute(curline, "'", "'\"'\"'", 'g')
  let cmd = "tmux send-keys -t top '" . escstr . "' Enter"
  echom cmd
  echom system(cmd)
endfunction
nnoremap &lt;F3&gt; :call SendCmd()&lt;CR&gt;
</code></p>

<h2>制作成插件</h2>

<p>当功能基本定型后，可以把脚本变成插件，避免每次使用时加载。</p>

<p>最简单的vim插件，只要在一个目录（tmuxcmd）里创建一个<code>plugin</code>目录，
把.vim脚本放进去，然后把目录做成git库就行了：</p>

<pre><code>mkdir -p tmuxcmd/plugin
mv test.vim tmuxcmd/plugin/tmuxcmd.vim
cd tmuxcmd
git init
git add ...; git commit -m "..."
</code></pre>

<p>在.vimrc里加入这个插件：增加一行代码：<code>Plugin 'file:///home/leo/temp/tmuxcmd'</code></p>

<p>安装：<code>vim +PluginInstall</code></p>

<p>安装过程实际是把代码库clone到~/.vim/bundle下，
修改~/.vim/bundle/tmuxcmd/plugin/tmuxcmd.vim文件在新的vim编辑器中不会生效。</p>

<p>本地插件需要保存一个本地目录，更简单的方法是发布到github上，再用vundle安装：</p>

<ol>
<li><p>把代码库push到github上：
<a href="https://github.com/leetschau/tmuxcmd">leetschau/tmuxcmd</a></p></li>
<li><p>在.vimrc中，把原来的<code>Plugin 'file:///home/leo/temp/tmuxcmd'</code>换成
<code>Plugin 'leetschau/tmuxcmd'</code></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[保存Tmux屏幕输出到文件中]]></title>
    <link href="http://leetschau.github.io/blog/2016/06/24/094511/"/>
    <updated>2016-06-24T09:45:11+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/06/24/094511</id>
    <content type="html"><![CDATA[<p>保存Tmux的屏幕输出分为两步：
首先用<code>capture-pane</code>将屏幕输出保存在buffer里，
然后用<code>save-buffer</code>将buffer内容保存到文件里。</p>

<p>在<code>capture-pane</code>中可以用<code>-S</code>和<code>-E</code>指定要保存的屏幕输出的范围，
当前屏幕的最上一行为坐标原点，标记为0，下面一行坐标是1,依次类推；
原点的上一行坐标是-1，再上一行坐标是-2，依次类推。</p>

<p>用<code>Alt-c</code>进入copy-mode后，屏幕右上角显示当前屏幕在整个pane中的坐标[X/Y]，
其中X代表当前屏幕最高行的坐标，Y代表最早一行屏幕输出的坐标，
根据坐标确定要保存文本的起止坐标就可以保存了。</p>

<p>例如要保存第3个pane中的一段近5000行的输出，
进入copy-mode后按<code>g</code>键，到最早的屏幕输出，右上角显示<code>[5676/5676]</code>,
用<code>Ctrl-f</code>或者<code>J</code>键向下滚动屏幕，
当想要保存的第一行处于屏幕最上一行时，坐标显示为<code>[5557/5676]</code>，
将想要保存的最后一行滚动到屏幕最上一行，坐标显示为<code>[642/5676]</code>，
切换到另一个pane里执行：</p>

<pre><code>tmux capture-pane -S -5557 -E -642 -t 3
tmux save-buffer output.log
</code></pre>

<p>这样这段输出就保存到文件output.log里了，其中<code>-t 3</code>指定了要保存的pane的序号。</p>

<p>如果要保存所有历史输出，可以简写为<code>tmux capture-pane -S -</code>.</p>

<p>除了新开一个pane执行tmux命令，也可以在当前pane用快捷键<code>Alt-a</code>进入tmux命令行状态
即command-prompt，然后执行<code>capture-pane -S -5557 -E -642</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Persist Tmux]]></title>
    <link href="http://leetschau.github.io/blog/2016/03/21/004603/"/>
    <updated>2016-03-21T00:46:03+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/03/21/004603</id>
    <content type="html"><![CDATA[<h1>Work Flow</h1>

<ol>
<li><p>Persist tmux status automatically or manually;</p></li>
<li><p>After restarting the computer, all sessions, windows and panes can
comes back.</p></li>
</ol>


<h1>Solution</h1>

<p>First make sure your tmux version >= 1.9 with <code>tmux -V</code>. If not, run:
 <code>
proxychains wget https://github.com/tmux/tmux/releases/download/2.3/tmux-2.3.tar.gz
tar zxf tmux-2.3.tar.gz
cd tmux-2.3
./configure &amp;&amp; make
sudo apt-get install libevent-dev libncurses5-dev libncursesw5-dev
sudo apt-get remove tmux
sudo make install
</code></p>

<p>Then install <a href="https://github.com/tmux-plugins/tpm">Tmux Plugin Manager</a>,
<a href="https://github.com/tmux-plugins/tmux-resurrect">Tmux Resurrect</a> and
<a href="https://github.com/tmux-plugins/tmux-continuum">tmux-continuum</a>:</p>

<pre><code>git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm
</code></pre>

<p>Adding the following lines in the end of ~/.tmux.conf (without running tmux server):</p>

<pre><code># List of plugins
set -g @plugin 'tmux-plugins/tpm'
set -g @plugin 'tmux-plugins/tmux-sensible'

set -g @plugin 'tmux-plugins/tmux-resurrect'
set -g @plugin 'tmux-plugins/tmux-continuum'
set -g @continuum-restore 'on'

# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
run '~/.tmux/plugins/tpm/tpm'
</code></pre>

<p>and run <code>tmux source-file .tmux.conf</code>.
Start tmux and press <code>prefix + I</code> to install all the plugins.
When finished, press <code>prefix + Ctrl-S</code> (key shortcut for saving tmux session)
to verifiy the installation.</p>

<p>Now the tmux status will be saved to disk every 15 minutes,
or save it manually with <code>prefix, Ctrl-S</code>.</p>

<p>After restarting computer, run <code>tmux</code> in console,
all tmux sessions, windows and panes will be restored automatically
(or you can restore them manually with <code>prefix, Ctrl-R</code>).</p>

<p>You can remove the temporary session with <code>tmux kill-session -t 0</code>,
where &ldquo;0&rdquo; is the name of the temporary session.</p>

<p>Note:</p>

<p>For more details about tmux plugin manager (update, remove plugin, for example),
see README.md of <a href="https://github.com/tmux-plugins/tpm">Tmux Plugin Manager</a>.</p>

<p>If not install with <code>apt-get</code>, you can install <a href="http://libevent.org/">libevent</a>
with downloading libevent-2.0.22-stable.tar.gz and install it from source.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Move Window Between Multiple Screens via Tmux]]></title>
    <link href="http://leetschau.github.io/blog/2015/11/02/093547/"/>
    <updated>2015-11-02T09:35:47+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/11/02/093547</id>
    <content type="html"><![CDATA[<p>When developing in terminal you often have to open several Tmux windows
at the same time:</p>

<ul>
<li><p>server: mongod, Meteor, Elasticsearch, etc&hellip;</p></li>
<li><p>client: mongo, elasticsearch, etc&hellip;</p></li>
<li><p>editor: template.html, template.js, router.js, server.js, etc&hellip;</p></li>
</ul>


<p>In most cases, you edit in editor window, save the file,
switch to server window to see the result,
switch back to editor window for editing again&hellip;</p>

<p>Now you have the second screen, say, a Windows laptop,
ssh to your Linux machine via MobaXterm or Kitty.
It will be more efficient if you can put the server window on the screen
of the Windows machine, and keep editing on your Linux machine screen,
for saving you from so many annoying switching between the screens.</p>

<p>It&rsquo;s easy for Tmux to achieve this.
Start a new session on your Linux machine, named as you like, for now, &ldquo;search&rdquo;.
Start a new session in the terminal of the second screen named <code>v</code> (&ldquo;viewer for short).
If you want to see the server and editor windows at the same time,
switch to the server window and run <code>link-window -t v</code> (see note 1 below for details).
Now you can switch back to the editor window,
while keep server window on the other screen.</p>

<p>To cancel the link between the sessions,
switch to server window and run <code>unlink-window -t v</code>.</p>

<p>Note 1:</p>

<p>If you define a &ldquo;command-prompt&rdquo; shortcut in ~/.tmux.conf:
<code>bind -n M-a command-prompt</code>,
run tmux command <code>linkw -t v</code> means:
press &ldquo;M-a&rdquo;, input <code>lin&lt;Tab&gt; -t v</code> then press <Enter>.</p>

<p>Note 2:</p>

<p><code>link-window</code> <em>shares</em> a window between multiple sessions.
To <em>move</em> a window to another session,
switch to the server window and run tmux command <code>move-window -t v</code>.
To move it back, run <code>move-window -s v:shell</code>,
where <code>v</code> is the target session name defined by <code>tmux new -s v</code>.</p>
]]></content>
  </entry>
  
</feed>
