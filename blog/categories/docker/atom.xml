<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Docker | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-11-11T15:03:30+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[保证Docker的输入参数可执行]]></title>
    <link href="http://leetschau.github.io/blog/2016/10/25/110137/"/>
    <updated>2016-10-25T11:01:37+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/10/25/110137</id>
    <content type="html"><![CDATA[<p>写Docker的entrypoint时有个问题是：
Docker启动后如果用户的cmd参数以可执行命令开头，
这个命令覆盖entrypoint中的可执行命令，否则执行的是<code>entrypoint cmd</code>。</p>

<p>怎样实现entrypoint对cmd是否可执行的判断？</p>

<p><a href="https://github.com/appropriate/docker-curl">appropriate/docker-curl</a>中的
latest/entrypoint.sh脚本给出了一种实现方法：</p>

<pre><code>#!/bin/sh
set -e

# Prepend "curl" if the first argument is not an executable
if ! type -- "$1" &amp;&gt; /dev/null; then
  set -- curl "$@"
fi

exec "$@"
</code></pre>

<p>这段脚本的功能是：如果用户在run这个image时，cmd是以可执行命令（或者文件）开头
（例如cmd是<code>curl www.google.com</code>），那么执行这个cmd，否则
（例如cmd是<code>www.google.com</code>）给这个cmd前面加上<code>curl</code>再执行。</p>

<p>根据<a href="http://linuxcommand.org/lc3_man_pages/seth.html">set manpage</a>，
上面脚本第2行<code>set -e</code>的意思是如果执行过程中出现错误直接退出。</p>

<p>第5行用于判断cmd的第一部分是否为可执行命令，如果是跳到最后一行直接执行cmd整体，
否则在<code>$@</code>前面加上<code>curl</code>，然后再执行。</p>

<p>第5行中的<code>--</code>的作用是避免<code>$1</code>以横杠开头时干扰<code>type</code>的判断，在bash中做如下实验：</p>

<pre><code>$ type ls &amp;&gt; /dev/null         # return 0
$ type -p ls &amp;&gt; /dev/null     # return 0
$ type -- -p ls &amp;&gt; /dev/null  # return 1
</code></pre>

<p>可以看到，当cmd是<code>-p ls</code>时（第2条语句），如果不加<code>--</code>，
整个<code>type -p ls</code>的返回结果是0（因为<code>-p</code>被当成了<code>type</code>的选项），
但<code>-p</code>显然不是可执行命令，所以<code>--</code>是必需的。</p>

<p><code>&amp;</code>将命令变为后台运行，<code>&gt; /dev/null</code>去掉所有输出，二者组合起来的意思是：
不要任何输出，只告诉我命令执行是否成功了（返回值0表示成功，否则表示失败）。
做如下实验（假设当前目录下有<code>docs</code>子目录，没有<code>aaa</code>子目录）：</p>

<pre><code>cd docs
cd docs &amp;
cd docs &amp;&gt;/dev/null
cd aaa
cd aaa &amp;
cd aaa &amp;&gt;/dev/null
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用format参数获取docker Inspect输出的指定部分]]></title>
    <link href="http://leetschau.github.io/blog/2016/09/23/110618/"/>
    <updated>2016-09-23T11:06:18+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/09/23/110618</id>
    <content type="html"><![CDATA[<p>参考<a href="https://golang.org/pkg/text/template/">Package template in Go programming</a>.</p>

<p>基本规则：用<code>.</code>号取map的值，用<code>index</code>取数组的值。</p>

<p><code>index</code>的用法：<code>index &lt;array-name&gt; &lt;index-number&gt;</code></p>

<p><code>range</code>的用法：<code>{{range pipeline}} T1 {{end}}</code></p>

<p>表达式<code>pipeline</code>返回值（必须是一个map或者array）的各个元素赋给<code>T1</code>中的<code>.</code>，
例如下面的例子中，<code>{{.NetworkSettings.Networks}}</code>的返回值是一个key为<code>bridge</code>的map对象，
它被赋给<code>T1</code>（这里是<code>{{.IPAddress}}</code>）中的<code>.</code>，所以<code>{{.IPAddress}}</code>的值是"172.31.254.3".</p>

<p>示例：</p>

<pre><code>root@node1:~# docker inspect angry_wing 
[
    {
        "Id": "e30f58ac1610c8607205d612b4389b361c5f6745e999bb5c8086f11f4b4e5903",
        "Config": {
            "Hostname": "e30f58ac1610",
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "DEBIAN_FRONTEND=noninteractive",
                "DEBCONF_NONINTERACTIVE_SEEN=true"
            ],
            "Entrypoint": [
                "/entrypoint.sh"
            ]
        },
        "NetworkSettings": {
            "Networks": {
                "bridge": {
                    "IPAddress": "172.31.254.3"
                }
            }
        }
    }
]

root@node1:~# docker inspect --format='{{.NetworkSettings.Networks}}' angry_wing 
map[bridge:0xc8200aa3c0]

root@node1:~# docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' angry_wing 
172.31.254.3

root@node1:~# docker inspect --format='{{.NetworkSettings.Networks.bridge.IPAddress}}' angry_wing 
172.31.254.3

root@node1:~# docker inspect --format='{{.Config.Entrypoint}}' angry_wing 
[/entrypoint.sh]

root@node1:~# docker inspect --format='{{range .Config.Entrypoint}}{{.}}{{end}}' angry_wing 
/entrypoint.sh

root@node1:~# docker inspect --format='{{index .Config.Env 0}}' angry_wing 
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

root@node1:~# docker inspect --format='{{range .Config.Env}}{{.}}; {{end}}' angry_wing 
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; DEBIAN_FRONTEND=noninteractive; DEBCONF_NONINTERACTIVE_SEEN=true;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Lightweight Message Queue]]></title>
    <link href="http://leetschau.github.io/blog/2015/12/10/165329/"/>
    <updated>2015-12-10T16:53:29+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/12/10/165329</id>
    <content type="html"><![CDATA[<h1>RSMQ</h1>

<p><a href="http://smrchy.github.io/rsmq/">RSMQ</a> is a lightweight message queue
based on Redis.</p>

<h2>Setup Redis Server on Docker</h2>

<p>Start Redis server on docker:
<code>bash
docker run --name myredis -d redis
                  -------
                     A
</code></p>

<p>Connect to the server with:
<code>bash
docker run -it --link myredis:redis --rm redis bash -c 'redis-cli -h redis'
                      ------- -----                                  -----
                         A      B                                      B
</code>
or the full version:
<code>docker run -it --link myredis:redis --rm redis bash -c 'exec redis-cli -h "$REDIS_PORT_6379_TCP_ADDR" -p "$REDIS_PORT_6379_TCP_PORT"'</code>.</p>

<p>Now in redis console, use <code>info</code> to get the server&rsquo;s version;</p>

<p><code>keys *</code> to list all keys;
<code>set mykey "hello"</code> to add a key/value pair.
<code>get mykey</code> to fetch the key&rsquo;s value.</p>

<p>Note:</p>

<ol>
<li>Names labled with &ldquo;A&rdquo; is the container&rsquo;s name of Redis server.
Names labled with &ldquo;B&rdquo; is the name alias of Redis server container used
by Redis client container.</li>
</ol>


<h2>Setup Redis on Metal Host</h2>

<p>Install Redis on Ubuntu 14.04 with:
<code>bash
apt-get install -y python-software-properties # optional
add-apt-repository -y ppa:rwky/redis
apt-get update
apt-get install -y redis-server
</code></p>

<p>Install rsmq: in project root folder, run<code>npm install rsmq</code>;</p>

<p>Install rsmq-cli: <code>npm install -g rsmq-cli</code>;</p>

<pre><code>rsmq config ls
rsmq create -q payment            // create a new queue named "payment"
rsmq ls                           // list all queues
rsmq stats -q payment             // print stats of queue "payment"
rsmq send "pay $1000" -q payment  // send a message to "payment"
rsmq receive -q payment           // receive a message from "payment"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Run MongoDB Server on Docker in VPS]]></title>
    <link href="http://leetschau.github.io/blog/2015/05/15/142023/"/>
    <updated>2015-05-15T14:20:23+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/05/15/142023</id>
    <content type="html"><![CDATA[<h1>Use docker mongo server and client</h1>

<pre><code>// start server and run in background:
$ docker run --name mongoserver -d mongo:3.2
// start client, quit with Ctrl-d, the container will be removed when quit:
$ docker run -it --link mongoserver:mongo --rm mongo:3.2 sh -c 'exec mongo "$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/test"'
// stop server:
$ docker stop mongoserver
// start server again:
$ docker start mongoserver
// stop and remove server and all the data
$ docker stop mongoserver
$ docker rm -vf mongoserver
// start a new server and run in background:
$ docker run --name mongoserver -d mongo:3.2
$ docker run --link mongoserver:mongo --rm mongo:3.2 sh -c 'exec echo "$MONGO_PORT_27017_TCP_ADDR"'
172.17.0.4
</code></pre>

<p>Ref: <code>https://hub.docker.com/_/mongo/</code></p>

<h1>Use native mongo client</h1>

<p>Install mongodb client: <code>sudo aptitude install mongodb-org-shell</code>;</p>

<p>Install mongodb server and connect to it:</p>

<pre><code>sudo usermod -aG docker leo
docker run --name mongo3 -p 27017:27017 -d daocloud.io/mongo
mongo
&gt; db.version()
&gt; exit
</code></pre>

<p>Stop and restart mongodb server:</p>

<pre><code>docker stop mongo3
docker start mongo3
</code></pre>

<p>Remove mongodb completely:</p>

<pre><code>docker ps -a
docker stop mongo3
docker rm mongo3
docker images
docker rmi daocloud.io/mongo
</code></pre>

<p>Note:</p>

<p>You can also pull mongodb image from docker hub with
<code>docker run --name mongo3 -d mongo</code>, but it&rsquo;s very slow.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build BVT System Based on Docker]]></title>
    <link href="http://leetschau.github.io/blog/2014/09/03/150610/"/>
    <updated>2014-09-03T15:06:10+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/09/03/150610</id>
    <content type="html"><![CDATA[<p>System: ArchLinux 64bit, IP address: 10.32.1.18.</p>

<h1>Build</h1>

<pre><code>sudo docker -p 8080:8080 --name myjenkins jenkins
</code></pre>

<p>Now you can access <a href="http://10.32.1.18:8080">jenkins server</a> in browser.</p>

<p>List running containers: <code>sudo docker ps</code> (so you can get the container&rsquo;s name for stoping and restarting later);</p>

<p>Stop jenkins server: <code>sudo docker stop myjenkins</code>;</p>

<p>Restart this server: <code>sudo docker start myjenkins</code>;</p>

<h1>Backup and Restore</h1>

<p>Backup image: <code>sudo docker save -o jenkins-docker.tar jenkins</code>;</p>

<p>Restore image: <code>sudo docker load -i jenkins-docker.tar</code>;</p>

<p>Backup container:</p>

<pre><code>(optional) sudo docker stop jenkins
sudo docker export myjenkins &gt; mybvt-system.tar
scp mybvt-system.tar chad@laptop:~/
ssh chad@laptop
cat mybvt-system.tar | sudo docker import - exampleimagelocal:new
</code></pre>

<p>But where is the imported container?</p>
]]></content>
  </entry>
  
</feed>
