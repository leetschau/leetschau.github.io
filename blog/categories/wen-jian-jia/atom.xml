<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 文件夹 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/wen-jian-jia/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-05-26T17:50:21+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Auto Dir Sync Script Based on Total Commander]]></title>
    <link href="http://leetschau.github.io/blog/2012/12/28/143757/"/>
    <updated>2012-12-28T14:37:57+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/12/28/143757</id>
    <content type="html"><![CDATA[<p>The Sync source folder is in e:\mydoc\CalibreLib, destination folder is M:\backup\CalibreLib, where M is the drive letter of an USB disk with label &ldquo;Emacs&rdquo;;</p>

<h1>Giving USB Disk a fixed Drive Letter</h1>

<p>Right click &ldquo;My Compter&rdquo; -> Manage -> Storage -> Disk Management. Right click the USB drive -> Change Drive Letter and Paths, and modify it to M. You can choose any letter between M~Z. A letter before M is not recommended because it could be occupied by virtual drives or CD-ROMs.</p>

<p>Test shows that other USB disk won&rsquo;t use the drive letter &ldquo;M&rdquo;. And this USB disk(&ldquo;Emacs&rdquo;) always use &ldquo;M&rdquo; no matter which USB port it&rsquo;s plugged in;</p>

<h1>Define Sync Configuration in Total Commander</h1>

<ol>
<li><p>Open e:\mydoc\CalibreLib in upper(left) panel in TC, M:\backup\CalibreLib in bottom panel;</p></li>
<li><p>Shift + F12(Commands -> Synchronize Dirs) to show the Sync window of TC;</p></li>
<li><p>Check &ldquo;Asymmetric&rdquo;(because I want a strict mirror of e:\mydoc\CalibreLib, not a copy. see TC doc for detailed explanation) and &ldquo;Subdirs&rdquo;;</p></li>
<li><p>Click the button at the left side of the directory input box and choose &ldquo;add current directories and settings to list&rdquo;. You can verify this by openning file wincmd.ini in TC&rsquo;s installation dir and you can find:</p></li>
</ol>


<p> [SyncOptions]
 BooksLib_L=E:\MyDoc\CalibreLib\
 BooksLib_R=M:\backup\CalibreLib\
 BooksLib_Wcs=<em>.</em>
 BooksLib_Flags=9|61|-9</p>

<p>In &ldquo;Configuration and Switches&rdquo; -> &ldquo;ini file Settings&rdquo; of TC&rsquo;s document file(TOTALCMD.CHM), you can find the explanations about settings above.</p>

<h1>Define a hotkey in AutoHotkey Script</h1>

<p>  #!s:: Run, d:\apps\TotalCmd\TOTALCMD.EXE /S=S:=BooksLib ; Sync Calibre dir to usb disk</p>

<h1>Use this auto sync script</h1>

<ol>
<li><p>Insert USB disk;</p></li>
<li><p>Press Win+Alt+s;</p></li>
<li><p>Sync tool of TC will start comparation automatically;</p></li>
<li><p>When comparation ends, check the result. If it&rsquo;s OK, press Enter to start Synchronize;</p></li>
</ol>


<p>That&rsquo;s it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文件夹监控工具比较]]></title>
    <link href="http://leetschau.github.io/blog/2012/02/01/112546/"/>
    <updated>2012-02-01T11:25:46+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/02/01/112546</id>
    <content type="html"><![CDATA[<p>对文件夹监控软件的要求是：能同时监控多个指定的文件夹，能够根据事件类型决定是否监控（例如是否只监控文件夹生成或者删除等），能够记录监控日志。</p>

<p><a href="http://leelusoft.blogspot.com/2011/10/watch-4-folder-23.html">Watch 4 Folder</a>: 目前的版本2.3监测不到子目录文件的变化，不可用；</p>

<p>FolderMonitor和TrackFolderChanges同样功能太弱；</p>

<p>另有<a href="http://www.watchdirectory.net/index.html">watchDirectory</a>，收费软件，没有试；</p>

<p>基于TotalCMD的文件夹监控方法：改变前用TotalCMD的<a href="http://www.totalcmd.net/plugring/diskdir_extended.html">DiskDir Extended</a>扩展为文件夹的所有子文件夹和文件做一个记录（方法见 TotalCommander的两款目录插件 ），改变后再做一次，然后用文本比较工具（例如vim diff或者notepad++的都很好用）观察变化；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文件夹同步软件比较]]></title>
    <link href="http://leetschau.github.io/blog/2011/10/07/141255/"/>
    <updated>2011-10-07T14:12:55+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/10/07/141255</id>
    <content type="html"><![CDATA[<p>比较软件列表
 Toucan: GNU/GPL, 绿色；</p>

<p> Allway Sync免费版: ASF；</p>

<p>GoodSync: GS, proprietary ware;</p>

<p> TotalCommander: TC, proprietary ware;</p>

<p>Microsoft SyncToy: ST;</p>

<p>Super Flexible File Synchronizer Pro v5.54a: SFFS，proprietary ware;</p>

<p> SyncBackPro: proprietary ware, SBP;</p>

<p>Areca: 开源，绿色，适用于“备份”，不适用于“同步”，因为Areca中的“Repository"相当于同步目标位置，Source相当于同步源，但它会在Repo里自动加一个全数字组成的子目录，它的强大之处是可以像SVN一样记录每次备份的历史，为备份加密，备份前后可以执行脚本；</p>

<p>Free File Sync: 开源，绿色，有多种同步模式，但好像不支持智能盘符； 过滤器
同步软件的过滤器最好具有复杂逻辑判断能力，例如：将文件夹A备份到文件夹B，去除其中>500MB的文件，但其中FA, FB除外（也就是说FA,FB仍然要备份）。</p>

<p>以下是各软件的过滤器比较：</p>

<p>Toucan：可以用"Rules"定义；</p>

<p>ASF: 有文件大小定义，但试用后达不到预期目标；</p>

<p>GS: 没有文件大小定义，只有文件名定义；</p>

<p>TC: 没有过滤器功能；</p>

<p>SBP: 似乎有，但似乎很复杂；</p>

<p>SFFS: 过滤器功能很强大，包括Include/Exclude列表、尺寸大小、时间戳等多种方式过滤；</p>

<p> 任务导出/导入
如果没有复杂逻辑筛选功能，但具备任务的导入/导出功能，那么仍然可以满足前面提到的复杂备份要求，办法是手工定义文件排除列表，然后导出任务，这样系统或者软件重装后只要导入先前定义好的任务列表即可。</p>

<p>目前试用的有：</p>

<p>GS: 手工生成排除列表的功能比较直观好用，也具备导入/导出任务功能；</p>

<p>ASF, SFFS也具备导入/导出任务功能；
 智能盘符
GS不具备；</p>

<p>ASF具备；</p>

<p>SFFS可以在路径名中直接写盘符，例如：U52:\Backup\PersonalFinance</p>

<p>还可以勾选如下选项：Edit Profile->Advanced Settings->Job->Right-hand volume must be:&hellip;</p>

<p> 同步记录文件夹
很多同步软件会在同步目标文件夹下生成一些特殊的文件夹，例如GoodSync会生成gs_data文件夹，ASF生成_SYNCAPP文件夹，ST在源和目标文件夹下都生成一个SyncToy*.dat文件，很不好，这方面Toucan和SFFS做的比较好，不生成任何额外的文件夹。
 总结
Toucan是一款全功能（同步、备份、加密）软件，能过滤，能自己写脚本，支持在命令行下运行，不在文件夹下新建记录文件（夹），无需安装，推荐。使用方法详见"Settings->Help"，备份Calibre书库用Sync->Mirror方法备份，这种模式下即使目标比源新时也用源覆盖目标，保证绝对的单向备份。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数码照片按拍摄时间分文件夹保存]]></title>
    <link href="http://leetschau.github.io/blog/2011/06/27/154047/"/>
    <updated>2011-06-27T15:40:47+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/06/27/154047</id>
    <content type="html"><![CDATA[<h2>拍摄的大量数码照片需要根据拍摄的时间分别放到不同的文件夹里，例如2011年6月27日拍摄的照片要放在名为“2011-6-27”的文件夹里。拍摄时间是根据文件的“最后修改时间”属性确定的，因为“创建时间”属性是会随着文件的拷贝而变化的，不能作为拍摄时间的根据。当然如果用画图或者photoshop修改了照片，那么 “最后修改时间”属性也不是拍摄时间了，但文件的【属性->摘要->照片拍照时间】项仍能显示出真实的拍照时间，但如何取这个属性尚不清楚，故本文不涉及。下面是源代码： </h2>

<p> #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p> # Author:  Li Chao</p>

<p> # Created:  27-06-2011</p>

<p> #</p>

<p> # Purpose: 将相机SD卡上的照片按照拍摄日期放入硬盘上当前目录下的不同的文件夹中。</p>

<p> #</p>

<p> # Usage:</p>

<p> # step 1: 将本文件拷贝到目标文件夹中；</p>

<p> # step 2: 在这个文件夹下新建一个run.bat，内容如下：</p>

<p> #   python arrangePhotos.py [photo_path] [last_backup_date]</p>

<p> #   第1个参数是SD卡里照片所在文件夹路径，第二个参数是已备份的最后日期；</p>

<p> # step 3: 运行run.bat</p>

<p> #</p>

<p> # Example: python arrangePhotos.py h:/transfer/pics 2011-06-10</p>

<p> #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p> #!/usr/bin/env python</p>

<p> import sys, os, time, shutil</p>

<p> from datetime import date</p>

<p> def main():</p>

<p>  photos_path = sys.argv[1]</p>

<p>  last_bp = time.strptime(sys.argv[2], &ldquo;%Y.%m.%d&rdquo;)</p>

<p>  last_bp_epoch = time. mktime (last_bp)</p>

<p>  for item in os.listdir(photos_path):</p>

<p>   modif_time = os.path. getmtime (os.path.join(photos_path,item))</p>

<p>   if modif_time - last_bp_epoch &lt;= 3600*24 :</p>

<pre><code>continue 
</code></pre>

<p>   cre_date_obj = date.fromtimestamp(modif_time)</p>

<p>   cre_date = cre_date_obj.strftime(&ldquo;%Y.%m.%d&rdquo;)</p>

<p>   if not os.path.exists(cre_date):</p>

<pre><code>os.mkdir(cre_date) 

print '\n%s' %cre_date 
</code></pre>

<p>   shutil.copy2(os.path.join(photos_path,item), cre_date)</p>

<pre><code>print '.', 
</code></pre>

<p> if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<p>  main()</p>

<hr />

<p> 对源代码的解释：</p>

<ol>
<li>时区问题：</li>
</ol>


<p>  由于time.mktime()方法和os.path.getmtime()都是以1970-1-1 08:00:00为起点，因此将这些时间数转换为日期、时间时，一定要用time.localtime()方法，如果用time.gmtime()，则会得到错误的值，下面这段代码演示了两种方法的区别：</p>

<p> import time</p>

<p> gm_sec = time.gmtime(0)</p>

<p> print gm_sec</p>

<p> gm = time.strftime(&lsquo;%Y-%m-%d, %X&rsquo;, gm_sec)</p>

<p> print &lsquo;UTC start point is %s&rsquo; %gm</p>

<p> lc_sec = time.localtime(0)</p>

<p> print lc_sec</p>

<p> lc = time.strftime(&lsquo;%Y-%m-%d, %X&rsquo;, lc_sec)</p>

<p> print &lsquo;local time start point is %s&rsquo; %lc</p>

<p> second_day = time.mktime(time.strptime(&lsquo;1970-1-2&rsquo;, &ldquo;%Y-%m-%d&rdquo;))</p>

<p> print &lsquo;second day is %s hours after first day&rsquo; %(second_day/3600)</p>

<p>输出为：</p>

<p> time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)</p>

<p> UTC start point is 1970-01-01, 00:00:00</p>

<p> time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=8, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)</p>

<p> local time start point is 1970-01-01, 08:00:00</p>

<p> second day is 16.0 hours after first day</p>

<p>加粗的部分表明东8区的时间起点是1970-1-1 08:00:00。</p>

<ol>
<li>为什么修改时间要比最后一次备份时间多一天（即24小时，3600*24秒）？</li>
</ol>


<p> 例如最后一次备份时间是2011年6月27日，last_bp_epoch的值对应于27日0点0分，当处理一张2011年6月27日晚11点拍摄的照片时，modif_time - last_bp_epoch = 23 hour，这张照片已经备份过了，不应该再次备份，因此modif_time - last_bp_epoch > 24hour时才需要备份；</p>

<ol>
<li>怎样让print语句的输出不换行？</li>
</ol>


<p> 在字符串后面加逗号即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[删除过期的文件夹]]></title>
    <link href="http://leetschau.github.io/blog/2011/05/11/150130/"/>
    <updated>2011-05-11T15:01:30+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/05/11/150130</id>
    <content type="html"><![CDATA[<p>BVT将每天检出并运行单元测试的源代码放入一个以日期命名的文件夹中，每个文件夹都很大，因此需要及时清除比较老的文件夹以节约磁盘空间，例如今天是5月11日，bvt运行目录e:\bvt_build下有如下文件夹和文件：</p>

<p> 2011-04-18\</p>

<p> 2011-04-19\</p>

<p> 2011-04-22\</p>

<p> 2011-04-25\</p>

<p> 2011-04-27\</p>

<p> 2011-05-10\</p>

<p> 2011-05-09\</p>

<p>  2011-05-08\</p>

<p> backup\</p>

<p> note.txt</p>

<p>现在的要求是仅保留今天、昨天和前天共3天的文件夹，其余文件夹删除（文件都保留），技术关键有两点：一是怎样将字符串形式的日期转换为可以用来做减法的date对象，以便判断与今天的间隔，这里采用的方法是：先将字符串转换为一个datetime对象，然后转换为一个timestamp（实数），再将timestamp转换为date对象；二是怎样将时间间隔（timedelta）对象转换为整型数以便进行比较，这里用的方法是得到timedelta对象后取其days属性。代码如下：</p>

<p> import os,shutil,time</p>

<p> from datetime import datetime, timedelta, date</p>

<p> today = date.today()</p>

<p> sub_items = os.listdir(&lsquo;e:/bvt_build&rsquo;)</p>

<p> for item in sub_items:</p>

<p>  try:</p>

<p>   timeFloat = time.mktime(time.strptime(item, &ldquo;%Y-%m-%d&rdquo;))</p>

<p>   the_day = date.fromtimestamp(timeFloat)</p>

<p>   time_span = (today - the_day).days</p>

<p>   if time_span > 2:</p>

<pre><code>shutil.rmtree(os.path.join('e:/bvt_build',item)) 
</code></pre>

<p>  except:</p>

<p>   continue</p>

<p>运行后的结果如下：</p>

<p> 2011-05-09\</p>

<p> 2011-05-10\</p>

<p> backup\</p>

<p> note.txt</p>
]]></content>
  </entry>
  
</feed>
