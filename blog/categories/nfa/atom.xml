<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Nfa | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/nfa/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-09-10T17:28:18+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[能够进行多段文本匹配的NFA改良算法]]></title>
    <link href="http://leetschau.github.io/blog/2013/03/31/231152/"/>
    <updated>2013-03-31T23:11:52+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/03/31/231152</id>
    <content type="html"><![CDATA[<p>下面的代码基于NFA算法实现了在多段字符串中匹配正则表达式，对比NFA算法可以看到它将pc由局部变量提升为类成员，以保存中间匹配状态，另外在匹配成功后将pc恢复到null状态。实际使用中，此类还应该增加一个&#8221;reset&#8221;方法，将pc值置为null，以便用户可以显式要求重新开始匹配。</p>

<p> public class MultiSegmentNFA {
  private final Digraph G; // digraph of epsilon transitions
  private final String regexp; // regular expression
  private final int M; // number of characters in regular expression
  private Bag<Integer> pc = null;
  public MultiSegmentNFA(String regexp) {
   &hellip; // same as NFA
  }
  public boolean recognizes(String target) {
   if (pc == null) {
    DirectedDFS dfs = new DirectedDFS(G, 0);
    pc = new Bag<Integer>();
    for (int v = 0; v &lt; G.V(); v++)
     if (dfs.marked(v))
      pc.add(v);
   }
   for (int i = 0; i &lt; target.length(); i++) {
    Bag<Integer> match = new Bag<Integer>();
    for (int v : pc) {
     if (v == M)
      continue;
     if ((regexp.charAt(v) == target.charAt(i))
       || regexp.charAt(v) == &lsquo;.&rsquo;)
      match.add(v + 1);
    }
    DirectedDFS dfs = new DirectedDFS(G, match);
    pc = new Bag<Integer>();
    for (int v = 0; v &lt; G.V(); v++)
     if (dfs.marked(v))
      pc.add(v);
    if (pc.size() == 0)
     return false;
   }
   for (int v : pc)
    if (v == M) {</p>

<pre><code> pc = null; 
 return true;

} 
</code></pre>

<p>   return false;
  }</p>

<p>  public static void main(String[] args) {
   LinkedList<String> msgs = new LinkedList<String>();
   msgs.offer(&ldquo;welcome lonely logoout&rdquo;);
   msgs.offer(&ldquo;to flog&rdquo;);
   msgs.offer(&ldquo;into a fog&rdquo;);
   String token = &ldquo;outto&rdquo;;  // 这个目标由第1和第2个字符串拼接而成
   String pat = &ldquo;(.<em>&rdquo; + token + &ldquo;.</em>)&rdquo;;
   MultiSegmentNFA mnfa = new MultiSegmentNFA(pat);
   String target = msgs.poll();
   while (target != null) {
    if (mnfa.recognizes(target)) {
     break;
    }
    target = msgs.poll();
   }
   if (target == null) {
    System.out.println(&ldquo;cannot find &rdquo; + token + &ldquo; in msgs.&rdquo;);
   } else {
    System.out.println(&ldquo;find pat in &lt;&rdquo; + target + &ldquo;>&rdquo;);
   }
  }
 }</p>

<p>Note: Java的Pattern类使用的就是基于NFA的搜索算法，见JDK 6文档java.util.regex.Pattern的&#8221;Comparison to Perl 5&#8221;一节。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NFA算法笔记]]></title>
    <link href="http://leetschau.github.io/blog/2013/03/31/215259/"/>
    <updated>2013-03-31T21:52:59+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/03/31/215259</id>
    <content type="html"><![CDATA[<p>NFA(Nondeterministic finite-state automata)是一种在字符串中寻找正则表达式匹配的算法，优点是查找文本的指针不回退，适用于在网络传输的报文中寻找正则表达式描述的目标（因为网络传输中报文是被分段接收的，且分段的方式不确定），在Robert的&#8221;Algorithms&#8221;第5.4节&#8221;Regular Expressions&#8221;中有详细介绍。</p>

<p>NFA算法可以分为定义和执行两部分，定义阶段和执行阶段。</p>

<p>定义阶段是将要查找的正则表达式（String类型）转换为一个有向图（Digraph类型），该图中的边是所有可以进行的空转换（见p795倒数第2行），定义阶段在书中&#8221;Building an NFA corresponding to an RE&#8221;一节，图示见p803，代码见p802），在代码表现为以一个正则表达式字符串为参数的NFA构造函数；</p>

<p>执行阶段就是判断待处理的文本中是否含有目标正则表达式（见&#8221;Simulating an NFA&#8221;一节，图示见p798），整个过程是一个循环过程，每次循环待处理文本指针前进一个字符，这次循环由两步组成，首先根据当前正则表达式指针所处位置（最初位置都是0）算出所有空转换可达位置（借助深度优先算法DirectedDFS，可达位置保存在变量pc中），然后将所有可达位置上的字符与待处理文本指针处的字符比较，如果一样则把正则表达式指针的后一位保存在变量match中。然后以match为初始位置重新构造DirectedDFS对象，进而得到可达位置集合pc，然后从中筛选匹配上的位置，如此循环，直到待处理文本指针到达文本尾部，如果pc中有正则表达式长度的那个元素（代表匹配成功的位置，书中代码用类成员M表示），说明匹配正则表达式成功，否则失败。</p>

<p>需要说明的是，从所有可达状态pc中筛选匹配上位置并放入match中之前，需要先将值为M的元素去掉，以用&#8221;(A<em>B|AC)D&#8221;匹配&#8221;AABDC&#8221;为例，当目标文本指针等于4时，即指向&#8221;AABDC&#8221;的最后一个字符C时，pc中已经包含了最终状态11（正则串&#8221;((A</em>B|AC)D)&ldquo;的长度），因为AABD符合&rdquo;(A<em>B|AC)D&#8221;，但最后的C导致整个文本不匹配&#8221;(A</em>B|AC)D&#8221;，所以结果仍然是匹配失败。</p>

<p>测试代码如下：</p>

<p> String token = &ldquo;(A<em>B|AC)D&rdquo;;
 String regexp = &ldquo;(&rdquo; + token + &ldquo;)&rdquo;;
 // when test if target string &ldquo;contains&rdquo; regex, regexp = &ldquo;(.</em>&rdquo; + token + &ldquo;.*)&rdquo;
 NFA nfa = new NFA(regexp);
 String target = &ldquo;AABDC&rdquo;;
 if (nfa.recognizes(target)) {
  System.out.println(&ldquo;match: &rdquo; + target);
 } else {
  System.out.println(&ldquo;not match: &rdquo; + target);
 }</p>
]]></content>
  </entry>
  
</feed>
