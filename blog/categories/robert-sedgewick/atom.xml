<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Robert Sedgewick | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/robert-sedgewick/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-08-01T16:20:42+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[计算成本图像演示方法的改进]]></title>
    <link href="http://leetschau.github.io/blog/2013/01/27/132736/"/>
    <updated>2013-01-27T13:27:36+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/01/27/132736</id>
    <content type="html"><![CDATA[<p>本文在笔记 BinarySearchST计算成本的测试代码 的基础上，尝试将成本计算和图像演示等功能封装在一个单独的类中，尽量降低对被测试类的改动。</p>

<h1>测试方法</h1>

<ol>
<li><p>在被测类中增加一个成员及其getter；</p></li>
<li><p>在FrequencyCounter类中增加：st.getVisitTimes().drawCostCurve();</p></li>
</ol>


<h1>两个实例</h1>

<h2>BinarySearchST</h2>

<p> public class BinarySearchST<Key extends Comparable<Key>, Value> {
  private final VisitTimeCounter vtc = new VisitTimeCounter();
  public VisitTimeCounter getVisitTimes() {
   return vtc;
  }
  public int rank(Key key) {
   int lo = 0, hi = N - 1;
   while (lo &lt;= hi) {
    int m = lo + (hi - lo) / 2;
    vtc.addVisitTimes();
    int cmp = key.compareTo(keys[m]);
    if (cmp &lt; 0)
     hi = m - 1;
    else if (cmp > 0)
     lo = m + 1;
    else
     return m;
   }
   return lo;
  }
  public void put(Key key, Value val) {
   if (val == null) {
    delete(key);
    return;
   }
   int i = rank(key);
   if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) {
    vtc.putComplete();
    vals[i] = val;
    return;
   }
   if (N == keys.length)
    resize(2 * keys.length);
   for (int j = N; j > i; j&ndash;) {
    keys[j] = keys[j - 1];
    vals[j] = vals[j - 1];
    vtc.addVisitTimes();
   }
   keys[i] = key;
   vals[i] = val;
   N++;
   vtc.putComplete();
   assert check();
  }
 }</p>

<p>对原版BinarySearchST类的修改包括增加了一个成员（vtc）和它的getter，在rank和put中各加了一个vtc.addVisitTimes()表示查询和插入操作中对数组的访问，以及put中两处vtc.putComplete()，表示在命中和未命中两种情况下将本次put的访问次数存入数组记录中。</p>

<p>下面是VisitTimeCounter类：</p>

<p> public class VisitTimeCounter {
  private int visitTimesInsidePut = 0; // 一次put操作当中的数组访问次数
  private final List<Integer> visitTimesInAllPut = new ArrayList<Integer>(); // 各次put的访问次数汇总保存在这里
  public void addVisitTimes() {
   visitTimesInsidePut++;
  }
  public void putComplete() {
   visitTimesInAllPut.add(visitTimesInsidePut);
   visitTimesInsidePut = 0;
  }
  public void drawCostCurve() {
   int maxComp = 0;
   for (Integer i : visitTimesInAllPut) {
    if (i > maxComp) {
     maxComp = i;
    }
   }
   StdOut.println(&ldquo;matrix scale: &rdquo; + visitTimesInAllPut.size() + &ldquo;, &rdquo;
     + maxComp);
   VisualAccumulator va = new VisualAccumulator(visitTimesInAllPut.size(),
     maxComp);
   for (int t = 0; t &lt; visitTimesInAllPut.size(); t++) {
    va.addDataValue(visitTimesInAllPut.get(t));
   }
  }
 }</p>

<p>FrequencyCounter类中演示成本只需要一条语句：</p>

<p> BinarySearchST&lt;String, Integer> st = new BinarySearchST&lt;String, Integer>(); // copy from original codes</p>

<p> st.getVisitTimes().drawCostCurve();</p>

<h2>BST</h2>

<p>即二叉查找树（binary search tree），原版代码见algs4-package.jar的BST.java类。</p>

<p> public class BST<Key extends Comparable<Key>, Value> {
  private final VisitTimeCounter vtc = new VisitTimeCounter();
  public VisitTimeCounter getVisitTimes() {
   return vtc;
  }
  public void put(Key key, Value val) {
   if (val == null) {
    delete(key);
    return;
   }
   root = put(root, key, val);
   vtc.putComplete();
   assert check();
  }
  private Node put(Node x, Key key, Value val) {
   if (x == null)
    return new Node(key, val, 1);
   int cmp = key.compareTo(x.key);
   vtc.addVisitTimes();
   if (cmp &lt; 0)
    x.left = put(x.left, key, val);
   else if (cmp > 0)
    x.right = put(x.right, key, val);
   else
    x.val = val;
   x.N = 1 + size(x.left) + size(x.right);
   return x;
  }
  private int rank(Key key, Node x) {
   if (x == null)
    return 0;
   int cmp = key.compareTo(x.key);
   vtc.addVisitTimes();
   if (cmp &lt; 0)
    return rank(key, x.left);
   else if (cmp > 0)
    return 1 + size(x.left) + rank(key, x.right);
   else
    return size(x.left);
  }
 }</p>

<p>查找成本体现在rank方法中，插入时每次访问的记录体现在private Node put方法中，总次数的记录体现在public void put方法中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BinarySearchST计算成本的测试代码]]></title>
    <link href="http://leetschau.github.io/blog/2013/01/26/231249/"/>
    <updated>2013-01-26T23:12:49+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/01/26/231249</id>
    <content type="html"><![CDATA[<p>下面是在原有BinarySearchST类上的修改，增加了两个成员（visitTimes与visitTime）和一个方法（getComparisionTimes），查找的成本主要体现在rank方法中的“cmp=key.compareTo(keys[m])”，在这一句后面加上visitTime++来标记访问次数增加了一次；写入的成本体现在put方法的两个位置，当key已经在keys中时，本次put的总成本是visitTime+1，当key不在keys数组中时（增加一个新元素），每移动一个元素，visitTime要加1，注意每次put操作记录结束后，除了要将次数存入visitTimes数组，还要将visitTime清零。</p>

<p>另外下面的代码省略了与原BinarySearchST类相同的成员和方法。</p>

<p> public class BinarySearchST<Key extends Comparable<Key>, Value> {
  private final List<Integer> visitTimes = new ArrayList<Integer>(); // 每次put访问数组的次数的集合
  int visitTime = 0; // 一次put操作中访问数组的次数计数器
  public Value get(Key key) {
   if (isEmpty())
    return null;
   int i = rank(key);
   visitTime++;
   if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0)
    return vals[i];
   return null;
  }
  public int rank(Key key) {
   int lo = 0, hi = N - 1;
   while (lo &lt;= hi) {
    int m = lo + (hi - lo) / 2;
    int cmp = key.compareTo(keys[m]);
    visitTime++;
    if (cmp &lt; 0)
     hi = m - 1;
    else if (cmp > 0)
     lo = m + 1;
    else {
     return m;
    }
   }
   return lo;
  }
  public void put(Key key, Value val) {
   if (val == null) {
    delete(key);
    return;
   }
   int i = rank(key);
   if (i &lt; N &amp;&amp; keys[i].compareTo(key) == 0) {
    vals[i] = val;
    visitTimes.add(visitTime + 1); // 查找了visitTime次，写入的成本是1
    visitTime = 0;
    return;
   }
   if (N == keys.length)
    resize(2 * keys.length);
   for (int j = N; j > i; j&ndash;) {
    keys[j] = keys[j - 1];
    vals[j] = vals[j - 1];
    visitTime++;
   }
   keys[i] = key;
   vals[i] = val;
   N++;
   visitTimes.add(visitTime);
   visitTime = 0;
   assert check();
  }
  public List<Integer> getComparisionTimes() {
   return visitTimes;
  }
 }</p>

<p>计算成本的图像演示代码FrequencyCounter类见笔记 SequentialSearchST算法成本的图形演示 。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SequentialSearchST算法成本的图形演示]]></title>
    <link href="http://leetschau.github.io/blog/2013/01/24/155123/"/>
    <updated>2013-01-24T15:51:23+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/01/24/155123</id>
    <content type="html"><![CDATA[<p>中文版238页图3.1.3演示了SequentialSearchST算法中每次写入单词数量（put方法中）时需要进行的比较次数，也就是此算法的成本，但书中没有生成此图的代码，下面是我自己的实现（第一个是新增的类，后两个是修改的类）：</p>

<p> package edu.princeton.cs.algs4;
 public class VisualAccumulator {
  private double total;
  private int N;
  public VisualAccumulator(int trials, double max) {
   StdDraw.setXscale(0, trials);
   StdDraw.setYscale(0, max);
   StdDraw.setPenRadius(.005);
  }
  public void addDataValue(double val) {
   N++;
   total += val;
   StdDraw.setPenColor(StdDraw.DARK_GRAY);
   StdDraw.point(N, val);
   StdDraw.setPenColor(StdDraw.RED);
   StdDraw.point(N, total / N);
   StdOut.println(&ldquo;Red point value:&rdquo; + total / N);// 平均比较次数
  }
  public double mean() {
   return total / N;
  }
  @Override
  public String toString() {
   return &ldquo;Mean (&rdquo; + N + &ldquo; values): &rdquo; + String.format(&ldquo;%7.5f&rdquo;, mean());
  }
  public static void main(String[] args) {
   int T = 300;
   VisualAccumulator a = new VisualAccumulator(T, 1.0);
   for (int t = 0; t &lt; T; t++) {
    a.addDataValue(StdRandom.random());
   }
   StdOut.println(a);
  }
 }</p>

<p> public class SequentialSearchST&lt;Key, Value> {
  private final List<Integer> compareTimes = new ArrayList<Integer>();
  public List<Integer> getComparisionTimes() {
   return compareTimes;
  }
  public void put(Key key, Value val) {
   int compareTime = 0;
   if (val == null) {
    compareTimes.add(1);
    delete(key);
    return;
   }
   for (Node x = first; x != null; x = x.next) {
    compareTime++;
    if (key.equals(x.key)) {
     x.val = val;
     compareTimes.add(compareTime);
     return;
    }
   }
   first = new Node(key, val, first);
   N++;
   compareTimes.add(compareTime);
  }
  public static void main(String[] args) {
   StdIn2.setInputFile(&ldquo;data/tale.txt&rdquo;);
   SequentialSearchST&lt;String, Integer> st = new SequentialSearchST&lt;String, Integer>();
   for (int i = 0; !StdIn2.isEmpty(); i++) {
    String key = StdIn2.readString();
    st.put(key, i);
   }
   List<Integer> comparisionTimes = st.getComparisionTimes();
   VisualAccumulator va = new VisualAccumulator(comparisionTimes.size(), 1.0);
   for (int t = 0; t &lt; comparisionTimes.size(); t++) {
    va.addDataValue(comparisionTimes.get(t));
   }
   for (String s : st.keys())
    StdOut.println(s + &ldquo; &rdquo; + st.get(s));
  }
 }</p>

<p> public class FrequencyCounter {
  public static void main(String[] args) {
   StdIn2.setInputFile(&ldquo;data/tale.txt&rdquo;);
   int distinct = 0, words = 0;
   int minlen = 8; // this is the first parameter
   SequentialSearchST&lt;String, Integer> st = new SequentialSearchST&lt;String, Integer>();
   while (!StdIn2.isEmpty()) {
    String key = StdIn2.readString();
    if (key.length() &lt; minlen)
     continue;
    words++;
    if (st.contains(key)) {
     st.put(key, st.get(key) + 1);
    } else {
     st.put(key, 1);
     distinct++;
    }
   }
   String max = &ldquo;&rdquo;;
   st.put(max, 0);
   for (String word : st.keys()) {
    if (st.get(word) > st.get(max))
     max = word;
   }
   StdOut.println(max + &ldquo; &rdquo; + st.get(max));
   StdOut.println(&ldquo;distinct = &rdquo; + distinct);
   StdOut.println(&ldquo;words = &rdquo; + words); // 以上是原始版本的代码，修改了获取输入的方法
   List<Integer> comparisionTimes = st.getComparisionTimes(); // 获取原始成本数据
   int maxComp = 0;
   for (Integer i : comparisionTimes) {
    if (i > maxComp) {
     maxComp = i;
    }
   } // 获得原始成本最大值，以确定画布的Y轴高度
   VisualAccumulator va = new VisualAccumulator(comparisionTimes.size(), maxComp);
   for (int t = 0; t &lt; comparisionTimes.size(); t++) {
    va.addDataValue(comparisionTimes.get(t));
   } // 画图
  }
 }</p>

<p>以上VisualAccumulator是完整的类，SequentialSearchST只写出了新增的属性compareTimes及其get方法，和修改后的put和main方法；FrequencyCounter类中修改后的main方法，</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调试Algorithms一书中带有输入重定向的代码]]></title>
    <link href="http://leetschau.github.io/blog/2013/01/23/125458/"/>
    <updated>2013-01-23T12:54:58+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/01/23/125458</id>
    <content type="html"><![CDATA[<p>Algorithms(by Robert Sedgewick)中运行算法程序一般是这样的：</p>

<p> java AlgorithmClass &lt; inputFile.txt</p>

<p>例如第47页"java BinarySearch tinyW.txt &lt; tinyT.txt"，其中的"&lt;&ldquo;是输入重定向（standard input redirect），即用文件（tiny.txt）的内容代替键盘（standard input）作程序的输入，在Eclipse中调试这种代码很麻烦，因为Eclipse不支持输入重定向（直接在参数里写&rdquo;&lt; tiny.txt"无效，但支持输出到某一指定文件中），有两个方法解决这个问题。</p>

<p>首先是准备工作：</p>

<ol>
<li><p>Create a project in eclipse, then creating a folder named &ldquo;data&rdquo; in it;</p></li>
<li><p>copy tinyT.txt &amp; tinyW.txt into &ldquo;data&rdquo;;</p></li>
</ol>


<h1>方法1：使用System.setIn()方法</h1>

<ol>
<li>modify &ldquo;int[] whitelist = In.readInts(args[0]);&rdquo; in BinarySearch.java as following:
System.setIn(new FileInputStream(&ldquo;data/tinyT.txt&rdquo;));
int[] whitelist = In.readInts(&ldquo;data/&rdquo; + &ldquo;tinyW.txt&rdquo;);</li>
<li>run BinarySearch;
Reference: <a href="http://stackoverflow.com/questions/188547/eclipse-reading-stdin-system-in-from-a-file">http://stackoverflow.com/questions/188547/eclipse-reading-stdin-system-in-from-a-file</a></li>
</ol>


<p>这个方法的不足之处是有时候程序在运行完后会报一个JNI异常，让人很不爽，于是有了下面第二个方法。</p>

<h1>方法2：自己修改StdIn类</h1>

<p>分析StdIn类的代码可知，它用了一个Scanner类包装了System.in，所以只要把System.in换成我们指定的文本文件就可以了，于是新建一个StdIn2类，代码与StdIn基本一样，增加了下面的方法：</p>

<p> public static void setInputFile(String path) {
  try {
   scanner = new Scanner(new BufferedInputStream(new FileInputStream(
     path)), charsetName);
  } catch (FileNotFoundException e) {
   e.printStackTrace();
  }
  scanner.useLocale(usLocale);
 }</p>

<p>其实就是把scanner的初始化方法放到了setInputFile中（包括声明scanner和static{}块中两处），然后修改算法代码：</p>

<ol>
<li><p>将BinarySearch中的StdIn重构为StdIn2；</p></li>
<li><p>main()方法的开始处加上"StdIn2.setInputFile(&ldquo;data/tiny.txt&rdquo;);&ldquo;；</p></li>
<li><p>运行代码。</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
