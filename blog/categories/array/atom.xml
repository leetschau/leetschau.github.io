<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Array | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/array/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-04-18T14:12:11+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ragged Array in Java]]></title>
    <link href="http://leetschau.github.io/blog/2014/06/11/150101/"/>
    <updated>2014-06-11T15:01:01+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/06/11/150101</id>
    <content type="html"><![CDATA[<p>Ragged array is a multi-dimensional array, whose elements has different length:</p>

<pre><code>$ cat Test.java
public class Test {
    public static void main(String[] args) {
        int[][] aa;
        aa = new int[3][];  // notice the unique way of it's initialization
        aa[0] = new int[2];
        aa[1] = new int[4];
        aa[2] = new int[5];
        aa[1][3] = 34;
        for (int i = 0; i &lt; aa.length; i++) {
            for (int j = 0; j &lt; aa[i].length; j++) {
                System.out.println("element aa[" + i + "][" + j + "] is: "
                        + aa[i][j]);
            }
        }
    }
}
$ javac Test.java
$ java Test
element aa[0][0] is: 0
element aa[0][1] is: 0
element aa[1][0] is: 0
element aa[1][1] is: 0
element aa[1][2] is: 0
element aa[1][3] is: 34
element aa[2][0] is: 0
element aa[2][1] is: 0
element aa[2][2] is: 0
element aa[2][3] is: 0
element aa[2][4] is: 0
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自动登录的实现方法]]></title>
    <link href="http://leetschau.github.io/blog/2012/07/23/164732/"/>
    <updated>2012-07-23T16:47:32+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/07/23/164732</id>
    <content type="html"><![CDATA[<h1>基于字节数组的定长队列</h1>

<p>这个队列可以在队尾追加（add）数据，由于是定长的，所以追加数据会将头部的数据“推出”队列。另外该队列可以检查是否包含（contains）某一子字符串，或者更进一步，检查是否包含某个用正则表达式表示的模式。这种数据结构主要用在Telnet Client的自动登录过程中，检查收到的报文中是否有预期的标志，以决定是否发送登录信息（用户名、密码等）。下面是一个实现：</p>

<p> public class ByteQueue {
  private final Logger logger = LoggerFactory.getLogger(this.getClass().getName());
  private final int BUFFER_LENGTH = 32;
  byte[] buffer = new byte[BUFFER_LENGTH];
  public void add(byte[] income, int len) {
   logger.debug(&ldquo;income is: &rdquo; + BytesHandler.bytes2HexString(income));
   byte[] tmp = new byte[BUFFER_LENGTH + len];
   System.arraycopy(buffer, 0, tmp, 0, buffer.length);
   System.arraycopy(income, 0, tmp, buffer.length, len);
   System.arraycopy(tmp, tmp.length - BUFFER_LENGTH, buffer, 0,
     BUFFER_LENGTH);
  }
  public boolean contains(String sub) {
   String bufStr = null;
   try {
    bufStr = new String(buffer, &ldquo;ISO8859-1&rdquo;);
   } catch (UnsupportedEncodingException e) {
    logger.error(&ldquo;bad encoding: ISO8859-1&rdquo;);
   }
   return bufStr.contains(sub);
  }
 }</p>

<p>上述&#8221;ISO8859-1&#8221;编码又名Latin-1，据“ ISO8859-1、UTF-8 与GB2312 ”一文是Java网络传输的标准编码，又据“ Java: Regex on byte array ”一文，这是一个单字节的编码方案，所以可以用字符串的contains方法完成字节的查找。“ 字符在utf-8,gbk,gb2312,iso8859-1下的编码实验 ”的结果很有参考价值。</p>

<p>下面的代码演示了如何使用上面的类完成自动登录：</p>

<p> ByteQueue bq = new ByteQueue();
 while (true) {
  byte[] buf = new byte[128];
  int recv = nis.read(buf);
  if (recv == -1) {
   logger.info(&ldquo;read -1 from client.&rdquo;);
   break;
  }
  logger.debug(&ldquo;client send: &rdquo;
    + BytesHandler.bytes2HexString(buf));
  uout.write(buf, 0, recv);
  uout.flush();
  // execute login script</p>

<p>  String expTest = expQ.peek(); //expQ是预期队列：&#8221;ogin:&ldquo;, &#8220;assword:&#8221;，sendQ是发送队列：&#8221;myusername&rdquo;, &ldquo;mypwd&rdquo;
  if (expTest != null) {
   bq.add(buf, recv); //由于buf是定长数组，其中会有很多0，所以add的第二个参数len标示了有效数据的长度很重要
   if (bq.contains(expTest)) {
    String exp = expQ.poll() + &ldquo;\r\n&rdquo;; // 一定不要忘了加回车！
    String send = sendQ.poll() + &ldquo;\r\n&rdquo;;
    nos.write(send.getBytes(&ldquo;UTF-8&rdquo;));
    nos.flush();
   }
  }
 }</p>

<h1>打印字节数组内容（调试时很有用）</h1>

<p> public static String bytes2HexString(byte[] b) {
  String ret = &ldquo;&rdquo;;
  for (int i = 0; i &lt; b.length; i++) {
   String hex = Integer.toHexString(b[i] &amp; 0xFF);
   if (hex.length() == 1) {
    hex = &lsquo;0&rsquo; + hex;
   }
   ret += hex.toUpperCase();
  }
  return ret;
 }</p>
]]></content>
  </entry>
  
</feed>
