<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 阻塞 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/zu-sai/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-08-11T14:15:46+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ConcurrentLinkedQueue vs LinkedBlockingQueue]]></title>
    <link href="http://leetschau.github.io/blog/2013/02/04/151243/"/>
    <updated>2013-02-04T15:12:43+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/02/04/151243</id>
    <content type="html"><![CDATA[<p>根据LinkedBlockingQueue实现的接口BlockingQueue的文档，BlockingQueue及其所有实现类都是线程安全的，且可用于多个Producer/Consumer的场景，它的主要用途是Producer-Consumer模型，它提供了4种出/入队列的方法，分别是抛异常、特殊值、阻塞和超时。</p>

<p>LinkedBlockingQueue初始化时可以设置容量，所以BlockingQueue具备一种“流量平衡”能力，即当消费过快以至于队列空时，出队列（消费）操作将阻塞；生产过快以至于队列满时，入队列（生产）操作将阻塞。</p>

<p>BlockingQueue的take()方法在阻塞状态下是不消耗CPU的。</p>

<p>ConcurrentLinkedQueue是一个"wait-free" algorithm（见文档），它的使用场景目前还不清楚。</p>

<p>参考：</p>

<p> <a href="http://stackoverflow.com/questions/1426754/linkedblockingqueue-vs-concurrentlinkedqueue">http://stackoverflow.com/questions/1426754/linkedblockingqueue-vs-concurrentlinkedqueue</a></p>

<p> <a href="http://stackoverflow.com/questions/1426342/need-a-queue-that-can-support-multiple-readers/1426375#1426375">http://stackoverflow.com/questions/1426342/need-a-queue-that-can-support-multiple-readers/1426375#1426375</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用输入流读取数据时的阻塞问题]]></title>
    <link href="http://leetschau.github.io/blog/2010/08/20/085649/"/>
    <updated>2010-08-20T08:56:49+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/08/20/085649</id>
    <content type="html"><![CDATA[<p>使用java.io.BufferedInputStream.read(byte[])方法读取Socket中传过来的数据时，如果需要超时退出判断机制，一定要注意B ufferedInputStream.available()的使用。下面的代码片段是一个很标准的读取过程，其中第5行的判断很重要，因为read( byte[] )方法本身是阻塞的，如果自始至终is没有收到任何数据，就会一直阻塞在read()方法上（第6行），导致整个超时判断机制失去作用，而 available()方法的使用避免了这种可能性。</p>

<p> 示例程序代码：</p>

<p> 01      try {   02           long startTime = System.currentTimeMillis();   03           while (someCriteria) {   04                byte[] cache = new byte[1024];   05                if (is.available() > 0) {   06                     int count = is.read(cache);   07                     if (count &lt;= 0) {   08                          if (System.currentTimeMillis() - startTime >= timeout) {   09                               throw new GapiException(&ldquo;Connection Time Out!&rdquo;);   10                          }   11                          continue;   12                     }   13                     // 后续处理   14                }   15                if (System.currentTimeMillis() - startTime >= timeout) {   16                     throw new GapiException(&ldquo;Connection Time Out!&rdquo;);   17                }   18                Thread.sleep(10);   19           }   20      } catch (Exception e) {   21           logger.error(&ldquo;ERROR: &rdquo;, e);   22      }</p>

<p> 程序流程图：</p>
]]></content>
  </entry>
  
</feed>
