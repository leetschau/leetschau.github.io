<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 转换 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/zhuan-huan/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-04-30T16:15:37+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[制表符转换为空格]]></title>
    <link href="http://leetschau.github.io/blog/2011/09/24/174145/"/>
    <updated>2011-09-24T17:41:45+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/09/24/174145</id>
    <content type="html"><![CDATA[<p>由于制表符的不定长特性，在纯文本显示时经常出现不能对齐的问题，因此一般需要转换为空格，Ultraedit有这个功能，但实际上Notepad2也有这个能力：</p>

<p>选中要转换的文字后【Edit->Convert->Untabify Selection】。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[日期格式转换的正则表达式实现]]></title>
    <link href="http://leetschau.github.io/blog/2011/07/19/164331/"/>
    <updated>2011-07-19T16:43:31+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/07/19/164331</id>
    <content type="html"><![CDATA[<p>原始文本：</p>

<blockquote><p>2011年7月18日：修改密码的核心功能开发完毕；
2011年7月19日：上午换座位，下午提交了著作权文档的电子流程；</p></blockquote>

<p>目标格式文本：</p>

<blockquote><p>2011-7-18：修改密码的核心功能开发完毕；
2011-7-19：上午换座位，下午提交了著作权文档的电子流程；</p></blockquote>

<h1>vim实现</h1>

<pre><code>:%s/\(\d\{4}\).\(\d\{1,2}\).\(\d\{1,2}\)./\1-\2-\3/g 
</code></pre>

<p>说明： 采用 :%s/old/new/g 命令进行替换，其中%表示对所有行进行替换操作，最后的g参数表明对一行中所有的new均替换为old。\d代表任意数字，old pattern中每个括号（即(&hellip;)）中的内容构成一个group member，new pattern中对group member的引用用\1、\2、\3&hellip;代表，即"BRE", back references.</p>

<h1>Groovy实现</h1>

<pre><code>oriStr = '''2011年7月18日：修改密码的核心功能开发完毕； 
2011年7月19日：上午换座位，下午提交了著作权文档的电子流程；'''; 
pattern = /(\d{4})\W(\d{1,2})\W(\d{1,2})\W/; 
matcher = oriStr =~ pattern; 
matcher.each { all,y,m,d-&gt; 
    println 'Patten is: '+all; 
    println 'Replaced by: '+y+'-'+m+'-'+d; 
}; 
println '*****'; 
println oriStr.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d;}; 
</code></pre>

<p>运行结果：</p>

<pre><code>Patten is: 2011年7月18日 
Replaced by: 2011-7-18 
Patten is: 2011年7月19日 
Replaced by: 2011-7-19 
***** 
2011-7-18：修改密码的核心功能开发完毕； 
2011-7-19：上午换座位，下午提交了著作权文档的电子流程； 
</code></pre>

<p>说明： 跨行字符串用三引号括起来；匹配模式用“ /&hellip;/” 括起来；用模式匹配字符串时，每一次成功匹配构成了matcher的一个元素（代码中用matcher.each得到），如果模式当中包含group（可以matcher.hasGroup()判断），则这个元素本身也是一个List，其中第一个元素是符合模式的substring（代码中的all），各个group member可以用下标引用，也可以分别起名字（代码中分别为y、m、d）。这部分内容可参见《Groovy in Action》（2007版）第3.5节“Working with regular expressions”。Groovy的String.replaceAll方法包括两个参数，第一个是要被代替的pattern，第二个是用来代替pattern的closure，该closure的返回结果是最后一行代码的值。</p>

<p>例如：<code>println oriStr.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d;return 'Date'};</code> 的输出是：</p>

<pre><code>Date：修改密码的核心功能开发完毕； 
Date：上午换座位，下午提交了著作权文档的电子流程； 
</code></pre>

<h1>基于文件读写的Groovy实现</h1>

<pre><code>pattern = /(\d{4})\W(\d{1,2})\W(\d{1,2})\W/; 
convStr = ''; 
new File('f:/Edit3.txt').eachLine{ 
    convStr += (it.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d})+'\n' 
} 
new File('f:/conv.txt').write convStr; 
</code></pre>

<p>说明： 第4行的it表示此行文本（字符串）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[射手网字幕编码修改笔记]]></title>
    <link href="http://leetschau.github.io/blog/2011/05/19/094133/"/>
    <updated>2011-05-19T09:41:33+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/05/19/094133</id>
    <content type="html"><![CDATA[<p>用射手播放器自动下载的视频用文本编辑器打开后经常是乱码，实验后发现主要是由于这些文件使用Big5编码格式，用Notepad2就可以进行编码转换，但Notepad2没有中文繁简体转换的功能，用Word进行转换是一种比较完整的解决方案，下面是详细操作过程：</p>

<p>用Word打开这个srt文件，Word会自动侦测其编码格式；</p>

<p>打开文件后，选中所有文本后用【审阅->繁转简】转为简体并保存：在【是否保存为这种格式】对话框里选“否”，然后在保存对话框中将【保存类型】选为【纯文本(*.txt)】，文件名框中将扩展名改为srt，在随后出现的编码对话框里【文本编码】选【其他编码】，在编码列表里选【Unicode (UTF-8)】，确定即可。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从CD光盘制作适合MP4播放的音乐文件]]></title>
    <link href="http://leetschau.github.io/blog/2011/03/05/093310/"/>
    <updated>2011-03-05T09:33:10+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/03/05/093310</id>
    <content type="html"><![CDATA[<p>将CD盘制作为无损的APE/FLAC格式是最佳选择，但制作要分两步，首先将CD中的音轨抓取出来成为wav文件（推荐使用EAC(Exact Audio Copy)），然后用wav文件制作APE/FLAC文件（推荐使用Monkey&rsquo;s Audio），比较麻烦，对于音源（CD盘）和外设（音响、耳机）质量都很一般的我而言，实在没必要这么严格。经过试验发现用Windows Media Player自带的“音频无损”方式制作出来的wma文件质量完全能满足我的要求，具体制作方法如下：</p>

<p>1.打开Windows Media Player，主菜单【工具->选项->翻录音乐】，【翻录音乐到此位置】下面设置好输出wma文件的位置，【翻录设置】下面的“格式”选【Windows Media音频无损】，【确定】。找不到主菜单？把Media Player窗口上能点的按钮都点一遍总能找到的，比如最小化按钮左边那个倒三角按钮。</p>

<p>2.插入CD，切换到【翻录】面板，勾上要翻录的音乐，【翻录音乐】。</p>

<p>bingo，把喜欢的CD放进MP4随时欣赏吧:)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用AutoHotkey做汉字到Unicode字符串的转换]]></title>
    <link href="http://leetschau.github.io/blog/2011/03/04/164916/"/>
    <updated>2011-03-04T16:49:16+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/03/04/164916</id>
    <content type="html"><![CDATA[<p>要把汉字转换为&#x641C;的形式，也就是在汉字的Unicode Big Endian编码前面加“&amp;#x”，后面加分号。例如“”字转换后为“&#x641C;”（英文字符无需转换）。</p>

<p>前置条件：native2ascii.exe文件，autohotkey。</p>

<p>算法流程：</p>

<p>输入要转换的汉字；
生成临时文件；
用native2ascii处理该文件；
获取native2ascii的输出放入字符串res中；
以“\u”分割res，以“&#xAAAA;”形式重新组合，存入字符串res2； 将res2放入剪贴板；
AHK源码：</p>
]]></content>
  </entry>
  
</feed>
