<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Haskell | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-01-23T11:15:02+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Note About `Programming in Haskell`]]></title>
    <link href="http://leetschau.github.io/blog/2013/12/16/174627/"/>
    <updated>2013-12-16T17:46:27+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/12/16/174627</id>
    <content type="html"><![CDATA[<h1>1.7 Exercises</h1>

<ol>
<li>How should the definition of the function qsort be modified so that it produces a reverse sorted version of a list?</li>
</ol>


<p> qsort :: Ord a => [a] -> [a]
 qsort [] = []
 qsort (x:xs) = qsort bigger ++ [x] ++ qsort smaller where
     smaller = filter (&lt;=x) xs
     bigger = filter (>x) xs</p>

<h1>Type and Class</h1>

<p>Recall that a type is a collection of related values. Building upon this notion, a class is a collection of types that support certain overloaded operations called methods. &ndash; Section 3.9: Basic Classes</p>

<h1>Patterns Matching</h1>

<p>Section 4.4, excellent explanation about tuple pattern, list pattern and integer pattern.</p>

<p>Note that cons patterns must be parenthesised, because function application has higher priority than all other operators. (p34)</p>

<h1>4.8 Exercises</h1>

<ol>
<li>Splits an even-lengthed list into two halves:</li>
</ol>


<p> halve :: [a] -> ([a], [a])</p>

<p> halve x = splitAt (div (length x) 2) x</p>

<ol>
<li>safetail</li>
</ol>


<p> safetail :: [a] -> [a]</p>

<p> &ndash; conditional expression</p>

<p> safetail xs = if null xs then []</p>

<pre><code>    else tail xs
</code></pre>

<p> &ndash; guarded equation</p>

<p> safetail xs | null xs = []</p>

<pre><code>| otherwise = tail xs
</code></pre>

<p> &ndash; pattern matching</p>

<p> safetail [] = []</p>

<p> safetail xs = tail xs</p>

<h1>5.7 Exercies</h1>

<ol>
<li><p>sum [x**2|x&lt;-[1..100]]</p></li>
<li><p>replicate n x = [x | t &lt;- [1..n]]</p></li>
</ol>


<p> (answer of textbook: replicate n x = [x|_&lt;-[1..n]]</p>

<ol>
<li>Find pythagorean triples:</li>
</ol>


<p> pyths n = [(x,y,z)|x&lt;-[1..n], y&lt;-[1..n], z&lt;-[1..n], x<strong>2+y</strong>2==z**2]</p>

<ol>
<li>Find perfects number:</li>
</ol>


<p> factors n = [x | x &lt;- [1..n-1], n <code>mod</code> x == 0]</p>

<p> perfects n = [x|x&lt;-[1..n], x == sum (factors x)]</p>

<h1>sat function in Chapter 8</h1>

<p>The codes in section 8.1~8.3 and 8.6 doesn&rsquo;t work. The author explained it in chapter remarks(section 8.9) and the errata (Pages 74 to 78&hellip;). He also gave a monad version of &ldquo;Parser&rdquo; in his website: <a href="http://www.cs.nott.ac.uk/~gmh/Parsing.lhs">Code -> Parsing</a>. So I am afraid we have to learn some monads then come back to this interesting Haskell parser.</p>

<p>Ref: <a href="http://stackoverflow.com/questions/2607498/programming-in-haskell-error-in-sat-function">http://stackoverflow.com/questions/2607498/programming-in-haskell-error-in-sat-function</a></p>

<h1>Chapter 9</h1>

<h2>Clear Screen</h2>

<p>MyClr.hs:</p>

<p> module Main where
 cls :: IO ()
 cls = putStr &ldquo;\ESC[2J&rdquo;
 bingo :: IO ()
 bingo = putStr &ldquo;bingo!\n&rdquo;
 main = do cls
    bingo</p>

<p>$ ghc MyClr.hs</p>

<p>$ ./MyClr</p>

<p>You have to remove the type declaration sentences.</p>

<h2>StrLen</h2>

<p> strLen :: IO ()
 strLen = do putStr &ldquo;Enter a string: &rdquo;
    xs &lt;- getLine
    putStr &ldquo;The string has &rdquo;
    putStr (show (length xs))
    putStrLn &ldquo; characters.&rdquo;</p>

<p>Then load in ghci and run &ldquo;strLen&rdquo;.</p>

<h2>goto (in ghci)</h2>

<p> let goto (x,y) = putStr (&ldquo;\ESC[&rdquo; ++ show y ++ &ldquo;;&rdquo; ++ show x ++ &ldquo;H&rdquo;)</p>

<p> goto (20,20)</p>

<h1>Chapter 10</h1>

<h2>Normal Functions and Constructor Function</h2>

<p> data Shape = Circle Float | Rect Float Float</p>

<p>The constructors Circle and Rect are actually constructor functions, which produce results of type Shape from arguments of type Float . The difference between normal functions and constructor functions is that the latter have no defining equations, and exist solely for the purpose of building pieces of data. The expression Circle 1.0 is just a piece of data, in the same way that 1.0 itself is just data.</p>

<h2>Diferent Kinds of tree</h2>

<p>The parameter type &ldquo;a&rdquo; represents the stored data.</p>

<ul>
<li><p>Store data only in leaves: data Tree a = Leaf a | Node (Tree a) (Tree a)</p></li>
<li><p>Store data only in nodes:</p></li>
</ul>


<p> data Tree a = Leaf | Node (Tree a) a (Tree a)</p>

<p>and:</p>

<p> data Tree a = Node a [Tree a ]</p>

<ul>
<li>Store data both in leaves (data type is &ldquo;a&rdquo;) and nodes (data type is &ldquo;b&rdquo;):</li>
</ul>


<p> data Tree a b = Leaf a | Node (Tree a b) b (Tree a b)</p>

<h1>Chapter 11</h1>

<p> results ns = [res| (ls,rs) &lt;- split ns,
      lx &lt;- results ls,
      ry &lt;- results rs,
      res &lt;- combine&#8217; lx ry]</p>

<p>Above is a imperative-style calculation in list comprehension. The cost is you have to put your result in a list, while empty list means failure of calculation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell Interactive Development in Emacs]]></title>
    <link href="http://leetschau.github.io/blog/2013/12/16/113414/"/>
    <updated>2013-12-16T11:34:14+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/12/16/113414</id>
    <content type="html"><![CDATA[<h1>Installation</h1>

<p>Following <a href="https://github.com/haskell/haskell-mode">haskell-mode</a>.</p>

<ol>
<li>Use MELPA repository: add the following into ~/.emacs</li>
</ol>


<p> (require &lsquo;package)
 (add-to-list &#8216;package-archives
    &rsquo;(&ldquo;melpa&rdquo; . &ldquo;<a href="http://melpa.milkbox.net/packages/">http://melpa.milkbox.net/packages/</a>&rdquo;) t)
 (package-initialize)</p>

<ol>
<li><p>M-x package-refresh-contents</p></li>
<li><p>M-x package-install [RET] haskell-mode</p></li>
</ol>


<h1>Usage</h1>

<ol>
<li><p>Open a haskell file in emacs;</p></li>
<li><p>Use &ldquo;C-c C-z&rdquo; to open ghci (but there isn&rsquo;t a jump-back shortcut, you can use C-x o);</p></li>
<li><p>Use &ldquo;C-c C-l&rdquo; to load file (same as &ldquo;:l <file_name>&rdquo;);</p></li>
</ol>


<p>However, there isn&rsquo;t tab-completion in the ghci invoked by &ldquo;C-c C-z&rdquo;, so you can start a console to run ghci;</p>

<h1>User Manual</h1>

<p>M-x info-display-manual [RET] haskell-mode</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note About `Yet Another Haskell Tutorial`]]></title>
    <link href="http://leetschau.github.io/blog/2013/12/15/212740/"/>
    <updated>2013-12-15T21:27:40+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/12/15/212740</id>
    <content type="html"><![CDATA[<h1>Exercises Solutions</h1>

<p><a href="http://en.wikibooks.org/wiki/Haskell/YAHT">http://en.wikibooks.org/wiki/Haskell/YAHT</a></p>

<h1>Exercise 3.10</h1>

<p>Save the following scripts in SumInputs.hs:</p>

<p> module Main where
 main = do
  inputNumbers &lt;- getNumber
  putStrLn (&ldquo;The sum is &rdquo; ++ show (sum inputNumbers))
  putStrLn (&ldquo;The product is &rdquo; ++ show (foldr (*) 1 inputNumbers))
  printFactorials inputNumbers
 getNumber = do
  putStrLn &ldquo;Give me a number (or 0 to stop): &rdquo;
  number &lt;- getLine
  let num = read number
  if num == 0
   then return []
   else do
    rest &lt;- getNumber
    return (num : rest)
 printFactorials [] = putStrLn &ldquo;&rdquo;
 printFactorials (x:xs) = do
  putStrLn (show x ++ &ldquo; factorial is: &rdquo; ++ show (factorial x))
  printFactorials xs
 factorial 1 = 1
 factorial n = n * factorial (n-1)</p>

<ul>
<li><p>Run it in ghci: main</p></li>
<li><p>Compile and run in console:</p></li>
</ul>


<p> ghc &ndash;make SumInputs.hs -o myfac</p>

<p> ./myfac</p>

<h1>Exercise 4.4 &amp; 4.5</h1>

<p> data Pair a b = Pair a b
 pairFst (Pair x y) = x
 pairSnd (Pair x y) = y
 data Triple a b c = Triple a b c
 tripleFst :: Triple a b c -> a
 tripleFst (Triple a b c) = a
 tripleSnd (Triple a b c) = b
 tripleThr (Triple a b c) = c
 data Quadruple a b = Quadruple a a b b deriving (Show)
 firstTwo :: Quadruple a b -> [a]
 &ndash; you can&rsquo;t write it as: &hellip; -> [a, a]. This is not a valid type expression?
 firstTwo (Quadruple w x y z) = [w, x]</p>

<p> lastTwo :: Quadruple a b -> [b]
 lastTwo (Quadruple w x y z) = [y, z]</p>

<h1>Exercise 4.6</h1>

<p> data Tuple a b c d = Tuple1 a
      | Tuple2 a b
      | Tuple3 a b c
      | Tuple4 a b c d
      deriving (Show)
 tuple1 :: Tuple a b c d -> a
 tuple1 (Tuple1 x) = x
 tuple1 (Tuple2 x y) = x
 tuple1 (Tuple3 x y z) = x
 tuple1 (Tuple4 x y z t) = x
 tuple2 :: Tuple a b c d -> Maybe b
 tuple2 (Tuple1 x) = Nothing
 tuple2 (Tuple2 x y) = Just y
 tuple2 (Tuple3 x y z) = Just y
 tuple2 (Tuple4 x y z t) = Just y
 tuple3 :: Tuple a b c d -> Maybe c
 tuple3 (Tuple1 x) = Nothing
 tuple3 (Tuple2 x y) = Nothing
 tuple3 (Tuple3 x y z) = Just z
 tuple3 (Tuple4 x y z t) = Just z
 tuple4 :: Tuple a b c d -> Maybe d
 tuple4 (Tuple1 x) = Nothing
 tuple4 (Tuple2 x y) = Nothing
 tuple4 (Tuple3 x y z) = Nothing
 tuple4 (Tuple4 x y z t) = Just t</p>

<p>Pattern matching plays a big role in tuple-like data structure.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell Command-line Application Building]]></title>
    <link href="http://leetschau.github.io/blog/2013/12/15/122240/"/>
    <updated>2013-12-15T12:22:40+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/12/15/122240</id>
    <content type="html"><![CDATA[<h1>Haskeline Package</h1>

<p><a href="http://hackage.haskell.org/package/haskeline">Haskeline</a> provides a user interface for line input in command-line programs. This library is similar in purpose to readline, but since it is written in Haskell it is (hopefully) more easily used in other Haskell programs.</p>

<p>A tab-completion solution based on haskeline: <a href="http://stackoverflow.com/questions/6147201/haskell-haskeline-word-completion">Haskell (haskeline) word completion</a></p>

<h1>Command Suite Parse</h1>

<p><a href="http://hackage.haskell.org/package/console-program">console-program</a> provides an infrastructure to build command line programs. It provides the following features:</p>

<ul>
<li><p>Declare any number of &ldquo;commands&rdquo; (modes of operation) of the program;</p></li>
<li><p>Declare options of these commands;</p></li>
<li><p>Collect options from a configuration file and the command line, and execute the proper command;</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell Notes]]></title>
    <link href="http://leetschau.github.io/blog/2011/05/13/163122/"/>
    <updated>2011-05-13T16:31:22+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/05/13/163122</id>
    <content type="html"><![CDATA[<h1>Installation</h1>

<pre><code>sudo apt-get install aptitude
sudo aptitude install haskell-platform
</code></pre>

<p>verified on Linux Mint 14 Xfce.</p>

<p>Install hoogle (offline documentation of Haskell):</p>

<pre><code>cabal update
cabal install alex happy &amp;&amp; cabal install hoogle
</code></pre>

<p>Ref: <a href="http://stackoverflow.com/questions/11753979/cabal-install-hoogle-error">http://stackoverflow.com/questions/11753979/cabal-install-hoogle-error</a></p>

<p>Very slow, you can use <a href="http://www.haskell.org/hoogle/">the online version</a>;</p>

<p>modify ~/.cabal/conifg:</p>

<pre><code>remote-repo: old.hackage.haskell.org:http://old.hackage.haskell.org
</code></pre>

<p>Ref:</p>

<p><a href="http://hackage.haskell.org/">http://hackage.haskell.org/</a></p>

<p><a href="http://www.haskell.org/haskellwiki/Hoogle">http://www.haskell.org/haskellwiki/Hoogle</a></p>

<pre><code>$ cabal update
$ cabal install hoogle
$ ~/.cabal/bin/hoogle data # create database
$ ~/.cabal/bin/hoogle map # search "map"
</code></pre>

<p>Save the following lines to ~/.ghci to enable you use &ldquo;:hoogle&rdquo; or &ldquo;:doc&rdquo; to get doc info in ghci:</p>

<pre><code>:def hoogle \x -&gt; return $ ":!hoogle \"" ++ x ++ "\""       
:def doc \x -&gt; return $ ":!hoogle --info \"" ++ x ++ "\""
</code></pre>

<h1>Sample Project</h1>

<p>Based on <a href="http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program;">http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program;</a></p>

<ol>
<li><p>create home folder: <code>take haq</code>;</p></li>
<li><p>create source file &ldquo;Haq.hs&rdquo;;</p></li>
<li><p>stick it in version control:</p>

<pre><code> git init
 git add Haq.hs
 git commit -m "add first source"
</code></pre></li>
<li><p>add a build system: <code>cabal init</code>;</p></li>
<li><p>modify .cabal file: add &ldquo;Haq.hs&rdquo; after &ldquo;&ndash; main-is:&rdquo; and uncomment this line(delete &ldquo;&ndash;&rdquo;); If you donot specify the license type, comment out the line &ldquo;license-file&rdquo;;</p></li>
<li><p>cabal update</p></li>
<li><p>cabal install &ndash;prefix=<dst_folder> &ndash;user</p></li>
<li><p>run app: <code>bin/haq me</code> under <dst_folder>, or run app in-place (under current directory): dist/build/haq/haq me</p></li>
</ol>


<p>verified on Haskell Platform 7.4.2, Linux Mint 14:</p>

<p>$ ghc &ndash;version</p>

<p>The Glorious Glasgow Haskell Compilation System, version 7.4.2</p>

<h1>Miscellaneous</h1>

<ul>
<li><p>ghc: compiler</p></li>
<li><p>ghci: interactive shell;</p></li>
<li><p>runghc: run haskell script without compile</p></li>
<li><p>Compile haskell source file to executable:</p>

<pre><code>  $ ghc --make &lt;FileName&gt;.hs -o &lt;ExeFileName&gt;
</code></pre></li>
</ul>


<p>for example:</p>

<pre><code>$ ghc --make Test.hs -o test
</code></pre>

<h1>GHCi usage</h1>

<ul>
<li><p>get current working directory: :!pwd (you can use :!<shell_cmd> to run any shell command);</p></li>
<li><p>turn on/off type declaration: :set +t, :unset +t</p></li>
<li><p>get type information of a object: :t</p></li>
<li><p>define local variable and show bindings:</p>

<pre><code>  let x = 3, 
  :show bindings
</code></pre></li>
<li><p>load module: :m +Data.Ratio</p></li>
<li><p>change cwd: :cd <path_name></p></li>
<li><p>load file: :l <file_name></p></li>
<li><p>quit ghci shell: :q</p></li>
<li><p>get function doc: :i <func_name></p></li>
</ul>


<h1>Syntax</h1>

<ul>
<li><p>comments: &ndash;</p></li>
<li><p>comparison: /=, >, &lt;</p></li>
<li><p>boolean operation: not, || , &amp;&amp;</p></li>
<li><p>Haskell requires type names to start with an uppercase letter, and variable names must start with a lowercase letter.</p></li>
<li><p>To construct a rational number: 11 % 29 (after &ldquo;:m +Data.Ratio&rdquo;)</p></li>
<li><p>values in &ldquo;where&rdquo;, &ldquo;case&rdquo; and &ldquo;let&rdquo; clause must keep the SAME indentions;</p></li>
</ul>


<h1>Shell Interaction Library</h1>

<p>shqq, shelly</p>

<p>Ref: <a href="http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts">Shelly: Write your shell scripts in Haskell</a></p>
]]></content>
  </entry>
  
</feed>
