<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Haskell | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-11-11T15:03:30+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Option类型的实现方法比较]]></title>
    <link href="http://leetschau.github.io/blog/2016/04/19/120234/"/>
    <updated>2016-04-19T12:02:34+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/04/19/120234</id>
    <content type="html"><![CDATA[<p>Scala的Option类型定义在
<a href="https://github.com/scala/scala">scala/scala</a>的src/library/scala/Option.scala中：</p>

<pre><code>sealed abstract class Option[+A]
final case class Some[+A](x: A) extends Option[A]
case object None extends Option[Nothing]
</code></pre>

<p>对应的Haskell定义是： <code>data Maybe a = Nothing | Just a</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[几种常用语言处理文本的效率比较]]></title>
    <link href="http://leetschau.github.io/blog/2016/04/15/171843/"/>
    <updated>2016-04-15T17:18:43+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/04/15/171843</id>
    <content type="html"><![CDATA[<p>读一个37264行，大小为81MB的文本文件f4.json，计算每行的单词数，然后打印出总单词数，
Python用时0.16秒，Ruby用时1.16秒，Haskell用时13.4秒，分别差一个数量级。
下面是测试脚本和过程：</p>

<p>wordcount.py:
<code>
inp = 'f4.json'
counts = []
with open(inp) as f:
  for line in f:
    counts.append(len(line.split()))
print(sum(counts))
</code></p>

<p>wordcount.rb:
<code>
inp = 'f4.json'
words = []
File.open(inp).each do |line|
  words.push(line.split.size)
end
puts words.reduce(0, :+)
</code></p>

<p>WordCount.hs:
```
main :: IO ()
main = do
input &lt;- readFile &ldquo;f4.json&rdquo;
print $ sum(countWords input)</p>

<p>countWords input = map (length.words) (lines input)
<code>
测试过程：
</code>
wc -l f4.json
37264 f4.json</p>

<p>time python wordcount.py
1103404
python wordsum.py  0.14s user 0.01s system 99% cpu 0.157 total</p>

<p>time ruby wordsum.rb
1103404
ruby wordsum.rb  1.13s user 0.02s system 99% cpu 1.158 total</p>

<p>time runhaskell Main.hs
1105752
runhaskell wordcount.hs  12.64s user 0.76s system 100% cpu 13.395 total</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Haskell Develop Environment in Atom]]></title>
    <link href="http://leetschau.github.io/blog/2016/03/04/113755/"/>
    <updated>2016-03-04T11:37:55+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/03/04/113755</id>
    <content type="html"><![CDATA[<p><a href="https://atom.io/packages/ide-haskell">IDE-Haskell</a> is a good choice
for haskell editor.</p>

<h1>Installation</h1>

<pre><code>$ cabal update
$ cabal install ghc-mod stylish-haskell
$ ghc-mod --version
ghc-mod version 5.5.0.0 compiled by GHC 7.10.2
</code></pre>

<p>Download Atom 1.5 (atom-amd64.deb),
install it with <code>sudo dpkg -i atom-amd64.deb</code>, and run:</p>

<pre><code>$ apm install language-haskell haskell-ghc-mod ide-haskell-cabal ide-haskell autocomplete-haskell ide-haskell-repl
</code></pre>

<p>Open Atom, Ctrl-Shift-P, open &ldquo;View Installed Packages&rdquo;,
click &ldquo;Settings&rdquo; of haskell-ghc-mod,
input full path of ghc-mod and ghc-modi in &ldquo;Ghc Mod Path&rdquo; and &ldquo;Ghc Modi Path&rdquo;,
here &ldquo;/home/leo/.cabal/bin/ghc-mod&rdquo; and &ldquo;/home/leo/.cabal/bin/ghc-modi&rdquo;.</p>

<p>Click &ldquo;Settings&rdquo; of ide-haskell,
input full path of stylish-haskell in &ldquo;Stylish Haskell Path&rdquo;,
here it&rsquo;s &ldquo;/home/leo/.cabal/bin/stylish-haskell&rdquo;.</p>

<p>Restart Atom, open a folder contains haskell .hs files to use ide-haskell.</p>

<h2>GHCi in Atom</h2>

<p>Click &ldquo;Settings&rdquo; of ide-haskell-repl,
set &ldquo;Command Args&rdquo; to &ldquo;ghci&rdquo;, and &ldquo;Command Path&rdquo; to &ldquo;/usr/bin/stack&rdquo;,
when you use stack. (This works fine in Atom 1.5).
Set &ldquo;Command Args&rdquo; to &ldquo;repl&rdquo;, and &ldquo;Command Path&rdquo; to &ldquo;/home/leo/.local/bin/cabal&rdquo;,
when you use cabal. (This doesn&rsquo;t work in Atom 1.5).</p>

<p>To load chapter 2 of &ldquo;Learning Haskell Data Analysis&rdquo;
into ide-haskell-repl, you must install required libraries with stack:</p>

<pre><code>stack install csv HDBC sqlite HDBC-sqlite3
</code></pre>

<p>Then open file &ldquo;LearningDataAnalysis02.hs&rdquo; in Atom,
click [Haskell IDE -> Open REPL] in main menu,
now module &ldquo;LearningDataAnalysis02&rdquo; is loaded into ghci.
Input <code>parseCSVFromFile "all_week.csv"</code> in repl box,
press Shift+Enter to evluate it.</p>

<p>See all keybindings in &ldquo;Keybindings&rdquo; of ide-haskell-repl
in Atom package settings.</p>

<h1>Discussion</h1>

<p>Ensure ghc-mod version > 5.4.
Do NOT install it with <code>apt-get</code>, because its version is 3.x.
See <a href="https://github.com/atom-haskell/haskell-ghc-mod#configuration">https://github.com/atom-haskell/haskell-ghc-mod#configuration</a> for details.</p>

<p>If you only install stack instead of cabal, you can install Haskell package with
<code>stack install ghc-mod stylish-haskell</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cabal Notes]]></title>
    <link href="http://leetschau.github.io/blog/2016/02/07/103930/"/>
    <updated>2016-02-07T10:39:30+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/02/07/103930</id>
    <content type="html"><![CDATA[<h1>Packages</h1>

<p>Haskell packages can be installed in user level (global, like <code>npm install -g</code>)
or project level (local, like <code>npm install</code>).</p>

<p>The default behavior of cabal is user level:</p>

<pre><code>cabal install &lt;package-name&gt;
</code></pre>

<p>To install package in project level, you need create a sandbox beforehand:</p>

<pre><code>cabal sandbox init     # run in project root folder
cabal install &lt;package-name&gt;
</code></pre>

<p>The global packages are stored in $HOME/.cabal/packages folder,
while local packages are stored in $PROJ_ROOT/.cabal-sandbox/lib folder.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes of Learn You a Haskell for Great Good]]></title>
    <link href="http://leetschau.github.io/blog/2015/10/01/202107/"/>
    <updated>2015-10-01T20:21:07+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/10/01/202107</id>
    <content type="html"><![CDATA[<p>Notes for <a href="http://learnyouahaskell.com/">Learn You a Haskell for Great Good</a>.</p>

<h1>Modules</h1>

<p>The following code snippet demonstrate how to import and use Haskell submodule.
Save the following codes into a shell script and run it.</p>

<pre><code>#!/bin/bash
mkdir Geometry
cat &lt;&lt; EOF &gt; Geometry/Sphere.hs
module Geometry.Sphere
( volume
, area
) where

volume :: Float -&gt; Float
volume radius = (4.0 / 3.0) * pi * (radius ^ 3)

area :: Float -&gt; Float
area radius = 4 * pi * (radius ^ 2)
EOF

cat &lt;&lt; EOF &gt; app.hs
import Geometry.Sphere
main = print $ volume 3
EOF

runghc app.hs
</code></pre>

<p>The result should be &ldquo;113.097336&rdquo;.</p>

<h1>Making Our Own Types and Typeclasses</h1>

<p>Value constructor is also called &ldquo;data constructor&rdquo;.</p>

<p>Ref:</p>

<p><a href="https://wiki.haskell.org/Constructor">Constructor</a></p>

<p><a href="http://stackoverflow.com/questions/18204308/haskell-type-vs-data-constructor">Haskell Type vs Data Constructor</a></p>

<h1>Applicative Functors</h1>

<p>下面的代码，转换<code>[1,2,3,4]</code>时，可以用<code>map</code>代替<code>fmap</code>，转换<code>Just 4</code>就不行：</p>

<pre><code>Prelude&gt; fmap (replicate 3) [1,2,3,4]
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]

Prelude&gt; map (replicate 3) [1,2,3,4]
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]

Prelude&gt; fmap (replicate 3) (Just 4)
Just [4,4,4]

Prelude&gt; map (replicate 3) (Just 4)
&lt;interactive&gt;:45:20:
    Couldn't match expected type ‘[a]’ with actual type ‘Maybe Integer’
    Relevant bindings include it :: [[a]] (bound at &lt;interactive&gt;:45:1)
    In the second argument of ‘map’, namely ‘(Just 4)’
    In the expression: map (replicate 3) (Just 4)
</code></pre>

<p>map是一个函数，通过一个将a类型变为b类型的函数，
将元素类型为a类型的数组转换为元素类型为b的数组；</p>

<pre><code>Prelude&gt; :t map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>

<p>fmap是一个函数，通过一个将a类型变为b类型的函数，
将一个类型为"f a"的值，变为一个类型为"f b"的值。</p>

<pre><code>Prelude&gt; :t fmap
fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>

<p><code>Maybe</code>是一个实现了(instance)函子(Functor)类型类(class)的类型构造器(type constructor)。
类型构造器类似于Java的泛型，例如“数组” <code>[]</code>就是类型构造器，
“元素为整数的数组” <code>[Int]</code>是一个具体类型，这里的整型 Int就充当了数组类型构造器的参数，
用函数做类比，数组是个“类型函数”，参数是具体类型 Int，返回具体类型 [Int]。</p>

<pre><code>Prelude&gt; :k []
[] :: * -&gt; *
</code></pre>

<p>这里<code>:k</code>表示取数组的kind值，kind可以理解为是类型构造器的类型。
<code>*</code>表示某个具体类型（而不是类型构造器）。</p>

<p><code>Just</code>是一个函数，将a类型值转换为<code>Maybe a</code>类型值，
例如<code>Just 4</code>将Int类型值 (4)，转换为<code>Maybe Int</code>，
或者更准确地表述为：将Num类型值转为<code>Num a =&gt; Maybe a</code>类型。</p>

<pre><code>Prelude&gt; :k Maybe
Maybe :: * -&gt; *
Prelude&gt; :t Just
Just :: a -&gt; Maybe a
Prelude&gt; :t Just 4
Just 4 :: Num a =&gt; Maybe a
</code></pre>

<p>由于<code>Just 4</code>的类型<code>Maybe Integer</code>不符合<code>map</code>第二个参数类型<code>[a]</code>的要求，所以报错。</p>

<pre><code>Prelude&gt; :t replicate 3
replicate 3 :: a -&gt; [a]
Prelude&gt; :t fmap (replicate 3) (Just 4)
fmap (replicate 3) (Just 4) :: Num a =&gt; Maybe [a]
</code></pre>

<p>在上面的计算过程中，<code>(replicate 3)</code>是<code>fmap</code>的第一个参数<code>(a -&gt; b)</code>，
这里由于<code>(replicate 3)</code>类型是<code>(a -&gt; [a])</code>，所以<code>b</code>就是<code>[a]</code>。
<code>(Just 4)</code>是第二个参数<code>f a</code>，代入<code>Just 4</code>的类型<code>Maybe a</code>，
可知<code>Functor f</code>就是<code>Maybe</code>.
所以最终<code>f b</code>就是<code>Maybe [a]</code>。</p>
]]></content>
  </entry>
  
</feed>
