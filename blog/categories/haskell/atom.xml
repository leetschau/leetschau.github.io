<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Haskell | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-10-05T15:23:42+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Notes of Learn You a Haskell for Great Good]]></title>
    <link href="http://leetschau.github.io/blog/2015/10/01/202107/"/>
    <updated>2015-10-01T20:21:07+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/10/01/202107</id>
    <content type="html"><![CDATA[<p>Notes for <a href="http://learnyouahaskell.com/">Learn You a Haskell for Great Good</a>.</p>

<h1>Modules</h1>

<p>The following code snippet demonstrate how to import and use Haskell submodule.
Save the following codes into a shell script and run it.</p>

<pre><code>#!/bin/bash
mkdir Geometry
cat &lt;&lt; EOF &gt; Geometry/Sphere.hs
module Geometry.Sphere
( volume
, area
) where

volume :: Float -&gt; Float
volume radius = (4.0 / 3.0) * pi * (radius ^ 3)

area :: Float -&gt; Float
area radius = 4 * pi * (radius ^ 2)
EOF

cat &lt;&lt; EOF &gt; app.hs
import Geometry.Sphere
main = print $ volume 3
EOF

runghc app.hs
</code></pre>

<p>The result should be &ldquo;113.097336&rdquo;.</p>

<h1>Making Our Own Types and Typeclasses</h1>

<p>Value constructor is also called &ldquo;data constructor&rdquo;.</p>

<p>Ref:</p>

<p><a href="https://wiki.haskell.org/Constructor">Constructor</a></p>

<p><a href="http://stackoverflow.com/questions/18204308/haskell-type-vs-data-constructor">Haskell Type vs Data Constructor</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stack Notes]]></title>
    <link href="http://leetschau.github.io/blog/2015/09/23/123748/"/>
    <updated>2015-09-23T12:37:48+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/09/23/123748</id>
    <content type="html"><![CDATA[<h1>Install</h1>

<p>Install <a href="https://github.com/commercialhaskell/stack">stack</a> and start a demo yesod web server:</p>

<pre><code>wget -q -O- https://s3.amazonaws.com/download.fpcomplete.com/ubuntu/fpco.key | sudo apt-key add -
echo 'deb http://download.fpcomplete.com/ubuntu/trusty stable main'|sudo tee /etc/apt/sources.list.d/fpco.list
sudo apt-get update &amp;&amp; sudo apt-get install stack -y
cd ~/docs/playground
stack new myHaskellProj yesod-sqlite  // very slow, 30 minutes or so
stack install yesod-bin cabal-install --install-ghc
stack build  // if it's interupteed by "FailedConnectionException s3.amazonaws.com 443" error, run this command again
stack exec -- yesod devel
</code></pre>

<p>Now open &ldquo;<a href="http://localhost:3000/">http://localhost:3000/</a>&rdquo;.</p>

<h1>Run Haskell Code</h1>

<p>To start a ghci, in any folder, run:</p>

<pre><code>stack ghci
Prelude&gt; putStrLn "hello world"
</code></pre>

<p>To run haskell script: in any folder, run</p>

<pre><code>$ cat hello.hs
main = putStrLn "hello world"
$ stack runghc hello.hs
</code></pre>

<h1>Editor Setup</h1>

<p>Ref: <a href="http://seanhess.github.io/2015/08/05/practical-haskell-editors.html">PRACTICAL HASKELL - EDITOR SETUP WITH STACK</a>.</p>

<pre><code>cd ~
stack setup
stack install hdevtools
stack path|grep ghc      # to get the ghc binary path used below
</code></pre>

<p>Add <code>PATH=$PATH:$HOME/.stack/programs/x86_64-linux/ghc-7.10.2/bin:$HOME/.local/bin</code> into ~/.zshenv.</p>

<p>Install syntastic and &lsquo;bitc/vim-hdevtools&rsquo; plugin for vim:</p>

<p>add the following 2 lines into ~/.vimrc:</p>

<pre><code>Plugin 'scrooloose/syntastic'
Plugin 'bitc/vim-hdevtools'
</code></pre>

<p>then run <code>vim +PluginInstall</code>.</p>

<p>Now your .hs files will be checked when saving.</p>

<p>To verify, create hello.hs as follows:</p>

<pre><code>main = do
  print "What is your name?"
  name &lt;- getLine
  print ("Hello " ++ name ++ "!")
</code></pre>

<p>When cursor on &ldquo;print&rdquo; in the 2nd line, run <code>:HdevtoolsType</code>
(which equivalent to run <code>hdevtools type hello.hs 2 3</code> in shell),
you should get &ldquo;[Char] -> IO ()&rdquo;.</p>

<p>For convenient, add the following shortcuts into ~/.vimrc:</p>

<pre><code>" hdevtools setup (haskell)
au FileType haskell nnoremap &lt;buffer&gt; &lt;F3&gt; :HdevtoolsType&lt;CR&gt;
au FileType haskell nnoremap &lt;buffer&gt; &lt;silent&gt; &lt;F4&gt; :HdevtoolsClear&lt;CR&gt;
</code></pre>

<p>Add &ldquo;this&rdquo; at the end of file from column 3 and save
(which is equivalent to run <code>hdevtools check hello.hs</code> in shell),
a &ldquo;Not in scope: ‘this’&rdquo; error will raises.</p>

<p>See <a href="https://github.com/schell/hdevtools">hdevtools</a> and
<a href="https://github.com/bitc/vim-hdevtools">bitc/vim-hdevtools</a> for more information.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note About `Programming in Haskell`]]></title>
    <link href="http://leetschau.github.io/blog/2013/12/16/174627/"/>
    <updated>2013-12-16T17:46:27+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/12/16/174627</id>
    <content type="html"><![CDATA[<h1>1.7 Exercises</h1>

<ol>
<li>How should the definition of the function qsort be modified so that it produces a reverse sorted version of a list?</li>
</ol>


<p> qsort :: Ord a => [a] -> [a]
 qsort [] = []
 qsort (x:xs) = qsort bigger ++ [x] ++ qsort smaller where
     smaller = filter (&lt;=x) xs
     bigger = filter (>x) xs</p>

<h1>Type and Class</h1>

<p>Recall that a type is a collection of related values. Building upon this notion, a class is a collection of types that support certain overloaded operations called methods. &ndash; Section 3.9: Basic Classes</p>

<h1>Patterns Matching</h1>

<p>Section 4.4, excellent explanation about tuple pattern, list pattern and integer pattern.</p>

<p>Note that cons patterns must be parenthesised, because function application has higher priority than all other operators. (p34)</p>

<h1>4.8 Exercises</h1>

<ol>
<li>Splits an even-lengthed list into two halves:</li>
</ol>


<p> halve :: [a] -> ([a], [a])</p>

<p> halve x = splitAt (div (length x) 2) x</p>

<ol>
<li>safetail</li>
</ol>


<p> safetail :: [a] -> [a]</p>

<p> &ndash; conditional expression</p>

<p> safetail xs = if null xs then []</p>

<pre><code>    else tail xs
</code></pre>

<p> &ndash; guarded equation</p>

<p> safetail xs | null xs = []</p>

<pre><code>| otherwise = tail xs
</code></pre>

<p> &ndash; pattern matching</p>

<p> safetail [] = []</p>

<p> safetail xs = tail xs</p>

<h1>5.7 Exercies</h1>

<ol>
<li><p>sum [x**2|x&lt;-[1..100]]</p></li>
<li><p>replicate n x = [x | t &lt;- [1..n]]</p></li>
</ol>


<p> (answer of textbook: replicate n x = [x|_&lt;-[1..n]]</p>

<ol>
<li>Find pythagorean triples:</li>
</ol>


<p> pyths n = [(x,y,z)|x&lt;-[1..n], y&lt;-[1..n], z&lt;-[1..n], x<strong>2+y</strong>2==z**2]</p>

<ol>
<li>Find perfects number:</li>
</ol>


<p> factors n = [x | x &lt;- [1..n-1], n <code>mod</code> x == 0]</p>

<p> perfects n = [x|x&lt;-[1..n], x == sum (factors x)]</p>

<h1>sat function in Chapter 8</h1>

<p>The codes in section 8.1~8.3 and 8.6 doesn&rsquo;t work. The author explained it in chapter remarks(section 8.9) and the errata (Pages 74 to 78&hellip;). He also gave a monad version of &ldquo;Parser&rdquo; in his website: <a href="http://www.cs.nott.ac.uk/~gmh/Parsing.lhs">Code -> Parsing</a>. So I am afraid we have to learn some monads then come back to this interesting Haskell parser.</p>

<p>Ref: <a href="http://stackoverflow.com/questions/2607498/programming-in-haskell-error-in-sat-function">http://stackoverflow.com/questions/2607498/programming-in-haskell-error-in-sat-function</a></p>

<h1>Chapter 9</h1>

<h2>Clear Screen</h2>

<p>MyClr.hs:</p>

<p> module Main where
 cls :: IO ()
 cls = putStr &ldquo;\ESC[2J&rdquo;
 bingo :: IO ()
 bingo = putStr &ldquo;bingo!\n&rdquo;
 main = do cls
    bingo</p>

<p>$ ghc MyClr.hs</p>

<p>$ ./MyClr</p>

<p>You have to remove the type declaration sentences.</p>

<h2>StrLen</h2>

<p> strLen :: IO ()
 strLen = do putStr &ldquo;Enter a string: &rdquo;
    xs &lt;- getLine
    putStr &ldquo;The string has &rdquo;
    putStr (show (length xs))
    putStrLn &ldquo; characters.&rdquo;</p>

<p>Then load in ghci and run &ldquo;strLen&rdquo;.</p>

<h2>goto (in ghci)</h2>

<p> let goto (x,y) = putStr (&ldquo;\ESC[&rdquo; ++ show y ++ &ldquo;;&rdquo; ++ show x ++ &ldquo;H&rdquo;)</p>

<p> goto (20,20)</p>

<h1>Chapter 10</h1>

<h2>Normal Functions and Constructor Function</h2>

<p> data Shape = Circle Float | Rect Float Float</p>

<p>The constructors Circle and Rect are actually constructor functions, which produce results of type Shape from arguments of type Float . The difference between normal functions and constructor functions is that the latter have no defining equations, and exist solely for the purpose of building pieces of data. The expression Circle 1.0 is just a piece of data, in the same way that 1.0 itself is just data.</p>

<h2>Diferent Kinds of tree</h2>

<p>The parameter type &ldquo;a&rdquo; represents the stored data.</p>

<ul>
<li><p>Store data only in leaves: data Tree a = Leaf a | Node (Tree a) (Tree a)</p></li>
<li><p>Store data only in nodes:</p></li>
</ul>


<p> data Tree a = Leaf | Node (Tree a) a (Tree a)</p>

<p>and:</p>

<p> data Tree a = Node a [Tree a ]</p>

<ul>
<li>Store data both in leaves (data type is &ldquo;a&rdquo;) and nodes (data type is &ldquo;b&rdquo;):</li>
</ul>


<p> data Tree a b = Leaf a | Node (Tree a b) b (Tree a b)</p>

<h1>Chapter 11</h1>

<p> results ns = [res| (ls,rs) &lt;- split ns,
      lx &lt;- results ls,
      ry &lt;- results rs,
      res &lt;- combine' lx ry]</p>

<p>Above is a imperative-style calculation in list comprehension. The cost is you have to put your result in a list, while empty list means failure of calculation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell Interactive Development in Emacs]]></title>
    <link href="http://leetschau.github.io/blog/2013/12/16/113414/"/>
    <updated>2013-12-16T11:34:14+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/12/16/113414</id>
    <content type="html"><![CDATA[<h1>Installation</h1>

<p>Following <a href="https://github.com/haskell/haskell-mode">haskell-mode</a>.</p>

<ol>
<li>Use MELPA repository: add the following into ~/.emacs</li>
</ol>


<p> (require &lsquo;package)
 (add-to-list 'package-archives
    &rsquo;(&ldquo;melpa&rdquo; . &ldquo;<a href="http://melpa.milkbox.net/packages/">http://melpa.milkbox.net/packages/</a>&rdquo;) t)
 (package-initialize)</p>

<ol>
<li><p>M-x package-refresh-contents</p></li>
<li><p>M-x package-install [RET] haskell-mode</p></li>
</ol>


<h1>Usage</h1>

<ol>
<li><p>Open a haskell file in emacs;</p></li>
<li><p>Use &ldquo;C-c C-z&rdquo; to open ghci (but there isn&rsquo;t a jump-back shortcut, you can use C-x o);</p></li>
<li><p>Use &ldquo;C-c C-l&rdquo; to load file (same as &ldquo;:l <file_name>&rdquo;);</p></li>
</ol>


<p>However, there isn&rsquo;t tab-completion in the ghci invoked by &ldquo;C-c C-z&rdquo;, so you can start a console to run ghci;</p>

<h1>User Manual</h1>

<p>M-x info-display-manual [RET] haskell-mode</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Note About `Yet Another Haskell Tutorial`]]></title>
    <link href="http://leetschau.github.io/blog/2013/12/15/212740/"/>
    <updated>2013-12-15T21:27:40+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/12/15/212740</id>
    <content type="html"><![CDATA[<h1>Exercises Solutions</h1>

<p><a href="http://en.wikibooks.org/wiki/Haskell/YAHT">http://en.wikibooks.org/wiki/Haskell/YAHT</a></p>

<h1>Exercise 3.10</h1>

<p>Save the following scripts in SumInputs.hs:</p>

<p> module Main where
 main = do
  inputNumbers &lt;- getNumber
  putStrLn (&ldquo;The sum is &rdquo; ++ show (sum inputNumbers))
  putStrLn (&ldquo;The product is &rdquo; ++ show (foldr (*) 1 inputNumbers))
  printFactorials inputNumbers
 getNumber = do
  putStrLn &ldquo;Give me a number (or 0 to stop): &rdquo;
  number &lt;- getLine
  let num = read number
  if num == 0
   then return []
   else do
    rest &lt;- getNumber
    return (num : rest)
 printFactorials [] = putStrLn &ldquo;&rdquo;
 printFactorials (x:xs) = do
  putStrLn (show x ++ &ldquo; factorial is: &rdquo; ++ show (factorial x))
  printFactorials xs
 factorial 1 = 1
 factorial n = n * factorial (n-1)</p>

<ul>
<li><p>Run it in ghci: main</p></li>
<li><p>Compile and run in console:</p></li>
</ul>


<p> ghc &ndash;make SumInputs.hs -o myfac</p>

<p> ./myfac</p>

<h1>Exercise 4.4 &amp; 4.5</h1>

<p> data Pair a b = Pair a b
 pairFst (Pair x y) = x
 pairSnd (Pair x y) = y
 data Triple a b c = Triple a b c
 tripleFst :: Triple a b c -> a
 tripleFst (Triple a b c) = a
 tripleSnd (Triple a b c) = b
 tripleThr (Triple a b c) = c
 data Quadruple a b = Quadruple a a b b deriving (Show)
 firstTwo :: Quadruple a b -> [a]
 &ndash; you can&rsquo;t write it as: &hellip; -> [a, a]. This is not a valid type expression?
 firstTwo (Quadruple w x y z) = [w, x]</p>

<p> lastTwo :: Quadruple a b -> [b]
 lastTwo (Quadruple w x y z) = [y, z]</p>

<h1>Exercise 4.6</h1>

<p> data Tuple a b c d = Tuple1 a
      | Tuple2 a b
      | Tuple3 a b c
      | Tuple4 a b c d
      deriving (Show)
 tuple1 :: Tuple a b c d -> a
 tuple1 (Tuple1 x) = x
 tuple1 (Tuple2 x y) = x
 tuple1 (Tuple3 x y z) = x
 tuple1 (Tuple4 x y z t) = x
 tuple2 :: Tuple a b c d -> Maybe b
 tuple2 (Tuple1 x) = Nothing
 tuple2 (Tuple2 x y) = Just y
 tuple2 (Tuple3 x y z) = Just y
 tuple2 (Tuple4 x y z t) = Just y
 tuple3 :: Tuple a b c d -> Maybe c
 tuple3 (Tuple1 x) = Nothing
 tuple3 (Tuple2 x y) = Nothing
 tuple3 (Tuple3 x y z) = Just z
 tuple3 (Tuple4 x y z t) = Just z
 tuple4 :: Tuple a b c d -> Maybe d
 tuple4 (Tuple1 x) = Nothing
 tuple4 (Tuple2 x y) = Nothing
 tuple4 (Tuple3 x y z) = Nothing
 tuple4 (Tuple4 x y z t) = Just t</p>

<p>Pattern matching plays a big role in tuple-like data structure.</p>
]]></content>
  </entry>
  
</feed>
