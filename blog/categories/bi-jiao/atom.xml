<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 比较 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/bi-jiao/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-04-30T16:15:37+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[文件夹同步软件比较]]></title>
    <link href="http://leetschau.github.io/blog/2011/10/07/141255/"/>
    <updated>2011-10-07T14:12:55+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/10/07/141255</id>
    <content type="html"><![CDATA[<p>比较软件列表
 Toucan: GNU/GPL, 绿色；</p>

<p> Allway Sync免费版: ASF；</p>

<p>GoodSync: GS, proprietary ware;</p>

<p> TotalCommander: TC, proprietary ware;</p>

<p>Microsoft SyncToy: ST;</p>

<p>Super Flexible File Synchronizer Pro v5.54a: SFFS，proprietary ware;</p>

<p> SyncBackPro: proprietary ware, SBP;</p>

<p>Areca: 开源，绿色，适用于“备份”，不适用于“同步”，因为Areca中的“Repository"相当于同步目标位置，Source相当于同步源，但它会在Repo里自动加一个全数字组成的子目录，它的强大之处是可以像SVN一样记录每次备份的历史，为备份加密，备份前后可以执行脚本；</p>

<p>Free File Sync: 开源，绿色，有多种同步模式，但好像不支持智能盘符； 过滤器
同步软件的过滤器最好具有复杂逻辑判断能力，例如：将文件夹A备份到文件夹B，去除其中>500MB的文件，但其中FA, FB除外（也就是说FA,FB仍然要备份）。</p>

<p>以下是各软件的过滤器比较：</p>

<p>Toucan：可以用"Rules"定义；</p>

<p>ASF: 有文件大小定义，但试用后达不到预期目标；</p>

<p>GS: 没有文件大小定义，只有文件名定义；</p>

<p>TC: 没有过滤器功能；</p>

<p>SBP: 似乎有，但似乎很复杂；</p>

<p>SFFS: 过滤器功能很强大，包括Include/Exclude列表、尺寸大小、时间戳等多种方式过滤；</p>

<p> 任务导出/导入
如果没有复杂逻辑筛选功能，但具备任务的导入/导出功能，那么仍然可以满足前面提到的复杂备份要求，办法是手工定义文件排除列表，然后导出任务，这样系统或者软件重装后只要导入先前定义好的任务列表即可。</p>

<p>目前试用的有：</p>

<p>GS: 手工生成排除列表的功能比较直观好用，也具备导入/导出任务功能；</p>

<p>ASF, SFFS也具备导入/导出任务功能；
 智能盘符
GS不具备；</p>

<p>ASF具备；</p>

<p>SFFS可以在路径名中直接写盘符，例如：U52:\Backup\PersonalFinance</p>

<p>还可以勾选如下选项：Edit Profile->Advanced Settings->Job->Right-hand volume must be:&hellip;</p>

<p> 同步记录文件夹
很多同步软件会在同步目标文件夹下生成一些特殊的文件夹，例如GoodSync会生成gs_data文件夹，ASF生成_SYNCAPP文件夹，ST在源和目标文件夹下都生成一个SyncToy*.dat文件，很不好，这方面Toucan和SFFS做的比较好，不生成任何额外的文件夹。
 总结
Toucan是一款全功能（同步、备份、加密）软件，能过滤，能自己写脚本，支持在命令行下运行，不在文件夹下新建记录文件（夹），无需安装，推荐。使用方法详见"Settings->Help"，备份Calibre书库用Sync->Mirror方法备份，这种模式下即使目标比源新时也用源覆盖目标，保证绝对的单向备份。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java范型方法中T与?的比较]]></title>
    <link href="http://leetschau.github.io/blog/2011/08/18/092023/"/>
    <updated>2011-08-18T09:20:23+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/08/18/092023</id>
    <content type="html"><![CDATA[<p>Java范型从范围上分，有范型类和范型方法两种，这里只讨论范型方法，从语义上来说，范型中的 T 和 ? 都有“任意一个类”（或者“任意一种类型”）的意思，那么二者的区别是什么呢？我认为是 T 可以放在Field或者Method名称前作为类型名，而 ? 不行，除此之外本质上完全一样，下面的代码是一个实例。</p>

<p> package org.leechau.genericEx;</p>

<p> import java.util.ArrayList;</p>

<p> import org.junit.Before;</p>

<p> import org.junit.Test;</p>

<p> public class GenericTest {</p>

<p>  private final ArrayList<String> p1 = new ArrayList<String>();</p>

<p>  private final ArrayList<Integer> p2 = new ArrayList<Integer>();</p>

<p>  public <T> String ma(ArrayList <T> pa) {</p>

<p>   return pa.get(0).toString();</p>

<p>  }</p>

<p>  public String mb(ArrayList &lt;?> pa) {</p>

<p>  return pa.get(0).toString();</p>

<p>  }</p>

<p>  @Before</p>

<p>  public void setUp() throws Exception {</p>

<p>   p1.add(&ldquo;1st strings&rdquo;);</p>

<p>   p2.add(51);</p>

<p>  }</p>

<p>  @Test</p>

<p>  public void testMa() {</p>

<p>   System.out.println(ma(p1));</p>

<p>   System.out.println(ma(p2));</p>

<p>  }</p>

<p>  @Test</p>

<p>  public void testMb() {</p>

<p>   System.out.println(mb(p1));</p>

<p>   System.out.println(mb(p2));</p>

<p>  }</p>

<p> }</p>

<p> 下面的代码演示了如何分别用 T 和 ? 完成相同的实现。</p>

<p> T版：</p>

<p> package org.leechau.genericEx;</p>

<p> import java.util.Collection;</p>

<p> public abstract class Animal {</p>

<p> public <T extends Animal> void playWith(Collection<T> playGroup) {}</p>

<p> }</p>

<p> package org.leechau.genericEx;</p>

<p> import java.util.ArrayList;</p>

<p> import java.util.Collection;</p>

<p> public class Dog extends Animal {</p>

<p> @Override</p>

<p> public <T extends Animal> void playWith(Collection<T> playGroup) {</p>

<p> System.out.println(this.toString() + &ldquo; play with &rdquo;</p>

<ul>
<li>playGroup.toString());</li>
</ul>


<p> }</p>

<p> public static void main(String[] args) {</p>

<p> Collection<Dog> dogs = new ArrayList<Dog>();</p>

<p> Dog aDog = new Dog();</p>

<p> aDog.playWith(dogs);</p>

<p> }</p>

<p> }</p>

<p> ?版：</p>

<p> package org.leechau.genericEx;</p>

<p> import java.util.Collection;</p>

<p> public class Animal2 {</p>

<p> public void playWith(Collection &lt;? extends Animal2> playGroup) {}</p>

<p> }</p>

<p> package org.leechau.genericEx;</p>

<p> import java.util.ArrayList;</p>

<p> import java.util.Collection;</p>

<p> public class Dog2 extends Animal2 {</p>

<p> @Override</p>

<p> public void playWith(Collection&lt;? extends Animal2> playGroup) {</p>

<p> System.out.println(this.toString() + &ldquo; play with &rdquo;</p>

<ul>
<li>playGroup.toString());</li>
</ul>


<p> }</p>

<p> public static void main(String[] args) {</p>

<p> Collection<Dog2> dogs = new ArrayList<Dog2>();</p>

<p> Dog2 aDog = new Dog2();</p>

<p> aDog.playWith(dogs);</p>

<p> }</p>

<p> }</p>

<p> Java的范型（尤其是实现机制）给我的感觉是不够优雅，当一堆&lt;>嵌套在一起的时候让人觉得像天书一样，背离了Java简洁易用的原则，但即便如此，毕竟现在Java还是产品开发（尤其是大规模产品）的主流工具，我们有必要理解它的一些细节。[1]的Part I,II 和[2]的第12章对范型的讲解比较透彻，[3]的4.3.7节则对Java范型进行了中肯的评价， [1]的Part III探讨了如何将没有范型的老代码改为有范型的新代码以保证类型安全 。</p>

<p> [1] Venkat Subramaniam, Generics in Java</p>

<p> [2] Cay S. Horstmann, Core Java. Volume I, Fundamentals, 8th ed, 2007.9</p>

<p> [3] Bruce A. Tate, Beyond Java, 2005.9</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[视频格式转换软件比较]]></title>
    <link href="http://leetschau.github.io/blog/2011/01/27/105812/"/>
    <updated>2011-01-27T10:58:12+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/01/27/105812</id>
    <content type="html"><![CDATA[<p>此处比较的软件共6种，分别是：</p>

<p> 狸窝全能：狸窝全能视频转换器，Leawo Video Converter v2.7.0.0</p>

<p> Softstunt： Softstunt RM RMVB Converter</p>

<p>Any Video Conv: Any Video Converter Professional v2.7.6</p>

<p> 软件名称/功能特点 多种格式转换 转换速度 CPU占用率 合并视频 已完成百分比 视频剪辑 目标文件大小 任务列表 任务完成自动关机 已消耗时间 剩余时间 狸窝全能 全部格式 快 100% 能 标识 具备 标识 具备 具备 标识 标识  Softstunt 仅rm->多种格式 慢 单任务40%，双任务80% 不能 标识 不具备 无标识 具备 不具备 无标识 无标识  Any Video Conv 全部格式 快 单任务50% 能 标识 具备 无标识 具备 具备 无标识 无标识</p>

<p>整体而言，Softstunt生成的avi体积太大，CPU占有率太高，一开始转换就无法进行其他工作了，只能转换rm格式视频，在本次PK中首先出局。Leawo和Any的功能都不错，leawo的易用性更胜一筹，Any生成的avi文件体积只是leawo版的一半左右（相同的avi制式），且实验证明用Any生成的xvid格式的avi影片能够在电视上正常放映， 最终的胜出者是 Any Video Converter  。</p>

<p>Any转换格式设置方法：</p>

<p>首先导入影片，以rmvb影片为例，在右边的“视频输出”部分，【编码器(video codec)】选【xvid】；【大小(video size)】选【原先的】；【比特率】选【768】；【帧率】设置为与被转换的影片一样；“音频输出”部分全部用默认值即可。</p>
]]></content>
  </entry>
  
</feed>
