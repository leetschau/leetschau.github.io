<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Erlang | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/erlang/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-08-01T16:20:42+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compile ASN Module 25331-690 With Erlang]]></title>
    <link href="http://leetschau.github.io/blog/2014/05/20/194453/"/>
    <updated>2014-05-20T19:44:53+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/05/20/194453</id>
    <content type="html"><![CDATA[<ol>
<li><p>Split the origin ASN file(25331-690.txt): there are 5 modules in this file, so we need split it into 5 modules:</p></li>
<li><p>Class-definitions.asn</p></li>
<li>PDU-definitions.asn</li>
<li>InformationElements.asn</li>
<li>Constant-definitions.asn</li>
<li>Internode-definitions.asn</li>
</ol>


<p>Each has the same structure:</p>

<pre><code>&lt;module-name&gt; DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
...
END
</code></pre>

<ol>
<li><p>Compile modules according their dependencies. The order is:</p>

<p> Constant-definitions -> InformationElements -> PDU-definitions -> Class-definitions -> Internode-definitions</p></li>
</ol>


<p>The compile method is: in erlang shell(<code>$ erl</code>), run &ldquo;asn1ct:compile("PDU-definitions&rdquo;, [per, verbose]).&ldquo;.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Encode and Decode ASN.1 in Erlang]]></title>
    <link href="http://leetschau.github.io/blog/2014/05/12/142038/"/>
    <updated>2014-05-12T14:20:38+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/05/12/142038</id>
    <content type="html"><![CDATA[<p>Firstly a template asn file (PP.asn here) was created. Then it&rsquo;s be used to encode some text, creating a segment binary data(stored in variable Bin), then Bin was decoded based on PP.asn. We can also store binaries into a file, then read from it.</p>

<pre><code>$ cat PP.asn
PP DEFINITIONS AUTOMATIC TAGS ::=
BEGIN
  TGSN ::=    INTEGER (0..14)
  Persons ::= SEQUENCE {
    name PrintableString,
    location INTEGER {home(0),field(1),roving(2)},
    age INTEGER OPTIONAL
  }
END
$ erl
Erlang/OTP 17 [erts-6.0] [source-07b8f44] [smp:2:2] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.0  (abort with ^G)
1&gt; asn1ct:compile("PP", [ber, verbose]).
Erlang ASN.1 compiler 3.0
Compiling: "PP.asn"
Options: [ber,verbose,{i,"."}]
--{generated,"PP.asn1db"}--
--{generated,"PP.hrl"}--
--{generated,"PP.erl"}--
ok
2&gt; Rockstar = {'Persons',"Some Name",roving,50}.
{'Persons',"Some Name",roving,50}
3&gt; {ok,Bin} = 'PP':encode('Persons',Rockstar).    
{ok,&lt;&lt;48,17,128,9,83,111,109,101,32,78,97,109,101,129,1,
      2,130,1,50&gt;&gt;}
4&gt; {ok,Persons} = 'PP':decode('Persons',Bin).  
{ok,{'Persons',"Some Name",roving,50}}
5&gt; file:write_file("test", Bin).
ok
6&gt; {ok, Bin2} = file:read_file("test").
{ok,&lt;&lt;48,17,128,9,83,111,109,101,32,78,97,109,101,129,1,
      2,130,1,50&gt;&gt;}
7&gt; {ok,Persons} = 'PP':decode('Persons',Bin2).
{ok,{'Persons',"Some Name",roving,50}}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bitstring in Erlang]]></title>
    <link href="http://leetschau.github.io/blog/2014/05/10/172302/"/>
    <updated>2014-05-10T17:23:02+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/05/10/172302</id>
    <content type="html"><![CDATA[<p>bitstring is the bit sequence literals in Erlang. It&rsquo;s powerful and convenient due to the Erlang&rsquo;s telecom background.</p>

<p>Now we have a bit sequence &ldquo;0110 0101 1000 1111 1010 0010&rdquo;, whose corresponding hex literal is: &ldquo;0x65 0x8f 0xa2&rdquo;. To express it with Erlang:</p>

<pre><code>1&gt; Bin = &lt;&lt;16#65, 16#8f, 16#a2&gt;&gt;.
&lt;&lt;101,143,162&gt;&gt;
</code></pre>

<p>Every segment divided by comma is called a &ldquo;segment&rdquo;, it&rsquo;s default size is 8.</p>

<p>But we want divide this sequence in this way: &ldquo;011 0010 1100 011 1110 10 0010&rdquo;, which can be expressed as &ldquo;&lt;&lt;value1:length1, value2:length2, &hellip;>>&rdquo;:</p>

<pre><code>2&gt; Bin2 = &lt;&lt;3:3, 2:4, 16#c:4, 3:3, 16#e:4, 2:2, 2:4&gt;&gt;.
&lt;&lt;101,143,162&gt;&gt;
</code></pre>

<p>So that&rsquo;s why</p>

<pre><code>3&gt; &lt;&lt;3, 17, 23:16&gt;&gt;.
&lt;&lt;3,17,0,23&gt;&gt;
4&gt; &lt;&lt;3, 17, 3323:16&gt;&gt;.
&lt;&lt;3,17,12,251&gt;&gt;
</code></pre>

<p>The third segment &ldquo;<num>:16&rdquo; consists of 16 bits. So it&rsquo;s 8-bit &ldquo;normal&rdquo; literals is:</p>

<pre><code>0 * 256 + 23 = 23
12 * 256 + 251 = 3323
</code></pre>

<p>That&rsquo;s it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Run Interactive Shell Command in Erlang]]></title>
    <link href="http://leetschau.github.io/blog/2013/08/14/160009/"/>
    <updated>2013-08-14T16:00:09+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/08/14/160009</id>
    <content type="html"><![CDATA[<p>The following simple Erlang netcat client demonstrates the communication between Erlang program and external OS process. The rc.erl start a netcat client to connect to a netcat server, and send some message to the server at a given time.</p>

<ol>
<li><p>Create Erlang server;</p>

<p> -module(rc).
 -export([cmd/1]).
 cmd(Cmd) ->
     Opt = [stream, exit_status, stderr_to_stdout, eof],
     P = open_port({spawn, Cmd}, Opt),
     get_data(P, [], 0).
 get_data(P, Sofar, 3) ->
     port_command(P, &ldquo;abcd&rdquo;),
     get_data(P, Sofar, 4);
 get_data(P, Sofar, Cnt) ->
     receive
         {P, {data, Bin}} ->
             io:format(&ldquo;rec Bin: ~p, Cnt=~p~n&rdquo;, [Bin, Cnt]),
             get_data(P, [Bin|Sofar], Cnt+1);
         {P, eof} ->
             port_close(P),
             receive
                 {P, {exit_status, N}} ->
                     {N, lists:reverse(Sofar)}
             end
     end.</p></li>
<li><p>Start netcat server: run command <code>nc -l 3333</code> at host 10.21.3.31;</p></li>
<li><p>Start netcat client:</p>

<p> $ erl
 &hellip;</p>

<p> 1> c(rc).</p>

<p> {ok,rc}
 2> rc:cmd(&ldquo;nc 10.21.3.31 3333&rdquo;).</p></li>
<li><p>Send message from server to client: press &ldquo;1<CR>2<CR>3<CR>4<CR>^C&rdquo;, client output as follows:</p>

<p> rec Bin: &ldquo;1\n&rdquo;, Cnt=0
 rec Bin: &ldquo;2\n&rdquo;, Cnt=1
 rec Bin: &ldquo;3\n&rdquo;, Cnt=2
 rec Bin: &ldquo;4\n&rdquo;, Cnt=4
 {0,[&ldquo;1\n&rdquo;,&ldquo;2\n&rdquo;,&ldquo;3\n&rdquo;,&ldquo;4\n&rdquo;]}
 3></p></li>
</ol>


<p>When you press <CR> after 3, you can receive &ldquo;abcd&rdquo; from netcat client.</p>

<p>The pattern of Erlang-Shell communication is:</p>

<ul>
<li><p>Use &ldquo;open_port&rdquo; to start a external shell process;</p></li>
<li><p>Use &ldquo;receive&rdquo; clause to receive output of the process;</p></li>
<li><p>Use &ldquo;port_command&rdquo; to send message to process;</p></li>
<li><p>Use &ldquo;port_close&rdquo; to close the shell;</p></li>
</ul>


<p>Notes:</p>

<ol>
<li><p>For non-interactive shell command, os:cmd/1 is a better choice;</p></li>
<li><p>If you want to catch the event that the peer close actively, add &ldquo;eof&rdquo; into option list of open_port; If you want to catch the exit value of the shell process, add &ldquo;exit_status&rdquo; to option list of open_port;</p></li>
<li><p>Not specify &ldquo;in&rdquo; in option list of open_port when you want to send the process some message, or a &ldquo;ebadf&rdquo; exception arises, because &ldquo;in&rdquo; means this process only used for input, and &ldquo;ebadf&rdquo; means the file is not open for reading or writing.</p></li>
<li><p><a href="http://www.cnblogs.com/gibbon/archive/2012/12/26/Erlang.html">Erlang port communicate with python</a> is a good demonstration of erlang calling a python script; Chapter 12 of &ldquo;Programming Erlang&rdquo; also concentrate Erlang interfacing techniques.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Build Erlang Application With Rebar]]></title>
    <link href="http://leetschau.github.io/blog/2013/07/24/165328/"/>
    <updated>2013-07-24T16:53:28+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/07/24/165328</id>
    <content type="html"><![CDATA[<p>See usage mannul at <a href="https://github.com/rebar/rebar/wiki">rebar wiki</a>;</p>

<p>Or you can Download rebar manually at <a href="https://github.com/basho/rebar">rebar homepage</a>;</p>

<p>Basic usage:</p>

<ol>
<li><p>Download rebar to project root directory;</p></li>
<li><p><code>./rebar create-app</code></p></li>
<li><p>edit source files;</p></li>
<li><p><code>./rebar compile</code></p></li>
</ol>

]]></content>
  </entry>
  
</feed>
