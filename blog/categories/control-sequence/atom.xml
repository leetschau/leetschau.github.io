<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Control Sequence | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/control-sequence/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-02-02T16:10:00+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[演示切换屏幕控制序列的程序]]></title>
    <link href="http://leetschau.github.io/blog/2012/11/08/100435/"/>
    <updated>2012-11-08T10:04:35+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/11/08/100435</id>
    <content type="html"><![CDATA[<p>\033[?1049h和\033[?1049l的功能是切换屏幕（见笔记 关于ansi转义序列控制符 ），下面的代码是一个Telnet Server的一部分，用Telnet Client连上后，先收到一个&#8221;hello&#8221;,然后切换到一个新屏幕上再收到一个&#8221;hello&#8221;，然后切换回原来的屏幕，并断开连接。</p>

<p> SocketAddress clientAddress = sock.getRemoteSocketAddress();</p>

<p> // sock is the incoming socket
 logger.info(&ldquo;Accept client from &rdquo; + clientAddress);
 Thread.currentThread().setName(this.getClass().getName());
 InputStream is = sock.getInputStream();
 OutputStream os = sock.getOutputStream();
 byte[] helloMsg = &ldquo;hello&rdquo;.getBytes();
 os.write(helloMsg);
 os.flush();
 Thread.sleep(2000);
 byte[] switchScreen = { 0x1b, 0x5b, 0x3f, 0x31, 0x30, 0x34, 0x39, 0x68 };
 // \033[?1049h, switch to a new screen
 os.write(switchScreen);
 os.flush();
 Thread.sleep(2000);
 os.write(helloMsg);
 os.flush();
 Thread.sleep(2000);
 byte[] switchBack = { 0x1b, 0x5b, 0x3f, 0x31, 0x30, 0x34, 0x39, 0x6c };
 // \033[?1049l, switch back to original screen
 os.write(switchBack);
 os.flush();
 sock.close();</p>
]]></content>
  </entry>
  
</feed>
