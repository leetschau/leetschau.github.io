<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Junit | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/junit/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-10-01T21:14:19+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Solution of Cobertura Exception `touchJump` When Unit Test]]></title>
    <link href="http://leetschau.github.io/blog/2013/08/08/114315/"/>
    <updated>2013-08-08T11:43:15+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/08/08/114315</id>
    <content type="html"><![CDATA[<p>During unit test I encounter a &ldquo;java.lang.NoSuchMethodError: net.sourceforge.cobertura.coveragedata.ClassData.touchJump(IIZ)V&rdquo; exception.
I find there are 2 cobertura.jar in classpath. That jar in /usr/share/ant/lib is v1.9.2, while in ./lib/ is 1.8.1.</p>

<p>When I delete the jar in ./lib, there is a &ldquo;java.lang.NoClassDefFoundError: net/sourceforge/cobertura/coveragedata/HasBeenInstrumented&rdquo; exception.</p>

<p>Then I copy cobertura.jar from /usr/share/ant/lib to ./lib, everything goes fine.</p>

<h1>Solution of &ldquo;local class incompatible&rdquo;</h1>

<p>Problem: local class incompatible: stream classdesc serialVersionUID = 2, local class serialVersionUID = 2152686494816595840</p>

<p>Solution: use <code>unzip -q -c cobertura.jar META-INF/MANIFEST.MF</code>, I found the version of this jar is 1.8, while that in other projects is 1.9.1. So I copy the jar of version 1.9.1 to replace that of version 1.8, everything goes fine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Metrics Management With Sonar]]></title>
    <link href="http://leetschau.github.io/blog/2013/05/29/183259/"/>
    <updated>2013-05-29T18:32:59+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/05/29/183259</id>
    <content type="html"><![CDATA[<p>I added coverage test with cobertura and test the demo project built yesterday. Then I add Sonar Ant task in the ant script and saved test result into Sonar database.</p>

<p>The following is a standard build script(add junit-4.*.jar and cobertura.jar to $ANT_HOME/lib, in Ubuntu it is /usr/share/ant/lib):</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project name="MyJavaProj" basedir="./" default="coverage_report"&gt;
    &lt;property name="build.dir" value="${basedir}/build" /&gt;
    &lt;target name="init"&gt;
        &lt;delete dir="${build.dir}"/&gt;
        &lt;mkdir dir="${build.dir}"/&gt;
    &lt;/target&gt;

    &lt;property name="src.dir" value="${basedir}/src" /&gt;
    &lt;property name="src.class.dir" value="${build.dir}/class" /&gt;
    &lt;target name="compile-src" depends="init"&gt;
        &lt;mkdir dir="${src.class.dir}"/&gt;
        &lt;javac srcdir="${src.dir}" destdir="${src.class.dir}" encoding="UTF-8" debug="true"/&gt;
    &lt;/target&gt;
    &lt;taskdef classpath="cobertura.jar" resource="tasks.properties" /&gt;
    &lt;property name="instrumented.class.dir" value="${build.dir}/instrumented-class" /&gt;
    &lt;property name="cobertura.data.file" value="${instrumented.class.dir}/cobertura.ser" /&gt;

    &lt;target name="instrument" depends="compile-src"&gt;
        &lt;cobertura-instrument datafile="${cobertura.data.file}" todir="${instrumented.class.dir}"&gt;
        &lt;fileset dir="${src.class.dir}"&gt;
            &lt;include name="**/*.class" /&gt;
        &lt;/fileset&gt;
        &lt;/cobertura-instrument&gt;
    &lt;/target&gt;

    &lt;property name="test.dir" value="${basedir}/test" /&gt;
    &lt;property name="test.class.dir" value="${build.dir}/test" /&gt;
    &lt;target name="compile-test" depends="instrument"&gt;
        &lt;mkdir dir="${test.class.dir}"/&gt;
        &lt;javac srcdir="${test.dir}" destdir="${test.class.dir}"&gt;
            &lt;classpath&gt;
                &lt;pathelement location="${instrumented.class.dir}"/&gt;
                &lt;pathelement location="${src.class.dir}"/&gt;
            &lt;/classpath&gt;
        &lt;/javac&gt;
    &lt;/target&gt;

    &lt;property name="unittest.report.dir" value="${build.dir}/unittest_report" /&gt;
    &lt;property name="lib.dir" value="${basedir}/lib" /&gt;
    &lt;target name="unittest" depends="compile-test"&gt;
        &lt;mkdir dir="${unittest.report.dir}"/&gt;
        &lt;junit printsummary="yes" fork="yes"&gt;
            &lt;sysproperty key="net.sourceforge.cobertura.datafile" file="${cobertura.data.file}" /&gt;
            &lt;classpath&gt;
                &lt;pathelement location="${instrumented.class.dir}"/&gt;
                &lt;pathelement location="${src.class.dir}"/&gt;
                &lt;pathelement location="${test.class.dir}"/&gt;
                &lt;pathelement location="${src.dir}"/&gt;
                &lt;path refid="lib.path"/&gt;
            &lt;/classpath&gt;
            &lt;formatter type="xml"/&gt;
            &lt;batchtest todir="${unittest.report.dir}" haltonerror="no"&gt;
                &lt;fileset dir="${test.dir}"&gt;
                    &lt;include name="**/*.java" /&gt;
                &lt;/fileset&gt;
            &lt;/batchtest&gt;
        &lt;/junit&gt;
    &lt;/target&gt;

    &lt;property name="coverage.report.dir" value="${build.dir}/coverage_report" /&gt;
    &lt;target name="coverage-report" depends="unittest"&gt;
        &lt;cobertura-report datafile="${cobertura.data.file}" srcdir="${src.dir}" destdir="${coverage.report.dir}" format="xml" /&gt;
    &lt;/target&gt;

    &lt;property name="sonar.jdbc.url" value="jdbc:h2:tcp://localhost:9092/sonar" /&gt;
    &lt;property name="sonar.jdbc.username" value="sonar" /&gt;
    &lt;property name="sonar.jdbc.password" value="sonar" /&gt;
    &lt;property name="sonar.projectKey" value="com.doco.gif.MyModule" /&gt;
    &lt;property name="sonar.projectName" value="My Unit Test Project Demo" /&gt;
    &lt;property name="sonar.projectVersion" value="2.1" /&gt;
    &lt;property name="sonar.language" value="java" /&gt;
    &lt;property name="sonar.sources" value="src" /&gt;
    &lt;property name="sonar.tests" value="test" /&gt;
    &lt;property name="sonar.binaries" value="${src.class.dir},${test.class.dir},${build.instrument.dir}" /&gt;
    &lt;property name="sonar.dynamicAnalysis" value="reuseReports" /&gt;
    &lt;property name="sonar.surefire.reportsPath" value="${unittest.report.dir}" /&gt;
    &lt;property name="sonar.core.codeCoveragePlugin" value="cobertura" /&gt;
    &lt;property name="sonar.cobertura.reportPath" value="${coverage.report.dir}/coverage.xml" /&gt;
    &lt;target name="sonar" depends="coverage-report"&gt;
        &lt;taskdef uri="antlib:org.sonar.ant" resource="org/sonar/ant/antlib.xml"&gt;
            &lt;classpath path="/usr/share/ant/lib/sonar-ant-task-2.1.jar" /&gt;
        &lt;/taskdef&gt;
        &lt;sonar:sonar xmlns:sonar="antlib:org.sonar.ant" /&gt;
    &lt;/target&gt;
&lt;/project&gt;
</code></pre>

<p>To run this script successfully:</p>

<ol>
<li><p>build a demo java project and put this script at project root;</p></li>
<li><p>copy sonar-ant-task-2.1.jar and junit-4.11.jar to $ANT_HOME/lib;</p></li>
<li><p>start Sonar server: $SONAR_HOME/bin/sonar.sh console;</p></li>
<li><p>run this script: ant sonar;</p></li>
</ol>


<p>Note1: you have to add &ldquo;sonar.core.codeCoveragePlugin&rdquo; or coverage result can&rsquo;t be collected by Sonar. This is not mentioned in official documents<a href="http://docs.codehaus.org/display/SONAR/Code+Coverage+by+Unit+Tests+for+Java+Project">Code Coverage by Unit Tests for Java Project</a>;</p>

<p>Note2: take care of the spelling: &ldquo;sonar.surefire.report<strong>s</strong>Path&rdquo; while &ldquo;sonar.cobertura.reportPath&rdquo;;</p>

<p>Note3: the &ldquo;xmlns:sonar="antlib:org.sonar.ant&rdquo; in &ldquo;sonar:sonar&rdquo; is necessary or the prefix &ldquo;sonar&rdquo; would be unbound;</p>

<p>Note4: if unit test results can&rsquo;t be collected by Sonar, try to specify &ldquo;sonar.binaries&rdquo; carefully as above shows;</p>

<p>Note5: the value of junit report path &ldquo;sonar.surefire.reportsPath&rdquo; is a <strong>directory</strong>(because there are lots of reports under this folder), while the value of cobertura report is a <strong>file</strong>, if sonar can not get junit or cobertura report, verify these settings;</p>

<p>Note6: if there are &ldquo;class &hellip; is not accessible through the ClassLoader.&rdquo; in output of sonar task, there are two solutions:</p>

<ol>
<li><p>remove property &ldquo;sonar.binaries&rdquo;, where Sonar will not check bytecode;</p></li>
<li><p>in case you want Sonar check bytecodes, add property &ldquo;sonar.libraries&rdquo; like follows:</p>

<p> <property name="sonar.libraries" value="src/lib/*.jar,src/lib/dom4j/*.jar"/></p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unit Test With JUnit and Ant]]></title>
    <link href="http://leetschau.github.io/blog/2013/05/28/185513/"/>
    <updated>2013-05-28T18:55:13+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/05/28/185513</id>
    <content type="html"><![CDATA[<p>I put junit-4.11.jar to $ANT_HOME/lib folder(I didn&rsquo;t set ANT_HOME environment virable), then I can use <junit> task in ant script as follows:</p>

<p> <target name="unit_test" depends="compile">
  <mkdir dir="${test.report.dir}"/>
  <junit printsummary="yes" fork="yes">
   <classpath>
    <pathelement location="${src.class.dir}"/>
    <pathelement location="${test.class.dir}"/>
    <pathelement location="${lib.dir}/hamcrest-core-1.3.jar" />
   </classpath>
   <formatter type="plain"/>
   <batchtest todir="${test.report.dir}" haltonerror="no">
    <fileset dir="${test.dir}">
      <include name="**/*.java" />
    </fileset>
   </batchtest>
  </junit>
 </target></p>

<p>A pitfall here is that Junit depends on hamcrest(see junit website), but if you put hamcrest-core-1.3.jar to $ANT_HOME/lib, there will be a &ldquo;Class not found&rdquo; error. It&rsquo;s probably a bug or version matching problem of junit. You have to put hamcrest jar file in &ldquo;classpath&rdquo; element of junit task as above.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试Scala代码]]></title>
    <link href="http://leetschau.github.io/blog/2011/11/29/104637/"/>
    <updated>2011-11-29T10:46:37+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/11/29/104637</id>
    <content type="html"><![CDATA[<p>test.bat内容：</p>

<p>set JUnitPath=C:\Users\chad.ivy2\cache\junit\junit\jars\junit-4.8.2.jar
set ScalaLibraryPath=F:\Software\scala-2.9.1.final\lib\scala-library.jar
scalac -cp %JUnitPath%;. SampleTest.scala
rem java -cp %JUnitPath%;%ScalaLibraryPath%;. org.junit.runner.JUnitCore SampleTest</p>

<p>SampleTest.scala内容：</p>

<p>import java.util.ArrayList
import org.junit.Test
import org.junit.Assert._
class SampleTest {
 @Test def listAdd() {
 val list = new ArrayList[String]
 list.add(&ldquo;Milk&rdquo;)
 list add &ldquo;Sugar&rdquo;
 assertEquals(2, list.size())
 }
}</p>

<p>注：set表达式中，变量名、等号和值三者之间不能有空格，否则赋值失败。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[怎样在类外部测试私有方法和设置/读取私有变量]]></title>
    <link href="http://leetschau.github.io/blog/2011/02/23/105520/"/>
    <updated>2011-02-23T10:55:20+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/02/23/105520</id>
    <content type="html"><![CDATA[<p>有些私有方法有很明确的功能，算法比较复杂，不测可能会出问题。测的话最简单的方法是把测试用例写在类内部，例如下面的类：</p>

<p> package com.boco.godu.gapi;</p>

<p> import static org.junit.Assert.assertEquals;</p>

<p> import org.junit.Test;</p>

<p> public class ConnManager {</p>

<p> private static String buildConnPoolID(int connType, String ip, int port, String loginArg1, String loginArg2) {</p>

<p> return connType + ip;</p>

<p> }</p>

<p> @Test</p>

<p> public void testPoolID() {</p>

<p> assertEquals(&ldquo;23ipstr&rdquo;, buildConnPoolID(23, &ldquo;ipstr&rdquo;, 3, null, null));</p>

<p> }</p>

<p> }</p>

<p>但这样测会有几个问题：首先是如果测试方法很多，会把源代码文件搞得很臃肿，其次发布的时候需要将测试代码删除（毕竟不是产品的一部分），以后再需要测试的时候还得重写，最后这样的测试在BVT的时候无法运行，工作量也无法体现出来（BVT的测试用例都是写在单独的测试类中）。所以理想的方法是把测试方法写在单独的测试类中。</p>

<p>下面采用Java的反射机制实现这一目标。首先是被测类：</p>

<p> package org.leechau.testPrivateMethod;</p>

<p> public class ClassTested {</p>

<p> private String buffer ;</p>

<p> private String privateFoo (int a, String b) {</p>

<p> return a + b;</p>

<p> }</p>

<p> }</p>

<p>然后是测试类：</p>

<p> package org.leechau.testPrivateMethod;</p>

<p> import static org.junit.Assert.assertEquals;</p>

<p> import java.lang.reflect.InvocationTargetException;</p>

<p> import java.lang.reflect.Method;</p>

<p> import org.junit.BeforeClass;</p>

<p> import org.junit.Test;</p>

<p> public class PrivateMethodTest {</p>

<p> private static ClassTested oClassTested;</p>

<p> private static Method newPrivateFoo;</p>

<p> private static Field buffer;</p>

<p> @BeforeClass</p>

<p> public static void buildDupObj() throws NoSuchMethodException {</p>

<p> // Get the class of the private method.</p>

<p> oClassTested = new ClassTested();</p>

<p> Class&lt;?> cNewClassTested = oClassTested. getClass ();</p>

<p> // Change the property of the private method to be accessible.</p>

<p> newPrivateFoo = cNewClassTested. getDeclaredMethod (&ldquo;privateFoo&rdquo;,</p>

<p> int.class, String.class);</p>

<p> newPrivateFoo. setAccessible (true);</p>

<p> buffer =  cNewClassTested  . getDeclaredField (&ldquo;buffer&rdquo;);</p>

<p> buffer. setAccessible (true);</p>

<p> buffer. set ( oClassTested  , &ldquo;abcdefg&rdquo;);</p>

<p> }</p>

<p> @Test</p>

<p> public void privateFooTest() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {</p>

<p> // Run the private method.</p>

<p> Object oActual = newPrivateFoo. invoke (oClassTested, new Integer(169),  new String(&ldquo;_ABC&rdquo;));</p>

<p> // Test the private method</p>

<p> String sActual = oActual.toString();</p>

<p> String sExpected = &ldquo;169_ABC&rdquo;;</p>

<p> assertEquals(sActual, sExpected);</p>

<p> Object result = buffer. get ( oClassTested );</p>

<p> assertEquals(&ldquo;bcdefg&rdquo;, result);</p>

<p> }</p>

<p> @Test</p>

<p> public void privateFooTest2() throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {</p>

<p> Object oActual = newPrivateFoo. invoke (oClassTested, new Integer(169), new String(&ldquo;_DEF&rdquo;));</p>

<p> String sActual = oActual.toString();</p>

<p> String sExpected = &ldquo;169_DEF&rdquo;;</p>

<p> assertEquals(sActual, sExpected);</p>

<p> }</p>

<p> }</p>

<p>这里要注意的是，JUnit 4里一个测试类执行顺序为：@BeforeClass –> @Before –> @Test –> @After –> @AfterClass，其中@BeforeClass和@AfterClass标记仅在测试类的初始化和清理时运行一次且必须是static方法，而@Before/@After标记是在每个@Test方法运行前/后都运行一遍，因此每一个测试方法的调用顺序为：@Before –> @Test –> @After。在JUnit 3里没有@BeforeClass和@AfterClass标记，起初始化和清理任务的方法必须命名为SetUp()和TearDown()。</p>
]]></content>
  </entry>
  
</feed>
