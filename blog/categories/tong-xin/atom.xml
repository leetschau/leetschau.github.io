<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 通信 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/tong-xin/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-02-02T16:10:00+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最简单的Socket通信之Python版]]></title>
    <link href="http://leetschau.github.io/blog/2011/03/16/145839/"/>
    <updated>2011-03-16T14:58:39+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/03/16/145839</id>
    <content type="html"><![CDATA[<p>功能很简单，首先运行Server，当启动Client并向Server发送‘hi’时，Server回答一句问候语，当Client发送其他信息时，Server回答&#8217;bye&#8217;并关闭连接、退出。</p>

<p>Server端：</p>

<pre><code>import sys, socket 
serv = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
serv.bind(('localhost',7788)) 
serv.listen(2) 
while True: 
    connection,address = serv.accept() 
    try: 
        connection.settimeout(35) 
        buf = connection.recv(1024) 
        if buf=='hi': 
            connection.send('welcome to server!') 
        else: 
            connection.send('bye!') 
            connection.close() 
            sys.exit(0) 
    except socket.timeout: 
        print 'time out!' 
</code></pre>

<p>Client端：</p>

<pre><code>import socket 
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
sock.connect(('localhost', 7788)) 
import time 
time.sleep(2) 
sock.send('hi') 
print sock.recv(1024) 
sock.close() 
</code></pre>

<p>注意Server和Client都在本机运行时，要在不同的软件上运行，例如Server用WingIDE跑，Client用PyScripter跑。</p>

<p>Server端通信的基本过程是：建立socke对象->bind->listen->connection周期->close，其中connection周期是：首先用socket server的accept方法生成一个新的socket对象（习惯上成为connection）然后用connection的send/rec方法发送/接收数据，最后调用connection的close方法关闭连接。由于服务器经常要以“服务”的形式不断处理客户连接，因此connection周期通常要放在一个循环体里。</p>

<p>Client端通信的基本过程是：建立socke对象->connect->send/recv->close。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通信框架学习笔记]]></title>
    <link href="http://leetschau.github.io/blog/2010/09/30/164309/"/>
    <updated>2010-09-30T16:43:09+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/09/30/164309</id>
    <content type="html"><![CDATA[<p>Netty是如何处理信息的？例如Netty中有Handler，是否有filter？是否也使用链式结构？IoSession对应的类是什么？</p>

<p>Netty如何处理session与properties在时间上的矛盾？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java网络通信程序（一对多）]]></title>
    <link href="http://leetschau.github.io/blog/2010/05/07/111652/"/>
    <updated>2010-05-07T11:16:52+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/05/07/111652</id>
    <content type="html"><![CDATA[<p>在前文“Java网络通信程序（一对一）”基础上，实现了一个服务器为多个客户端提供服务的功能，本文基于[1]之10.3.9节例10-4和10-5，修正了一些变量递增错误，删去了两个无用的变量。本文使用的客户端程序与前文完全相同。
MultiTalkServer.java倒数第6行代码表明代码中可以直接使用同一目录下其他public类（这里是ServerThread类），无需import。
[1] 陈明：Java语言程序设计，清华大学出版社，2009.6</p>

<p> MultiTalkServer.java
import java.io.<em>;
import java.net.</em>;
public class MultiTalkServer{
 static int clientNum = 1;
 public static void main(String args[]) throws IOException {
 ServerSocket serverSocket = null;
 boolean listening = true;
 try {
  serverSocket = new ServerSocket(4700);
  System.out.println(&ldquo;MultiTalkServer Started.\n&rdquo;);
 }
 catch (IOException e){
  System.out.println(&ldquo;Could not listen to port 4700.&rdquo;);
  System.exit(-1);
 }
 while (listening) {
  new ServerThread(serverSocket.accept(), clientNum).start(); //直接引用同一文件夹下的其他公共类
  clientNum++;
 }
 serverSocket.close();
 }
}</p>

<p> ServerThread.java
import java.io.<em>;
import java.net.</em>;
 public class ServerThread extends Thread {
 Socket socket = null;
 int clientNum;
 public ServerThread(Socket socket, int num){
 this.socket = socket;
 clientNum = num;
 }
 public void run(){
 try{
  String line;
  BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream()));
  PrintWriter os = new PrintWriter(socket.getOutputStream());
  System.out.println(&ldquo;Connected to Client #&rdquo;+clientNum+&ldquo;.&rdquo;);
  System.out.println();
  do{
  line = is.readLine();
  System.out.println(&ldquo;Client #&rdquo;+clientNum+&ldquo; says: &rdquo;+line);
  System.out.println(&ldquo; To Client&rdquo;+clientNum+&ldquo;: you said: &rdquo;+line);
  System.out.println();
  os.println(&ldquo;You said: &rdquo;+line);
  os.flush();
  } while (! line.equals(&ldquo;bye&rdquo;));
  os.close();
  is.close();
  socket.close();
 }
 catch (Exception e){
  System.out.println(&ldquo;Error:&rdquo;+e);
 }
 }
}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java网络通信程序（一对一）]]></title>
    <link href="http://leetschau.github.io/blog/2010/05/07/110500/"/>
    <updated>2010-05-07T11:05:00+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/05/07/110500</id>
    <content type="html"><![CDATA[<p>本文是基于[1]之10.3.8节的阅读笔记，文末的两个java程序改自该节例10-2和10-3。</p>

<p> Client/Server结构的Java程序由两个独立的程序组成，每个程序的核心功能都由4个对象相互协作实现：
 1 Socket，这是网络通信的核心；
 2 信息发送者：是一个PrintWriter对象，与Socket的输出流绑定，负责发送信息，见Server程序第26行，Client程序第12行；
 3 信息接收者：是一个BufferedReader对象，首先与Socket的输入流绑定，然后将输入的字节流转换为字符流，见Server程序第25行，Client程序第13行；
 4 用户输入处理器：这个对象处理本地用户的输入，将输入字符串以合适的形式保存或者展现，不涉及网络，服务端程序代码见27行，客户端见11行；
之所以接收者需要加一层字节流到字符流的转换（用InputStreamReader实现），是因为网络传输的字节而非字符。</p>

<p> 这类程序的基本结构由4个步骤组成：
 1 创建Socket，Server端可分为两个子步骤（见程序第8-23行），第一步是创建一个ServerSocket对象，第二步是用它的accept方法在某一端口监听，等待客户端连接（程序运行到这里进入等待状态，也就是书中所谓的“阻塞”，在未收到客户端连接之前，不运行后面的代码）；Client端比较简单（见程序第8行），创建一个Socket对象就OK了；
 2 为Socket配置信息发送和接收者，服务端程序代码见25、26行，客户端见12、13行；
 3 开始进行信息传递，代码见第29-36行（服务端）和15-22行（客户端），服务端运行到第30行is.readLine()等待socket的输入流，进入等待状态，与此同时客户端运行到第17行sin.readLine()等待用户输入，例如用户输入&#8217;aa&#8217;并回车，则程序执行到第20行is.readLine()（第20行）进入等待socket输入流状态，同时服务端收到了客户端os.flush()发送的信息并打印出来（第30行），得到用户输入（第32行）后向客户端发送（第35行），本次通信完成，客户端得到了socket的输出流后打印出来（第20行），本次通信完成。以上就此一次完整的do while循环内容。
 4 通信结束，关闭Socket，见第37-46行（服务端）和24-31行（客户端）。</p>

<p>[1] 陈明：Java语言程序设计，清华大学出版社，2009.6</p>

<p> TalkServer.java（服务端程序）
01 import java.io.<em>;
02 import java.net.</em>;
03
04 public class TalkServer {
05
06 public static void main(String[] args) {
07 try{
08  ServerSocket server = null;
09  try{
10  server = new ServerSocket(4700);
11  System.out.println(&ldquo;Server Started.&rdquo;);
12  }
13  catch(Exception e){
14  System.out.println(&ldquo;Can not listen to:&rdquo;+e);
15  }
16  Socket socket = null;
17  try{
18  socket = server.accept();
19  System.out.println(&ldquo;Connected to Client.&rdquo;);
20  }
21  catch(Exception e){
22  System.out.println(&ldquo;Error:&rdquo;+e);
23  }
24  String line;
25  BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream()));
26  PrintWriter os = new PrintWriter(socket.getOutputStream());
27  BufferedReader sin = new BufferedReader(new InputStreamReader(System.in));
28  System.out.println();
29  do{
30  System.out.println(&ldquo;Client &rdquo;+is.readLine());
31  System.out.println(&ldquo;To Client:&rdquo;);
32  line = sin.readLine();
33  System.out.println();
34  os.println(line);
35  os.flush();
36  } while(! line.equals(&ldquo;bye&rdquo;));
37  os.close();
38  is.close();
39  socket.close();
40  server.close();
41 }
42 catch (Exception e){
43  System.out.println(&ldquo;Error:&rdquo;+e);
44 }
45 }
46 }
 TalkClient.java（客户端程序）
01 import java.io.<em>;
02 import java.net.</em>;
03
04 public class TalkClient {
05
06 public static void main(String[] args) {
07 try {
08 Socket socket = new Socket(&ldquo;127.0.0.1&rdquo;,4700);
09 System.out.println(&ldquo;Connected to Server.&rdquo;);
10 System.out.println();
11 BufferedReader sin = new BufferedReader(new InputStreamReader(System.in));
12 PrintWriter os = new PrintWriter(socket.getOutputStream());
13 BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream()));
14 String readline;
15 do{
16  System.out.print(&ldquo;To Server:&rdquo;);
17  readline = sin.readLine();
18  os.println(readline);
19  os.flush();
20  System.out.println(&ldquo;Server says:&rdquo;+is.readLine());
21  System.out.println();
22 }
23 while (! readline.equals(&ldquo;bye&rdquo;));
24 os.close();
25 is.close();
26 }
27 catch(Exception e){
28 System.out.println(&ldquo;Error&rdquo;+e);
29 }
30 }
31 }</p>
]]></content>
  </entry>
  
</feed>
