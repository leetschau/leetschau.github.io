<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tcl/tk | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/tcl-slash-tk/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-11-11T14:51:43+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Get Tcl and Expect Version on Ubuntu]]></title>
    <link href="http://leetschau.github.io/blog/2013/08/26/112747/"/>
    <updated>2013-08-26T11:27:47+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/08/26/112747</id>
    <content type="html"><![CDATA[<h1>tcl version</h1>

<p> $ tclsh</p>

<p> % puts $tcl_version
 8.5</p>

<h1>expect version</h1>

<p> $ expect -v</p>

<p> expect version 5.45</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exercies of Chapter 2 in `Exploring Expect`]]></title>
    <link href="http://leetschau.github.io/blog/2013/08/20/102248/"/>
    <updated>2013-08-20T10:22:48+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/08/20/102248</id>
    <content type="html"><![CDATA[<blockquote><ol>
<li>Write a procedure to reverse a string. If you wrote an iterative solution, now write a recursive solution or vice versa.</li>
</ol>
</blockquote>

<p> #!/usr/bin/tclsh</p>

<p> # iterative solution:</p>

<p> proc rev_str_iter { input } {
  for {set idx [string length $input]} {$idx > 0} {incr idx -1} {
   append res [string index $input [expr $idx-1]]
  }
  return $res
 }
 # recursive solution:
 proc rev_str_recur { input } {
  set len [string length $input]
  if {[expr $len - 1] > 0} {
   append res [rev_str_recur [string range $input 1 end]] \
             [string index $input 0]
  } else {
   set res $input
  }
  return $res
 }
 set m &ldquo;abcdefg&rdquo;
 set n [rev_str_iter $m]
 puts $n
 set n2 [rev_str_recur $m]
 puts $n2</p>

<blockquote><ol>
<li>Repeat the previous exercise but with a list instead of a string.</li>
</ol>
</blockquote>

<p> #!/usr/bin/tclsh
 # iterative solution:
 proc rev_list_iter { input } {
  for {set idx [llength $input]} {$idx > 0} {incr idx -1} {
   lappend res [lindex $input [expr $idx-1]]
  }
  return $res
 }
 # recursive solution:
 proc rev_list_recur { input } {
  set len [llength $input]
  if {[expr $len - 1] > 0} {
   set res [concat [rev_list_recur [lrange $input 1 end]] [lindex $input 0]]
  } else {
   set res $input
  }
  return $res
 }
 set m &ldquo;a b c d e g&rdquo;
 set n [rev_list_iter $m]
 puts $n
 set n2 [rev_list_recur $m]
 puts $n2</p>

<blockquote><ol>
<li>Write a procedure to rename all the files in a directory ending with .c to names ending in &ldquo;.cc“.</li>
</ol>
</blockquote>

<p> #!/usr/bin/tclsh
 foreach file_name [glob *.c] {
  file rename $file_name [append file_name c]
 }</p>

<blockquote><ol>
<li>Write a procedure that takes a list of variable names and a list of values, and sets each variable in the list to the respective value in the other list. Think of different alternatives to handle the case when the lists are of different lengths.</li>
</ol>
</blockquote>

<p> #!/usr/bin/tclsh
 proc assign {names values} {
  if {[llength $names] > [llength $values]} {
   set len [llength $values]
  } else {
   set len [llength $names]
  }
  for {set idx 0} {$idx&lt;$len} {incr idx} {
   set var_name [lindex $names $idx]
   set $var_name [lindex $values $idx]
   puts [concat $var_name = [set $var_name]]
  }
 }
 set names &ldquo;za bb ee dk&rdquo;
 set values &ldquo;11 32 53 94 5&rdquo;
 assign $names $values</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tcl Shell Notes]]></title>
    <link href="http://leetschau.github.io/blog/2013/08/20/101843/"/>
    <updated>2013-08-20T10:18:43+08:00</updated>
    <id>http://leetschau.github.io/blog/2013/08/20/101843</id>
    <content type="html"><![CDATA[<ul>
<li><p>Start origin tcl shell: tclsh (apt-get install tcl);</p></li>
<li><p>Start tcl shell with command history shortcuts (up arrow for previous command and other powerful command line shortcuts like alt+backspace, brackets matching, etc. on Ubuntu): rlwrap -c tclsh;</p></li>
</ul>


<p>For efficiency, add <code>alias tcl="rlwrap -c tclsh"</code> to ~/.zshrc;</p>

<p>Note: rlwrap is readline wrapper;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[“柴油机总体分析系统”开发手记]]></title>
    <link href="http://leetschau.github.io/blog/2010/04/23/083909/"/>
    <updated>2010-04-23T08:39:09+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/04/23/083909</id>
    <content type="html"><![CDATA[<p>该项目是应贾德文要求，做一个后端数值计算＋前端GUI实现，要求开发工具兼具较强的数值计算能力（尤其是矩阵和向量计算）、易用性（不需要内存、指针、堆栈、消息等专门知识）、用户图形界面（GUI）开发和程序打包（生成单一exe文件）功能。备选方案有pyhton、matlab和scilab，matlab是商业软件，体积庞大，GUI和打包比较麻烦，scilab数值计算功能一般，语法比较独特，GUI采用Tcl实现，好像也没有打包功能，而python平台在这方面表现最好，numpy模块的数值计算功能强大，GUI设计方面，简单界面可选Tkinter，复杂的可选wxPython，打包用py2exe模块，因此本项目最终选择在WinXP + python2.5平台上完成。 tkinter的界面设计基本方法：多层frame嵌套；
一般是两句定义一个控件，第一句定义控件特征，第二句定义放置方法，Label和Button可实现单语句定义；
向量数字的格式化输出，同时转化为长度固定的字符串： Python中[for ii in aa]的强大功能：见附件的第212、213行（给resMtx幅值的语句，在表达式中使用for语句）； Text的tab控制输出格式：格式字符串也可实现对齐，但tab stop有4种对齐方式，功能更强； GUI字体的设置方法：定义专门的字体设置字符串； 中文GUI界面的编码问题：在文件头加上：# -<em>- coding:utf-8 -</em>-，指明用utf8编码； CheckBox的判断： 界面上取得的字符串转化为数组，进行数学运算后表现在界面上：
from numpy import *
from Tkinter import *
def solve1():
 resStr = inp_txt.get(&lsquo;1.0&rsquo;,END)
 bb = fromstring(resStr,&rsquo;d',-1,&lsquo; &rsquo;).reshape(3,-1)
 print type(bb)
 print bb.shape
 out_txt.insert(&lsquo;1.0&rsquo;, transpose(bb))
root = Tk()
top = Frame(root)
top.pack(side=&lsquo;top&rsquo;)
inp_txt = Text(top, font=(&lsquo;Times&rsquo;,12),height=5,width=30)
inp_txt.insert(&lsquo;1.0&rsquo;,&lsquo;12 23\n34 45\n34.5 98.234&rsquo;)
inp_txt.pack(side=&lsquo;top&rsquo;)
Button(top, text=&lsquo;solve&rsquo;, command=solve1).pack(side=&lsquo;top&rsquo;,padx=40)
out_txt = Text(top, font=(&lsquo;Times&rsquo;,12),height=5,width=30)
out_txt.pack(side=&lsquo;top&rsquo;)
root.mainloop()
其他python编程实践：单句代码的折行、多句代码放在一行；pass语句的作用；</p>

<p>下面是Anova.py文件内容：
 # -<em>- coding:utf-8 -</em>-
 from Tkinter import Tk, Frame, LabelFrame, Label, Entry, Text, Button, \
  IntVar, Checkbutton, X, CENTER, NUMERIC, END
 from numpy import zeros, transpose, fromstring, reshape
 import rwMtx as rwm
 from tkMessageBox import showwarning</p>

<p> def Anova7(schMtx, calcMtx):
  k = 7 # total number of factors
  m = 3 # total number of levels
  n = 18 # total number of experiments
  r = n/m
  # here add the format check
  T = sum(calcMtx)
  CT = T<strong>2/n
  QT = sum(calcMtx</strong>2)
  ST = QT - CT
  K = zeros((m ,k))
  K[0,0] = sum(calcMtx[0:3]) + sum(calcMtx[9:12])
  K[1,0] = sum(calcMtx[3:6]) + sum(calcMtx[12:15])
  K[2,0] = sum(calcMtx[6:9]) + sum(calcMtx[15:18])
  K[0,1] = calcMtx[0]+calcMtx[3]+calcMtx[6]+calcMtx[9]+calcMtx[12]+calcMtx[15]
  K[1,1] = calcMtx[1]+calcMtx[4]+calcMtx[7]+calcMtx[10]+calcMtx[13]+calcMtx[16]
  K[2,1] = calcMtx[2]+calcMtx[5]+calcMtx[8]+calcMtx[11]+calcMtx[14]+calcMtx[17]
  K[0,2] = calcMtx[0]+calcMtx[3]+calcMtx[8]+calcMtx[10]+calcMtx[14]+calcMtx[16]
  K[1,2] = calcMtx[1]+calcMtx[4]+calcMtx[6]+calcMtx[11]+calcMtx[12]+calcMtx[17]
  K[2,2] = calcMtx[2]+calcMtx[5]+calcMtx[7]+calcMtx[9]+calcMtx[13]+calcMtx[15]
  K[0,3] = calcMtx[0]+calcMtx[5]+calcMtx[6]+calcMtx[10]+calcMtx[13]+calcMtx[17]
  K[1,3] = calcMtx[1]+calcMtx[3]+calcMtx[7]+calcMtx[11]+calcMtx[14]+calcMtx[15]
  K[2,3] = calcMtx[2]+calcMtx[4]+calcMtx[8]+calcMtx[9]+calcMtx[12]+calcMtx[16]
  K[0,4] = calcMtx[0]+calcMtx[5]+calcMtx[7]+calcMtx[11]+calcMtx[12]+calcMtx[16]
  K[1,4] = calcMtx[1]+calcMtx[3]+calcMtx[8]+calcMtx[9]+calcMtx[13]+calcMtx[17]
  K[2,4] = calcMtx[2]+calcMtx[4]+calcMtx[6]+calcMtx[10]+calcMtx[14]+calcMtx[15]
  K[0,5] = calcMtx[0]+calcMtx[4]+calcMtx[8]+calcMtx[11]+calcMtx[13]+calcMtx[15]
  K[1,5] = calcMtx[1]+calcMtx[5]+calcMtx[6]+calcMtx[9]+calcMtx[14]+calcMtx[16]
  K[2,5] = calcMtx[2]+calcMtx[3]+calcMtx[7]+calcMtx[10]+calcMtx[12]+calcMtx[17]
  K[0,6] = calcMtx[0]+calcMtx[4]+calcMtx[7]+calcMtx[9]+calcMtx[14]+calcMtx[17]
  K[1,6] = calcMtx[1]+calcMtx[5]+calcMtx[8]+calcMtx[10]+calcMtx[12]+calcMtx[15]
  K[2,6] = calcMtx[2]+calcMtx[3]+calcMtx[6]+calcMtx[11]+calcMtx[13]+calcMtx[16]
  Q = zeros(k)
  for i in range(k):
   Q[i] = sum(K[:,i]**2)/r
  S = Q - CT
  Se = ST - sum(S) # error of S
  dofLevel = m - 1 # degree of freedom
  dofSum = n - 1
  dofErr = dofSum - dofLevel * k
  sms = S / dofLevel # sum of mean square
  errSms = Se / dofErr
  F0 = sms / errSms
  Ap = (F0 - F0.min())/((F0.max() - F0.min())/0.9) + 0.1
  A = (Ap/sum(Ap)).transpose()
  R = zeros((k,m))
  for i in range(k):
   R[i,:] = (schMtx[i,:] - schMtx[i,:].min())/((schMtx[i,:].max() - schMtx[i,:].min())/0.9) + 0.1
  B = zeros(m)
  for i in range(m):
   dd = zeros(k)
   for j in range(k):
    dd[j] = min(A[j],R[j,i])
   B[i] = max(dd)
  min_index = B.argmin() # optimization result
  # assemble the return value:
  return B, schMtx[:,min_index]</p>

<p> def Anova5(calcMtx):
  k = 5 # total number of factors
  m = 3 # total number of levels
  n = 18 # total number of experiments
  r = n/m
  # here add the format check
  T = sum(calcMtx)
  CT = T<strong>2/n
  QT = sum(calcMtx</strong>2)
  ST = QT - CT
  K = zeros((m ,k))
  K[0,0] = sum(calcMtx[0:3]) + sum(calcMtx[9:12])
  K[1,0] = sum(calcMtx[3:6]) + sum(calcMtx[12:15])
  K[2,0] = sum(calcMtx[6:9]) + sum(calcMtx[15:18])
  K[0,1] = calcMtx[0]+calcMtx[3]+calcMtx[6]+calcMtx[9]+calcMtx[12]+calcMtx[15]
  K[1,1] = calcMtx[1]+calcMtx[4]+calcMtx[7]+calcMtx[10]+calcMtx[13]+calcMtx[16]
  K[2,1] = calcMtx[2]+calcMtx[5]+calcMtx[8]+calcMtx[11]+calcMtx[14]+calcMtx[17]
  K[0,2] = calcMtx[0]+calcMtx[3]+calcMtx[8]+calcMtx[10]+calcMtx[14]+calcMtx[16]
  K[1,2] = calcMtx[1]+calcMtx[4]+calcMtx[6]+calcMtx[11]+calcMtx[12]+calcMtx[17]
  K[2,2] = calcMtx[2]+calcMtx[5]+calcMtx[7]+calcMtx[9]+calcMtx[13]+calcMtx[15]
  K[0,3] = calcMtx[0]+calcMtx[5]+calcMtx[7]+calcMtx[11]+calcMtx[12]+calcMtx[16]
  K[1,3] = calcMtx[1]+calcMtx[3]+calcMtx[8]+calcMtx[9]+calcMtx[13]+calcMtx[17]
  K[2,3] = calcMtx[2]+calcMtx[4]+calcMtx[6]+calcMtx[10]+calcMtx[14]+calcMtx[15]
  K[0,4] = calcMtx[0]+calcMtx[4]+calcMtx[8]+calcMtx[11]+calcMtx[13]+calcMtx[15]
  K[1,4] = calcMtx[1]+calcMtx[5]+calcMtx[6]+calcMtx[9]+calcMtx[14]+calcMtx[16]
  K[2,4] = calcMtx[2]+calcMtx[3]+calcMtx[7]+calcMtx[10]+calcMtx[12]+calcMtx[17]
  Q = zeros(k)
  for i in range(k):
   Q[i] = sum(K[:,i]**2)/r
  S = Q - CT
  Se = ST - sum(S) # error of S
  dofLevel = m - 1 # degree of freedom
  dofSum = n - 1
  dofErr = dofSum - dofLevel * k
  sms = S / dofLevel # sum of mean square
  errSms = Se / dofErr
  F0 = sms / errSms
  optLevel = K.argmin(0)+1
  resMtx = {&lsquo;factors&rsquo;:[&lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;, &rsquo;D', &lsquo;E&rsquo;, &lsquo;Error&rsquo;, &lsquo;Sum&rsquo;], &rsquo;S':[&lsquo;%10.5f&rsquo;%ii for ii in S], &lsquo;Se&rsquo;:&lsquo;%10.5f&rsquo;%Se, &lsquo;ST&rsquo;:&lsquo;%10.5f&rsquo;%ST,\
   &lsquo;dofLevel&rsquo;:dofLevel, &lsquo;dofErr&rsquo;:dofErr, &lsquo;dofSum&rsquo;:dofSum, &lsquo;sms&rsquo;:[&lsquo;%10.5f&rsquo;%ii for ii in sms], &lsquo;errSms&rsquo;:&lsquo;%10.5f&rsquo;%errSms, &lsquo;F0&rsquo;:[&lsquo;%10.5f&rsquo;%ii for ii in F0], &lsquo;optLevel&rsquo;:optLevel}
  return resMtx</p>

<p> def Anova4(calcMtx):
  k = 4 # total number of factors
  m = 3 # total number of levels
  n = 9 # total number of experiments
  r = n/m
  # here add the format check
  T = sum(calcMtx)
  CT = T<strong>2/n
  QT = sum(calcMtx</strong>2)
  ST = QT - CT
  K = zeros((m ,k))
  K[0,0] = calcMtx[0]+calcMtx[1]+calcMtx[2]
  K[1,0] = calcMtx[3]+calcMtx[4]+calcMtx[5]
  K[2,0] = calcMtx[6]+calcMtx[7]+calcMtx[8]
  K[0,1] = calcMtx[0]+calcMtx[3]+calcMtx[6]
  K[1,1] = calcMtx[1]+calcMtx[4]+calcMtx[7]
  K[2,1] = calcMtx[2]+calcMtx[5]+calcMtx[8]
  K[0,2] = calcMtx[0]+calcMtx[5]+calcMtx[7]
  K[1,2] = calcMtx[1]+calcMtx[3]+calcMtx[8]
  K[2,2] = calcMtx[2]+calcMtx[4]+calcMtx[6]
  K[0,3] = calcMtx[0]+calcMtx[4]+calcMtx[8]
  K[1,3] = calcMtx[1]+calcMtx[5]+calcMtx[6]
  K[2,3] = calcMtx[2]+calcMtx[3]+calcMtx[7]
  Q = zeros(k)
  for i in range(k):
   Q[i] = sum(K[:,i]**2)/r
  S = Q - CT
  Se = min(S) # error of S
  dofLevel = m - 1 # degree of freedom
  dofSum = n - 1
  dofErr = dofLevel
  sms = S / dofLevel # sum of mean square
  errSms = Se / dofErr
  F0 = sms / errSms
  optLevel = K.argmin(0)+1
  resMtx = {&lsquo;factors&rsquo;:[&lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;, &rsquo;D', &lsquo;Error&rsquo;, &lsquo;Sum&rsquo;], &rsquo;S':[&lsquo;%10.5f&rsquo;%ii for ii in S], &lsquo;Se&rsquo;:&lsquo;%10.5f&rsquo;%Se, &lsquo;ST&rsquo;:&lsquo;%10.5f&rsquo;%ST,\
   &lsquo;dofLevel&rsquo;:dofLevel, &lsquo;dofErr&rsquo;:dofErr, &lsquo;dofSum&rsquo;:dofSum, &lsquo;sms&rsquo;:[&lsquo;%10.5f&rsquo;%ii for ii in sms], &lsquo;errSms&rsquo;:&lsquo;%10.5f&rsquo;%errSms, &lsquo;F0&rsquo;:[&lsquo;%10.5f&rsquo;%ii for ii in F0], &lsquo;optLevel&rsquo;:optLevel}
  return resMtx</p>

<p> def Anova3(calcMtx):
  k = 3 # total number of factors
  m = 3 # total number of levels
  n = 9 # total number of experiments
  r = n/m
  # here add the format check
  T = sum(calcMtx)
  CT = T<strong>2/n
  QT = sum(calcMtx</strong>2)
  ST = QT - CT
  K = zeros((m ,k))
  K[0,0] = calcMtx[0]+calcMtx[1]+calcMtx[2]
  K[1,0] = calcMtx[3]+calcMtx[4]+calcMtx[5]
  K[2,0] = calcMtx[6]+calcMtx[7]+calcMtx[8]
  K[0,1] = calcMtx[0]+calcMtx[3]+calcMtx[6]
  K[1,1] = calcMtx[1]+calcMtx[4]+calcMtx[7]
  K[2,1] = calcMtx[2]+calcMtx[5]+calcMtx[8]
  K[0,2] = calcMtx[0]+calcMtx[5]+calcMtx[7]
  K[1,2] = calcMtx[1]+calcMtx[3]+calcMtx[8]
  K[2,2] = calcMtx[2]+calcMtx[4]+calcMtx[6]
  Q = zeros(k)
  for i in range(k):
   Q[i] = sum(K[:,i]**2)/r
  S = Q - CT
  Se = ST - sum(S) # error of S
  dofLevel = m - 1 # degree of freedom
  dofSum = n - 1
  dofErr = dofSum - dofLevel * k
  sms = S / dofLevel # sum of mean square
  errSms = Se / dofErr
  F0 = sms / errSms
  optLevel = K.argmin(0)+1
  resMtx = {&lsquo;factors&rsquo;:[&lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;C&rsquo;, &lsquo;Error&rsquo;, &lsquo;Sum&rsquo;], &rsquo;S':[&lsquo;%10.5f&rsquo;%ii for ii in S], &lsquo;Se&rsquo;:&lsquo;%10.5f&rsquo;%Se, &lsquo;ST&rsquo;:&lsquo;%10.5f&rsquo;%ST,\
   &lsquo;dofLevel&rsquo;:dofLevel, &lsquo;dofErr&rsquo;:dofErr, &lsquo;dofSum&rsquo;:dofSum, &lsquo;sms&rsquo;:[&lsquo;%10.5f&rsquo;%ii for ii in sms], &lsquo;errSms&rsquo;:&lsquo;%10.5f&rsquo;%errSms, &lsquo;F0&rsquo;:[&lsquo;%10.5f&rsquo;%ii for ii in F0], &lsquo;optLevel&rsquo;:optLevel}
  return resMtx</p>

<p> def Anova2(calcMtx):
  k = 2 # total number of factors
  m = 3 # total number of levels
  n = 9 # total number of experiments
  r = n/m
  # here add the format check
  T = sum(calcMtx)
  CT = T<strong>2/n
  QT = sum(calcMtx</strong>2)
  ST = QT - CT
  K = zeros((m ,k))
  K[0,0] = calcMtx[0]+calcMtx[1]+calcMtx[2]
  K[1,0] = calcMtx[3]+calcMtx[4]+calcMtx[5]
  K[2,0] = calcMtx[6]+calcMtx[7]+calcMtx[8]
  K[0,1] = calcMtx[0]+calcMtx[3]+calcMtx[6]
  K[1,1] = calcMtx[1]+calcMtx[4]+calcMtx[7]
  K[2,1] = calcMtx[2]+calcMtx[5]+calcMtx[8]
  Q = zeros(k)
  for i in range(k):
   Q[i] = sum(K[:,i]**2)/r
  S = Q - CT
  Se = ST - sum(S) # error of S
  dofLevel = m - 1 # degree of freedom
  dofSum = n - 1
  dofErr = dofSum - dofLevel * k
  sms = S / dofLevel # sum of mean square
  errSms = Se / dofErr
  F0 = sms / errSms
  optLevel = K.argmin(0)+1
  resMtx = {&lsquo;factors&rsquo;:[&lsquo;A&rsquo;, &lsquo;B&rsquo;, &lsquo;Error&rsquo;, &lsquo;Sum&rsquo;], &rsquo;S':[&lsquo;%10.5f&rsquo;%ii for ii in S], &lsquo;Se&rsquo;:&lsquo;%10.5f&rsquo;%Se, &lsquo;ST&rsquo;:&lsquo;%10.5f&rsquo;%ST,\
   &lsquo;dofLevel&rsquo;:dofLevel, &lsquo;dofErr&rsquo;:dofErr, &lsquo;dofSum&rsquo;:dofSum, &lsquo;sms&rsquo;:[&lsquo;%10.5f&rsquo;%ii for ii in sms], &lsquo;errSms&rsquo;:&lsquo;%10.5f&rsquo;%errSms, &lsquo;F0&rsquo;:[&lsquo;%10.5f&rsquo;%ii for ii in F0], &lsquo;optLevel&rsquo;:optLevel}
  return resMtx</p>

<p> def F0_evaluate(input_array, factor_number):
  #F0数组显著性判断函数
  #print input_array
  if factor_number==5:
   F_005 = 4.74
   F_001 = 9.55
  elif factor_number==2:
   F_005 = 6.94
   F_001 = 18
  else:
   F_005 = 19
   F_001 = 99
  eval_res = []
  for theValue in input_array:
   theNumber = float(theValue)
   if theNumber>F_001: eval_res.append(&lsquo;<em>*&rsquo;)
   elif theNumber&lt;F_005: eval_res.append(&lsquo;-&rsquo;)
   else: eval_res.append(&lsquo;</em>&rsquo;)
  return eval_res</p>

<p> def solve_7():
  tStr = txt_sch.get(&lsquo;1.0&rsquo;,END)
  schemeMtx = transpose(fromstring(tStr,&rsquo;d',-1,&lsquo; &rsquo;).reshape(3,-1))
  tStr = txt_expRes.get(&lsquo;1.0&rsquo;,END)
  calcResMtx = fromstring(tStr,&rsquo;d',-1,&lsquo; &rsquo;)
  txt_optRes.delete(0, END)
  txt_optRes.insert(0, Anova7(schemeMtx, calcResMtx)[0])
  txt_optSch.delete(0, END)
  txt_optSch.insert(0, Anova7(schemeMtx, calcResMtx)[1])</p>

<p> def solve_2345():
  selected_item = chkb1.get()+chkb2.get()+chkb3.get()+chkb4.get()+chkb5.get()
  if selected_item == 5:
   calcResFile = open(&lsquo;data/expRes5.txt&rsquo;,&lsquo;r&rsquo;)
   calcResMtx = rwm.read(calcResFile)
   calcResFile.close()
   theRes = Anova5(calcResMtx)
   tt = &lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][0]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][0]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][0]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][0]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],5)[0]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][1]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][1]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][1]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][1]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],5)[1]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][2]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][2]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][2]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][2]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],5)[2]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][3]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][3]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][3]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][3]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],5)[3]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][4]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][4]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][4]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][4]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],5)[4]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][5]+&lsquo;\t&rsquo;+theRes[&lsquo;Se&rsquo;]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofErr&rsquo;])+&lsquo;\t&rsquo; +theRes[&lsquo;errSms&rsquo;]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][6]+&lsquo;\t&rsquo;+theRes[&lsquo;ST&rsquo;]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofSum&rsquo;])
   f3_res.delete(&lsquo;1.0&rsquo;, END)
   f3_res.insert(&lsquo;1.0&rsquo;, tt)
   txt_optLevel.delete(0, END)
   txt_optLevel.insert(0, theRes[&lsquo;optLevel&rsquo;])
  elif selected_item == 4:
   calcResFile = open(&lsquo;data/expRes4.txt&rsquo;,&lsquo;r&rsquo;)
   calcResMtx = rwm.read(calcResFile)
   calcResFile.close()
   theRes = Anova4(calcResMtx)
   tt = &lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][0]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][0]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][0]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][0]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],4)[0]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][1]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][1]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][1]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][1]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],4)[1]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][2]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][2]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][2]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][2]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],4)[2]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][3]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][3]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][3]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][3]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],4)[3]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][4]+&lsquo;\t&rsquo;+theRes[&lsquo;Se&rsquo;]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofErr&rsquo;])+&lsquo;\t&rsquo; +theRes[&lsquo;errSms&rsquo;]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][5]+&lsquo;\t&rsquo;+theRes[&lsquo;ST&rsquo;]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofSum&rsquo;])
   f3_res.delete(&lsquo;1.0&rsquo;, END)
   f3_res.insert(&lsquo;1.0&rsquo;, tt)
   txt_optLevel.delete(0, END)
   txt_optLevel.insert(0, theRes[&lsquo;optLevel&rsquo;])
  elif selected_item == 3:
   calcResFile = open(&lsquo;data/expRes3.txt&rsquo;,&lsquo;r&rsquo;)
   calcResMtx = rwm.read(calcResFile)
   calcResFile.close()
   theRes = Anova3(calcResMtx)
   tt = &lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][0]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][0]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][0]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][0]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],3)[0]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][1]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][1]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][1]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][1]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],3)[1]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][2]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][2]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][2]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][2]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],3)[2]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][3]+&lsquo;\t&rsquo;+theRes[&lsquo;Se&rsquo;]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofErr&rsquo;])+&lsquo;\t&rsquo; +theRes[&lsquo;errSms&rsquo;]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][4]+&lsquo;\t&rsquo;+theRes[&lsquo;ST&rsquo;]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofSum&rsquo;])
   f3_res.delete(&lsquo;1.0&rsquo;, END)
   f3_res.insert(&lsquo;1.0&rsquo;, tt)
   txt_optLevel.delete(0, END)
   txt_optLevel.insert(0, theRes[&lsquo;optLevel&rsquo;])
  elif selected_item == 2:
   calcResFile = open(&lsquo;data/expRes2.txt&rsquo;,&lsquo;r&rsquo;)
   calcResMtx = rwm.read(calcResFile)
   calcResFile.close()
   theRes = Anova2(calcResMtx)
   tt = &lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][0]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][0]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][0]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][0]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],2)[0]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][1]+&lsquo;\t&rsquo;+theRes[&rsquo;S'][1]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofLevel&rsquo;])+&lsquo;\t&rsquo; \
    +theRes[&lsquo;sms&rsquo;][1]+&lsquo;\t&rsquo;+theRes[&lsquo;F0&rsquo;][1]+&lsquo;\t&rsquo;+F0_evaluate(theRes[&lsquo;F0&rsquo;],2)[1]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][2]+&lsquo;\t&rsquo;+theRes[&lsquo;Se&rsquo;]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofErr&rsquo;])+&lsquo;\t&rsquo; +theRes[&lsquo;errSms&rsquo;]+&lsquo;\n&rsquo; \
    +&lsquo;\t&rsquo;+theRes[&lsquo;factors&rsquo;][3]+&lsquo;\t&rsquo;+theRes[&lsquo;ST&rsquo;]+&lsquo;\t&rsquo;+str(theRes[&lsquo;dofSum&rsquo;])
   f3_res.delete(&lsquo;1.0&rsquo;, END)
   f3_res.insert(&lsquo;1.0&rsquo;, tt)
   txt_optLevel.delete(0, END)
   txt_optLevel.insert(0, theRes[&lsquo;optLevel&rsquo;])
  else:
   showwarning(&lsquo;项目选择错误&rsquo;,&lsquo;请选择至少两项&rsquo;)</p>

<p> #===================== 界面设计 ===========================
 root = Tk()
 top = Frame(root)
 top.pack(side=&lsquo;top&rsquo;)
 #========定义字体============
 font_chs = (&lsquo;宋体&rsquo;, 12)
 font_eng = (&lsquo;Times&rsquo;, 12)
 #==========标题====================
 lbl_Title = Label(top, text=&lsquo;柴油机结构系统优化软件&rsquo;, font=(&lsquo;宋体&rsquo;, 16)).pack(side=&lsquo;top&rsquo;, padx=15, pady=10, ipadx=10, fill=X)
 #=============第1部分===============
 f1 = LabelFrame(top, text=&lsquo;柴油机总体参数&rsquo;, font=font_chs)
 f1_1 = Frame(f1, padx=10)
 Label(f1_1, text=&lsquo;功率：&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;)
 txt_power = Entry(f1_1, font=font_eng)
 txt_power.pack(side=&lsquo;left&rsquo;)
 f1_1.pack(side=&lsquo;left&rsquo;)</p>

<p> f1_2 = Frame(f1, padx=10)
 Label(f1_2, text=&lsquo;气缸数：&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;)
 txt_cyNo = Entry(f1_2, font=font_eng)
 txt_cyNo.pack(side=&lsquo;left&rsquo;)
 f1_2.pack(side=&lsquo;left&rsquo;)</p>

<p> f1_3 = Frame(f1, padx=10)
 Label(f1_3, text=&lsquo;冲程数：&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;)
 txt_strikeNo = Entry(f1_3, font=font_eng)
 txt_strikeNo.pack(side=&lsquo;left&rsquo;)
 f1_3.pack(side=&lsquo;left&rsquo;)</p>

<p> f1.pack(side=&lsquo;top&rsquo;, padx=15, pady=10, ipadx=10, ipady=10, fill=X)</p>

<p> #=============第2部分===============
 f2 = LabelFrame(top, text=&lsquo;柴油机本体结构参数评价及优化&rsquo;, font=font_chs)
 f2_1 = Frame(f2, pady = 10)
 f2_1_1 = Frame(f2_1, padx=1)
 Label(f2_1_1, text=&lsquo;方案：&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;)
 txt_sch = Text(f2_1_1, font=font_eng, height=3, width=40)
 txt_sch.pack(side=&lsquo;left&rsquo;)
 f2_1_1 .pack(side=&lsquo;left&rsquo;)
 f2_1_2 = Frame(f2_1, padx=10)
 Label(f2_1_2, text=&lsquo;试验结果：&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;)
 txt_expRes = Text(f2_1_2, font=font_eng, height=3, width=10)
 txt_expRes.pack(side=&lsquo;left&rsquo;)
 f2_1_2 .pack(side=&lsquo;left&rsquo;)
 Button(f2_1, text=&lsquo;参数分析&rsquo;, font=font_chs, command=solve_7).pack(side=&lsquo;left&rsquo;,padx=40)
 f2_1.pack(side=&lsquo;top&rsquo;)</p>

<p> f2_2 = Frame(f2, padx=1)
 f2_2_1 = Frame(f2_2, padx=10)
 Label(f2_2_1, text=&lsquo;评价结果：&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;)
 txt_optRes = Entry(f2_2_1, font=font_eng, bg=&lsquo;grey&rsquo;, width=32)
 txt_optRes.pack(side=&lsquo;left&rsquo;,anchor=&lsquo;c&rsquo;)
 f2_2_1.pack(side=&lsquo;left&rsquo;)</p>

<p> f2_2_2 = Frame(f2_2)
 Label(f2_2_2, text=&lsquo;优选方案：&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;)
 txt_optSch = Entry(f2_2_2, font=font_eng, bg=&lsquo;grey&rsquo;, width=32)
 txt_optSch.pack(side=&lsquo;left&rsquo;,anchor=&lsquo;c&rsquo;)
 f2_2_2.pack(side=&lsquo;left&rsquo;)
 f2_2.pack(side=&lsquo;top&rsquo;,anchor=&lsquo;w&rsquo;)
 f2.pack(side=&lsquo;top&rsquo;, padx=15, pady=5, ipadx=1, ipady=10, fill=X)</p>

<p> #=============第3部分===============
 f3 = LabelFrame(top, text=&lsquo;柴油机系统布置优化&rsquo;, font=font_chs)
 f3_top = Frame(f3)
 f3_1 = Frame(f3_top, padx=10)
 chkb1 = IntVar(); chkb2 = IntVar(); chkb3 = IntVar(); chkb4 = IntVar(); chkb5 = IntVar()
 chb_inlet = Checkbutton(f3_1, text=&lsquo;进排气系&rsquo;, font=font_chs, variable=chkb1)
 chb_inlet.pack(side=&lsquo;top&rsquo;, anchor=&lsquo;w&rsquo;)
 chb_lub = Checkbutton(f3_1, text=&lsquo;润滑系&rsquo;, font=font_chs, variable=chkb2)
 chb_lub.pack(side=&lsquo;top&rsquo;, anchor=&lsquo;w&rsquo;)
 chb_cool = Checkbutton(f3_1, text=&lsquo;冷却系&rsquo;, font=font_chs, variable=chkb3)
 chb_cool.pack(side=&lsquo;top&rsquo;, anchor=&lsquo;w&rsquo;)
 chb_start = Checkbutton(f3_1, text=&lsquo;起动系&rsquo;, font=font_chs, variable=chkb4)
 chb_start.pack(side=&lsquo;top&rsquo;, anchor=&lsquo;w&rsquo;)
 chb_turbo = Checkbutton(f3_1, text=&lsquo;增压器中冷装置&rsquo;, font=font_chs, variable=chkb5)
 chb_turbo.pack(side=&lsquo;top&rsquo;, anchor=&lsquo;w&rsquo;)
 f3_1.pack(side=&lsquo;left&rsquo;)
 f3_2 = Frame(f3_top, padx=10)
 Button(f3_2, text=&lsquo;求解&rsquo;, font=font_chs, command=solve_2345).pack(side=&lsquo;left&rsquo;)
 f3_2.pack(side=&lsquo;left&rsquo;)
 f3_3 = Frame(f3_top, padx=10)
 f3_3_1 = Frame(f3_3)
 Label(f3_3_1, text=&lsquo;方差来源&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;, anchor=&lsquo;w&rsquo;)
 Label(f3_3_1, text=&lsquo;偏差平方和&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;, padx=8)
 Label(f3_3_1, text=&lsquo;自由度&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;, padx=8)
 Label(f3_3_1, text=&lsquo;方差&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;, padx=25)
 Label(f3_3_1, text=&lsquo;F0值&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;, padx=20)
 Label(f3_3_1, text=&lsquo;显著性&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;, anchor=&lsquo;e&rsquo;, padx=4)
 f3_3_1.pack(side=&lsquo;top&rsquo;, fill=X, expand=1)
 f3_res = Text(f3_3, font=font_eng, bg=&lsquo;grey&rsquo;, height=7, width=65, tabs=(&lsquo;1c&rsquo;,CENTER,\
  &lsquo;3c&rsquo;,NUMERIC,&lsquo;5.5c&rsquo;,NUMERIC,&lsquo;7c&rsquo;,NUMERIC,&lsquo;9.2c&rsquo;,NUMERIC,&lsquo;11.5c&rsquo;,CENTER))
 f3_res.pack(side=&lsquo;top&rsquo;)
 f3_3.pack(side=&lsquo;left&rsquo;)
 f3_top.pack(side=&lsquo;top&rsquo;)</p>

<p> f3_bottom = Frame(f3, pady =10)
 Label(f3_bottom, text=&lsquo;优水平：&rsquo;, font=font_chs).pack(side=&lsquo;left&rsquo;)
 txt_optLevel = Entry(f3_bottom, font=font_eng, bg=&lsquo;grey&rsquo;, width=32)
 txt_optLevel.pack(side=&lsquo;left&rsquo;,anchor=&lsquo;c&rsquo;)
 f3_bottom.pack(side=&lsquo;top&rsquo;, anchor=&lsquo;e&rsquo;, ipadx=90)</p>

<p> f3.pack(side=&lsquo;top&rsquo;, padx=15, pady=10, ipadx=10, ipady=10, fill=X)</p>

<p> root.title(&lsquo;柴油机结构系统优化软件&rsquo;)
 root.mainloop()</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Ultraedit调试tk程序]]></title>
    <link href="http://leetschau.github.io/blog/2009/11/18/155015/"/>
    <updated>2009-11-18T15:50:15+08:00</updated>
    <id>http://leetschau.github.io/blog/2009/11/18/155015</id>
    <content type="html"><![CDATA[<p>tk没有自己的编译环境，Ultraedit中仅3步就可以打造一个tk调试环境：
1. 为UE添加tcl/tk语法高亮支持：从UE的网站上下载tcl/tk的wordfile；
2. 添加编译命令到菜单中：UE主菜单【高级->工具配置】出现“工具配置窗口：</p>

<p>在【命令】标签页中：</p>

<p>点击按钮“插入”</p>

<p>【菜单项目】：运行tk程序</p>

<p>【命令行】：wish85 %n%e（%n表示当前文件名（不含扩展名），%e表示当前文件名的扩展名）</p>

<p>【工作目录】：%p（当前文件的路径）</p>

<p>在【输出】标签页中：
 选择【Output to List Box】（运行结果显示在输出窗口中，此窗口在【窗口->输出窗口】或者【视图->视图/列表->输出窗口】处设置开闭，其他几项是输出到指定的文件中）和【Capture Output】（否则输出不会被捕捉到）</p>

<ol>
<li>为菜单项添加快捷键：【高级->配置->键盘映射】中找到【高级－用户工具1】，在【按下新的键】中设置自己喜欢的热键，例如F6。</li>
</ol>


<p>参考博文《如何用UltraEdit编译和运行java程序》。</p>

<p>注：UEv16中，标签页也是可浮动的，感觉不方便，在【配置->Application Layout->File Tabs->Operation】中取消勾选【Dockable Tabs】。</p>
]]></content>
  </entry>
  
</feed>
