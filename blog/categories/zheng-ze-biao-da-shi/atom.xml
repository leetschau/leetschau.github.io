<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 正则表达式 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/zheng-ze-biao-da-shi/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-09-10T17:28:18+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Groovy正则表达式复杂逻辑判断实例]]></title>
    <link href="http://leetschau.github.io/blog/2011/07/23/103345/"/>
    <updated>2011-07-23T10:33:45+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/07/23/103345</id>
    <content type="html"><![CDATA[<p>下面的两个pattern（p1和p2）分别代表了(A or B) and (C or D)和(A and B) or (C and D)的跨行匹配结果，当然还可以用正则表达式构建更复杂的pattern，但这个实例证明了Groovy具备跨行匹配复杂逻辑表达式的能力。</p>

<p> 值得注意的是，多行匹配文本时需要在匹配字符串前加“(?ms)”。</p>

<p> 该实例同时演示了Groovy闭包的使用方法。
 源代码</p>

<p> msg1 = &lsquo;&rsquo;&lsquo;one two three four</p>

<p> five six&#8217;&lsquo;&rsquo;</p>

<p> msg2 = &lsquo;&rsquo;&lsquo;Jan Feb Mar</p>

<p> Apr May Jun&#8217;&lsquo;&rsquo;</p>

<p> msg3 = &lsquo;&rsquo;&lsquo;one two three</p>

<p> Apr May Jun&#8217;&lsquo;&rsquo;</p>

<p> msg4 = &lsquo;&rsquo;&lsquo;Jan Feb Mar</p>

<p> four five six&#8217;&lsquo;&rsquo;</p>

<p> p1 = / (?ms) (two|Feb).*(five|May)/</p>

<p> p2 = / (?ms) (two.<em>five)|(Feb.</em>May)/</p>

<p> msgs = [msg1, msg2, msg3, msg4]</p>

<p> patterns = [p1, p2]</p>

<p> patterns.each { pattern-></p>

<p> println &lsquo;pattern is: &rsquo;+pattern</p>

<p> msgs.each { msg-></p>

<p> println &lsquo;msg is: &rsquo;+msg</p>

<p> println &lsquo;match result is:&rsquo;</p>

<p> matcher = msg =~ pattern</p>

<p> if (matcher)</p>

<p> println &ldquo;true&rdquo;</p>

<p> else</p>

<p> println &ldquo;false&rdquo;</p>

<p> println &lsquo;&mdash;&rsquo;</p>

<p> }</p>

<p> println &lsquo;===&rsquo;</p>

<p> }
 运行结果
 pattern is: (?ms)(two|Feb).*(five|May)</p>

<p> msg is: one two three four</p>

<p> five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: one two three</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> four five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<hr />

<p> pattern is: (?ms)(two.<em>five)|(Feb.</em>May)</p>

<p> msg is: one two three four</p>

<p> five six</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> true</p>

<hr />

<p> msg is: one two three</p>

<p> Apr May Jun</p>

<p> match result is:</p>

<p> false</p>

<hr />

<p> msg is: Jan Feb Mar</p>

<p> four five six</p>

<p> match result is:</p>

<p> false</p>

<hr />

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[日期格式转换的正则表达式实现]]></title>
    <link href="http://leetschau.github.io/blog/2011/07/19/164331/"/>
    <updated>2011-07-19T16:43:31+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/07/19/164331</id>
    <content type="html"><![CDATA[<p>原始文本：</p>

<blockquote><p>2011年7月18日：修改密码的核心功能开发完毕；
2011年7月19日：上午换座位，下午提交了著作权文档的电子流程；</p></blockquote>

<p>目标格式文本：</p>

<blockquote><p>2011-7-18：修改密码的核心功能开发完毕；
2011-7-19：上午换座位，下午提交了著作权文档的电子流程；</p></blockquote>

<h1>vim实现</h1>

<pre><code>:%s/\(\d\{4}\).\(\d\{1,2}\).\(\d\{1,2}\)./\1-\2-\3/g 
</code></pre>

<p>说明： 采用 :%s/old/new/g 命令进行替换，其中%表示对所有行进行替换操作，最后的g参数表明对一行中所有的new均替换为old。\d代表任意数字，old pattern中每个括号（即(&hellip;)）中的内容构成一个group member，new pattern中对group member的引用用\1、\2、\3&hellip;代表，即&#8221;BRE&#8221;, back references.</p>

<h1>Groovy实现</h1>

<pre><code>oriStr = '''2011年7月18日：修改密码的核心功能开发完毕； 
2011年7月19日：上午换座位，下午提交了著作权文档的电子流程；'''; 
pattern = /(\d{4})\W(\d{1,2})\W(\d{1,2})\W/; 
matcher = oriStr =~ pattern; 
matcher.each { all,y,m,d-&gt; 
    println 'Patten is: '+all; 
    println 'Replaced by: '+y+'-'+m+'-'+d; 
}; 
println '*****'; 
println oriStr.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d;}; 
</code></pre>

<p>运行结果：</p>

<pre><code>Patten is: 2011年7月18日 
Replaced by: 2011-7-18 
Patten is: 2011年7月19日 
Replaced by: 2011-7-19 
***** 
2011-7-18：修改密码的核心功能开发完毕； 
2011-7-19：上午换座位，下午提交了著作权文档的电子流程； 
</code></pre>

<p>说明： 跨行字符串用三引号括起来；匹配模式用“ /&hellip;/” 括起来；用模式匹配字符串时，每一次成功匹配构成了matcher的一个元素（代码中用matcher.each得到），如果模式当中包含group（可以matcher.hasGroup()判断），则这个元素本身也是一个List，其中第一个元素是符合模式的substring（代码中的all），各个group member可以用下标引用，也可以分别起名字（代码中分别为y、m、d）。这部分内容可参见《Groovy in Action》（2007版）第3.5节“Working with regular expressions”。Groovy的String.replaceAll方法包括两个参数，第一个是要被代替的pattern，第二个是用来代替pattern的closure，该closure的返回结果是最后一行代码的值。</p>

<p>例如：<code>println oriStr.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d;return 'Date'};</code> 的输出是：</p>

<pre><code>Date：修改密码的核心功能开发完毕； 
Date：上午换座位，下午提交了著作权文档的电子流程； 
</code></pre>

<h1>基于文件读写的Groovy实现</h1>

<pre><code>pattern = /(\d{4})\W(\d{1,2})\W(\d{1,2})\W/; 
convStr = ''; 
new File('f:/Edit3.txt').eachLine{ 
    convStr += (it.replaceAll (pattern) {all,y,m,d-&gt;y+'-'+m+'-'+d})+'\n' 
} 
new File('f:/conv.txt').write convStr; 
</code></pre>

<p>说明： 第4行的it表示此行文本（字符串）。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更新ivy资源库的自动化脚本]]></title>
    <link href="http://leetschau.github.io/blog/2011/06/28/145204/"/>
    <updated>2011-06-28T14:52:04+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/06/28/145204</id>
    <content type="html"><![CDATA[<p>为产品库添加一个新jar包需要下面几个步骤：</p>

<ol>
<li><p>根据jar包名字，从maven库里得到依赖定义字符串；</p></li>
<li><p>将该字符串加上配置说明和下载脚本（参见笔记“依赖管理常用vim脚本”）；</p></li>
<li><p>将已下载条目备份文件（installed.txt）另存为old.bpk；</p></li>
<li><p>将build.xml中的下载条目插入到installed.txt中（按字母顺序排列）；</p></li>
<li><p>用新的下载脚本替换build.xml中原有的下载脚本；</p></li>
<li><p>运行ant命令将jar包下载到产品库中；</p></li>
<li><p>在ivy.xml中加入依赖条目，解析之；</p></li>
</ol>


<p>以下是上面1~5步的自动化脚本。</p>

<p> #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p> # Purpose:  download jars to public repo</p>

<p> # Author:  Li Chao</p>

<p> # Created:  28-06-2011</p>

<p> #</p>

<p> # Demonstration:</p>

<p> # install Apache Log4j 1.2</p>

<p> #  1. from mvnrepository.com we got the dep string:</p>

<p> #   <dependency org="log4j" name="log4j" rev="1.2.16"/></p>

<p> #  2. modify dep_str in this file with above dep string:</p>

<p> #  3. run this file, copy modified dep string:</p>

<p> #   <dependency org="log4j" name="log4j" rev="1.2.16" conf="compile->master&#8221;/></p>

<p> #  4. open a shell and run ant cmd to download jars of log4j</p>

<p> #  5. paste modified dep string to ivy.xml and resolve it</p>

<p> #&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p>

<p> #!/usr/bin/env python</p>

<p> import os, re</p>

<p> dep_str = &lsquo;<dependency org="log4j" name="log4j" rev="1.2.16"/>&rsquo;</p>

<p> cmd_pattern = &lsquo;&lt;ivy:install.+from=&ldquo;\${from.resolver}&rdquo; to=&ldquo;\${to.resolver}&rdquo;/>&rsquo;</p>

<p> script = &lsquo;build.xml&rsquo;</p>

<p> def conv_str():</p>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>   covert dep_str to custom_ivy_dep string and ivy_install string;</p>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>  custom_ivy_dep = dep_str.replace(&lsquo;/>&rsquo;,&lsquo; conf=&ldquo;compile->master&rdquo;/>&rsquo;)</p>

<p>  print &lsquo;Copy the following String:\n%s&rsquo; %custom_ivy_dep</p>

<p>  keys = re.findall(r&#8217;&ldquo;\S+&rdquo;&lsquo;, dep_str)</p>

<p>  if len(keys)!=3:</p>

<p>   raise Exception(&lsquo;Format wrong of input string!&rsquo;)</p>

<p>  global ivy_install</p>

<p>  ivy_install = &lsquo;&lt;ivy:install organisation=%s module=%s revision=%s &rsquo;\</p>

<pre><code>  'from="${from.resolver}" to="${to.resolver}"/&gt;' %tuple(keys) 
</code></pre>

<p> def do_bpk():</p>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>   create backup file(filename: installed.txt/old.bpk):</p>

<pre><code>1 extract old install string from build.xml; 

2 delete old.bpk if it exists; 

3 rename installed.txt to old.bpk; 

4 read old.bpk file, insert old install string and create installed.txt file; 
</code></pre>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>  installed = &lsquo;installed.txt&rsquo;</p>

<p>  old_bpk =&lsquo;old.bpk&rsquo;</p>

<p>  xml_file = open(script)</p>

<p>  global xml_str</p>

<p>  xml_str = xml_file.read()</p>

<p>  xml_file.close()</p>

<p>  old_install = re.findall(cmd_pattern, xml_str, re.M)[0]</p>

<p>  print &lsquo;old install string is:\n%s&rsquo; %old_install</p>

<p>  if os.path.exists(old_bpk): os.remove(old_bpk)</p>

<p>  if os.path.exists(installed):</p>

<p>   os.rename(installed, old_bpk)</p>

<p>  else:</p>

<p>   raise Exception(&lsquo;%s does not exist!&rsquo;%installed)</p>

<p>  installed_file = open(old_bpk)</p>

<p>  installed_items = installed_file.read()</p>

<p>  installed_file.close()</p>

<p>  all_items = installed_items.split(&lsquo;\n&rsquo;)</p>

<p>  all_items.append(old_install)</p>

<p>  all_items.sort()</p>

<p>  bpk_file = open(installed,&lsquo;w&rsquo;)</p>

<p>  bpk_file.write( &lsquo;\n&rsquo;.join(all_items) )</p>

<p>  bpk_file.close()</p>

<p> def build_script():</p>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>   modify install script(build.xml): replace old install string with new one</p>

<p>  &ldquo;&rdquo;&#8221;</p>

<p>  xml_file = open(script,&lsquo;w&rsquo;)</p>

<p>  new_xml = re.sub(cmd_pattern, ivy_install, xml_str)</p>

<p>  xml_file.write(new_xml)</p>

<p>  xml_file.close()</p>

<p> def main():</p>

<p>  conv_str()</p>

<p>  do_bpk()</p>

<p>  build_script()</p>

<p> if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:</p>

<p>  main()</p>

<p>代码中的技术点包括：</p>

<ol>
<li><p>格式化字符串的生成方法：%后面必须接一个tuple；</p></li>
<li><p>如何使用正则表达式进行文本的搜索（findall）和替换(sub)；</p></li>
<li><p>字符串的join方法进行list的组合，也可以用reduce方法： total_str = reduce(lambda x,y:x+y, str_list)</p></li>
</ol>


<p>  但用join方法更简洁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VIM正则表达式的懒惰模式]]></title>
    <link href="http://leetschau.github.io/blog/2010/07/16/142741/"/>
    <updated>2010-07-16T14:27:41+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/07/16/142741</id>
    <content type="html"><![CDATA[<p>例如有如下一段话：
Another whale sighting occurred on <January 26>, <2004>. <B>AK</B> and <B>HI</B>
要匹配每一个&lt;&hellip;>，如果用&lt;.<em>>匹配，则匹配到的目标是<January 26>, <2004>，也就是尽量大的匹配范围，要将匹配模式改为尽量小（即懒惰模式），需要用{-}代替</em>，即写成&lt;.{-}>，就可以达到目标了。</p>
]]></content>
  </entry>
  
</feed>
