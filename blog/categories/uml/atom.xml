<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Uml | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/uml/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-05-26T17:50:21+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用ObjectAid生成Java代码的类图]]></title>
    <link href="http://leetschau.github.io/blog/2012/07/11/162523/"/>
    <updated>2012-07-11T16:25:23+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/07/11/162523</id>
    <content type="html"><![CDATA[<p>ObjectAid是一款比较好用的Java逆向工程工具（类似工具的比较见 自动生成Java类图工具比较 ），以下是使用方法。
 创建基于Java代码的类图
1. 安装objectaid插件：将objectaid-1.0.9.zip解压到$ECLIPSE_HOME/dropins/$OBJECTAID_PLUGIN_NAME下，目录结构如下：</p>

<ol>
<li><p>启动Eclipse，File -> New -> Other -> ObjectAid UML Diagram -> Next</p></li>
<li><p>&ldquo;Folder"后写上保存类图的位置，"Name"后面写类图的名字；</p></li>
<li><p>下面的选项里勾选上感兴趣的项目，其中"Relationships"中各项的含义见后面的说明；</p></li>
<li><p>&ldquo;Finish"。</p></li>
<li><p>打开新生成的类图文件（.ucls），将感兴趣的类文件拖入ucls文件窗口中（详细使用方法见ObjectAid官网上 如何生成类图的说明 ）；
对Relationships的说明（与标准UML中的术语不尽一致，如何对应以后再细分析，</p></li>
<li>继承(Generalization)：实线三角，子类/接口（Shell）指向父类/接口（ConnectionListener）；</li>
</ol>


<p> public interface Shell extends ConnectionListener</p>

<ol>
<li>实现(Realization)：虚线三角，源类（DummyShell）实现目标接口（Shell）；</li>
</ol>


<p> public class DummyShell implements Shell</p>

<ol>
<li>关联(Association)：实线箭头，源类（Connection）的一个field（m_NextShell）的类型是目标类/接口（Shell）；</li>
</ol>


<p> public class Connection {
 &hellip;
 private Shell m_NextShell;</p>

<ol>
<li>嵌入(Nesting)：如下图，内部类（IACHandler）嵌入到外部类（TelnetIO）中；</li>
</ol>


<p> public class TelnetIO {
 class IACHandler {
 &hellip;</p>

<ol>
<li>依赖(Dependencies)：虚线箭头，源的方法中出现了目标类对象；</li>
</ol>


<p> public class ShellManager {
 public Shell getShell(String key) {
  Shell myShell = null;
  &hellip;</p>

<p> 以上示例代码来自 Java Telnet daemon (wimpi)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自动生成Java类图工具比较]]></title>
    <link href="http://leetschau.github.io/blog/2012/07/03/153342/"/>
    <updated>2012-07-03T15:33:42+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/07/03/153342</id>
    <content type="html"><![CDATA[<p>ObjectAid : Eclipse插件，免费版只能生成类图，功能不错，可以用dropins方式离线安装（需要预先安装 GEF ）； EssModel : 独立运行，绿色软件，为java和delphi代码自动生成类图，功能还不错，有丢关系的现象； MoDisco : 只能在线安装，没有试用； BOUML : 可以运行在windows和CentOS上，付费软件，未试用； ModelGoon UML4Java : 不支持Eclipse 3.7； Architexa : 付费软件，没有试用； AgileJ : 付费软件，没有试用；</p>

<p> nWire 收费，功能很好</p>

<p>貌似Eclipse的MDT也有这种功能，有待确认；</p>

<p>Netbeans和IntelliJ也都有生成类图的插件，而不是内置功能，没有试用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Convert Java Codes to UML Diagram]]></title>
    <link href="http://leetschau.github.io/blog/2011/08/02/114314/"/>
    <updated>2011-08-02T11:43:14+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/08/02/114314</id>
    <content type="html"><![CDATA[<p>Power Designer -> File -> Reverse Engineer -> Object Language
 Object Language: Java</p>

<p> Reverse engineer: Java directories</p>

<p> Add &hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UML中关联(association)和依赖(dependency)的区别]]></title>
    <link href="http://leetschau.github.io/blog/2010/06/17/110050/"/>
    <updated>2010-06-17T11:00:50+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/06/17/110050</id>
    <content type="html"><![CDATA[<h2>下面是从网上搜集的一些关联(association)和依赖(dependency)区别的看法： </h2>

<h2>1. </h2>

<p>Dependency Relationship</p>

<p>Draw a dependency relationship between two classes, or between a class and an interface, to show that the client class depends on the supplier class/interface to provide certain services, such as:</p>

<p>?The client class accesses a value (constant or variable) defined in the supplier class/interface.</p>

<p>?Operations of the client class invoke operations of the supplier class/interface.</p>

<p>?Operations of the client class have signatures whose return class or arguments are instances of the supplier class/interface.</p>

<p>A dependency relationship is a dotted line with an arrowhead at one end:The arrowhead points to the supplier class.</p>

<p>Association Relationship</p>

<p>An association provides a pathway for communication. The communication can be between use cases and actors, between two classes or between a class and an interface. Associations are the most general of all relationships and consequentially the most semantically weak. If two objects are usually considered independently, the relationship is an association</p>

<hr />

<h2>2. </h2>

<p>Martin Fowler</p>

<p>If you have an association from Class A to Class B then that means every instance of class A has some kind of link to class B. Now exactly what people mean by &ldquo;some kind of link&rdquo; varies, it may be a conceptual link, a method of the form getA or a field inside class A. But the usual notion is that the link exists at all times (although if the lower bound is 0 it may be empty). This link can be used by any method of A and, if exposed, by other classes too.</p>

<p>With a parameter the connection between A and B only exists within the scope of the method that took the parameter. No other method can use the connection. As such that, for most people I come across, means that it is not an association.</p>

<p>The dependency means that if you change the interface of B then you may have to change A. An association usually implies a dependency, but not vice-versa, as the parameter example suggests.</p>

<hr />

<h2>3. </h2>

<p>Robert C. Martin
However, association is not free of semantics. An association is a data relationship. i.e. the implementation must use some sort of data variable to implement it. Typically this is done with some kind of member variable or instance variable that refers to the associate. In C++ we might create a pointer variable, in Java a reference variable. Or we might use some kind of string that represents the associate in a dictionary somewhere.</p>

<p>In order for a message to be send between two objects, an association must exist between their two classes; and that association must be navigable in the direction that the message was sent.</p>

<hr />

<h2>4. </h2>

<p>quote:</p>

<blockquote><p>What is the difference between Association and Dependency?</p>

<p>My understanding so far was:</p>

<p>If an object of class A has a reference to an object of class B in its
attribute structure, it is association.</p></blockquote>

<p>Robert C. Martin&rsquo;s answer:</p>

<p>Er, well, uh &ndash; hmmm.</p>

<p>That&rsquo;s as good a definition as any I suppose. There are so many different colloquialisms and slangs for UML that I guess it hardly matters any more.</p>

<p>There was a time when an association was the channel between classes over which messages were sent. No message, no association. But that rule has been relaxed by so much conventional usage that I don&rsquo;t think it can hold any more.</p>

<p>Nowadays we seem to use association and aggregation interchangeably to represent a data field (except, of course, that everybody has their own private definition for what the white diamond means.) Dependency if very commonly used to represent an argument passed to a function. This was not the original intent of UML, but it&rsquo;s the way things have turned out.</p>

<p>There was a time when dependency meant that a class knew about another, but did not send messages. Data structures had dependencies on their members because they didn&rsquo;t send them messages, whereas classes had associations with their members because they did send them messages. But that nice separation has gotten so badly muddled that it has become useless.</p>

<p>Perhaps you can read from my tone that I&rsquo;m pretty disillusioned with UML. Too bad. It could have been a standard. Now, I think its just going to be a confusing compendium of confounding conventions.</p>

<hr />

<h2>5. </h2>

<p>//
From UML 2.0 Superstructure Final Adopted Specification:
&ldquo;An association describes a set of tuples whose values refer to typed instances.&rdquo; (p. 97)
&ldquo;A dependency is a relationship that signifies that a single or a set of model elements requires other model elements for their specification or implementation.&rdquo; (p. 124)</p>

<hr />

<h2>6. </h2>

<p>依赖是比关联弱的关系，关联代表一种结构化的关系，体现在生成的代码中，以java为例：
 若类A单向关联指向类B，则在类A中存在一个属性B b。
若类A依赖类B，则不会有这个属性，类B的实例可能存在于某个方法调用的参数中，或某个方法的局部变量中。</p>

<hr />

<h2>7. </h2>

<p> 关联有双向与单向之分，类A与类B双向关联可以是A与B相互可以作为对方的一个attribute，单向的话，就指其中一个类作为另一个类中的 attribute；依赖就只有单向的，不存在attribute的问题，例如类A依赖类B，表示在类A中有三种类B的使用方法：一是类B是全局的，二是类B在类A中实例化，三是类B作为参数被传递</p>

<hr />

<h2>8. </h2>

<p>关联是一种结构关系，表现为一个对象能够获得另一个对象的实例引用并调用它的服务（即使用它）；依赖是一种使用关系，表现为一个对象仅仅是调用了另一个对象的服务。</p>
]]></content>
  </entry>
  
</feed>
