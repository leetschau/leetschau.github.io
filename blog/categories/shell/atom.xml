<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Shell | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2016-11-11T15:03:30+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Print First and Last Characters of a Line]]></title>
    <link href="http://leetschau.github.io/blog/2016/03/14/215015/"/>
    <updated>2016-03-14T21:50:15+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/03/14/215015</id>
    <content type="html"><![CDATA[<p>Some large files all content are in the same line,
there is no newline for the entire file.
For them it&rsquo;s very slow to view them with less or vim.
Instead we can use <code>head</code> and <code>tail</code>,
for example commands below print first and last 50 characters
of a large one-line file:</p>

<pre><code>cat large-one-line.json|head -c 50
cat large-one-line.json|tail -c 50
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Print Some Lines of a File With Head and Tail]]></title>
    <link href="http://leetschau.github.io/blog/2016/03/07/110735/"/>
    <updated>2016-03-07T11:07:35+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/03/07/110735</id>
    <content type="html"><![CDATA[<pre><code>$ echo "1\n2\n3\n4\n5\n6" &gt; test

$ cat test 
1
2
3
4
5
6

$ tail -n+2 test   // remove head (start from 2nd line)
2
3
4
5
6

$ head -n-2 test   // remove tail (discard last 2 lines)
1
2
3
4

$ head -2 test     // only head
1
2

$ tail -2 test     // only tail
5
6
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Duplicate Zsh History]]></title>
    <link href="http://leetschau.github.io/blog/2016/01/08/162914/"/>
    <updated>2016-01-08T16:29:14+08:00</updated>
    <id>http://leetschau.github.io/blog/2016/01/08/162914</id>
    <content type="html"><![CDATA[<p>To remove duplicate items in <a href="https://github.com/junegunn/fzf">fzf</a> prompt,
add the following lines into ~/.zshrc:</p>

<pre><code>setopt EXTENDED_HISTORY
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_FIND_NO_DUPS
setopt HIST_SAVE_NO_DUPS
setopt HIST_BEEP
</code></pre>

<p>Ref:</p>

<p><a href="https://wiki.archlinux.org/index.php/zsh#Preventing_duplicate_lines_in_the_history">Preventing duplicate lines in the history</a></p>

<p><a href="https://github.com/mattjj/my-oh-my-zsh/blob/master/history.zsh">https://github.com/mattjj/my-oh-my-zsh/blob/master/history.zsh</a></p>

<p><a href="http://zsh.sourceforge.net/Doc/Release/Options.html">zsh options</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Run Mongo Scripts in Shell]]></title>
    <link href="http://leetschau.github.io/blog/2015/05/08/155132/"/>
    <updated>2015-05-08T15:51:32+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/05/08/155132</id>
    <content type="html"><![CDATA[<p>You can query a remote mongoDB with a mongo script, print output to stdout.
Then manipulate the output data with other shell utilities.</p>

<p>For example, the following scripts get all fair names from a remote server,
compare them with a local fair name set,
to find out which are conflicted with the existing fair names in the local name.</p>

<p>Some key points:</p>

<ol>
<li><p>&ldquo;db&rdquo; is a built-in global variable refers to the connected database,
specified by the -h, -d options in mongo command line.
It can be override by &ldquo;connect&rdquo; function.
For example, with or without the first line, the script produce
the same result when running <code>mongo test.js</code>:</p>

<pre><code> $ cat test.js
 // db = connect("localhost/test")
 print(db.getCollectionNames())
 db.myCollection.find().forEach(function(item) {
   print(item.name)
 })
</code></pre></li>
<li><p>Use &ldquo;print&rdquo; function to print result to stdout.</p></li>
<li><p>To get command line arguments in mongo script,
you must compose the evaluation string before(outside) <code>mongo</code> command,
and you must add double quotes surrounding $exp.</p>

<pre><code> #!/bin/bash

 TargetDB=$1
 TargetCol=$2
 TargetField=$3

 exp="db.${TargetCol}.find().forEach( function(item) \
   { print(item.$TargetField); });"

 mongo localhost/$TargetDB --eval "$exp"
</code></pre></li>
</ol>


<p>Ref:</p>

<p><a href="http://docs.mongodb.org/manual/tutorial/write-scripts-for-the-mongo-shell/">Write Scripts for the mongo Shell</a></p>

<p><a href="http://stackoverflow.com/questions/8971151/file-write-operations-in-mongo-script">http://stackoverflow.com/questions/8971151/file-write-operations-in-mongo-script</a></p>

<p><a href="http://stackoverflow.com/questions/14478304/redirect-output-of-mongo-query-to-a-csv-file">http://stackoverflow.com/questions/14478304/redirect-output-of-mongo-query-to-a-csv-file</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fzf让命令行更方便]]></title>
    <link href="http://leetschau.github.io/blog/2015/04/16/172913/"/>
    <updated>2015-04-16T17:29:13+08:00</updated>
    <id>http://leetschau.github.io/blog/2015/04/16/172913</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/junegunn/fzf">fzf</a>是一个命令行工具，目前支持bash和zsh。</p>

<p>fzf配合autojump和vim，可以方便地在多层目录下进行文本编辑。</p>

<p>Before install fzf, download <a href="https://golang.org/">go</a> binary package (go1.4.2.linux-amd64.tar.gz for now)
extract it, and add its bin folder to $PATH.
Then install fzf with git.</p>

<p>首先运行<code>j demo</code>跳转到项目根目录下，项目文件结构如下：</p>

<pre><code>$ tree
.
├── both
│   ├── collections.coffee
│   └── router.coffee
├── client
│   ├── index.html
│   ├── layout.coffee
│   ├── layout.html
│   ├── registerHelpers.coffee
│   ├── stylesheets
│   │   └── app.scss
│   └── templates
│       ├── addPost
│       │   ├── addPost.coffee
│       │   ├── addPost.html
│       │   └── addPost.scss
│       ├── editPost
│       │   ├── editPost.coffee
│       │   └── editPost.html
│       ├── lists
│       │   ├── lists.coffee
│       │   └── lists.html
│       ├── postView
│       │   ├── postView.coffee
│       │   └── postView.html
│       ├── sharePost
│       │   ├── sharePost.coffee
│       │   └── sharePost.html
│       ├── sideMenu
│       │   └── sideMenu.html
│       └── userAccounts
│           ├── accountsConfig.coffee
│           ├── userAccounts.coffee
│           └── userAccounts.html
├── LICENSE
├── newnote.tmp
├── packages
├── README.md
└── server
    └── seeds.js

13 directories, 26 files
</code></pre>

<h1>配置</h1>

<p>全局定义：~/.fzf.zsh</p>

<p>默认快捷键可以在.fzf/shell/key-bindings.zsh中修改。
推荐将默认的文件搜索快捷键从Ctrl-T改成了Ctrl-J，需要避免使用的配置有：</p>

<ul>
<li><p>Ctrl-I: 代表<tab>键，虽然可以触发目录搜索，但<tab>键的自动补全功能不能用了；</p></li>
<li><p>Ctrl-M: 回车键的键值，如果改成了它，将导致回车键不可用，可以用Ctrl-Enter临时代替回车；</p></li>
<li><p>Ctrl-N: 下一条历史命令的快捷键。</p></li>
</ul>


<h1>使用</h1>

<h2>文件搜索</h2>

<p>要编辑client/templates/lists/lists.coffee文件，只要在命令行中输入<code>vi</code>然后按Ctrl-j，
就进入了fzf搜索界面，只要输入任意层目录中的几个字符，就可以匹配到目标文件，
例如上面lists.coffee文件，只要输入<code>listco</code>就可以匹配到了。
其中当输入到list时，就匹配到了lists文件夹以及下面的两个文件，
这时可以继续输入"co"，直接命中目标，也可以用Ctrl-j/k在列表中上下选择目标。</p>

<p>实际上fzf进行目录文件匹配的快捷键是Ctrl-T，但对vi进行了特殊定义，使得用<tab>也可以出发fzf搜索。</p>

<p>按Alt-C，选择好目录，可以直接切换到目标目录，相当于<code>cd &lt;Ctrl-T&gt;</code>的快捷版。</p>

<p>Ctrl-R在命令行历史使用<strong>模糊</strong>匹配。</p>

<h2>历史命令搜索</h2>

<p>Ctrl-r激活搜索列表，然后模糊匹配；</p>

<p>可以使用多种配置格式，例如前缀、后缀、取反、严格一致等等，
例如搜索单词<code>date</code>（而不是包含<code>d,a,t,e</code>的任何字符串），在Ctrl-R后输入<code>'date</code>,
详见文档对"extended-search mode"的说明。</p>

<h2>进程搜索</h2>

<p>输入<code>kill</code>然后按Tab键显示系统进程列表，开始模糊搜索；</p>
]]></content>
  </entry>
  
</feed>
