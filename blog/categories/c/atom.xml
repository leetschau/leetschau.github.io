<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-10-03T10:36:40+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Build C Development Environment With VirtualBox]]></title>
    <link href="http://leetschau.github.io/blog/2014/08/04/082233/"/>
    <updated>2014-08-04T08:22:33+08:00</updated>
    <id>http://leetschau.github.io/blog/2014/08/04/082233</id>
    <content type="html"><![CDATA[<p>Host: Win7, VM: CentOS 6.5 minimal</p>

<h1>VM setup</h1>

<p>setup network and share folders in Settings of VM.</p>

<h2>Network setup</h2>

<ol>
<li><p>In settings of VM: the first NIC is host-only, second is bridged.</p></li>
<li><p>Start VM, create /etc/sysconfig/network-scripts/ifcfg-eth1 based on ifcfg-eth0, the hardware address is from /etc/udev/rules/70-persistent.network;</p></li>
<li><p>reboot;</p></li>
</ol>


<h1>Install Guest Addons</h1>

<p>In VM:</p>

<pre><code> # yum update
 # yum install gcc
 # yum install kernel-devel
 # mount /dev/scd0 /media/cdrom
 # sh /media/VBOXADDITIONS_4.0.12_72916/VBoxLinuxAdditions.run
</code></pre>

<p>Now you can visit share folders in /media/sf_<share_folder_name>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes About 21st Century C]]></title>
    <link href="http://leetschau.github.io/blog/2012/12/20/204831/"/>
    <updated>2012-12-20T20:48:31+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/12/20/204831</id>
    <content type="html"><![CDATA[<ul>
<li><pre><code>              第10页，"gcc erf.c -o erf -lm -g -Wall -O3 -std=gnu11"指令，Ubuntu 11和Red Hat 5都不识别"-std=gnu11"选项，都能够识别"-std=gnu99"选项，都能够正常运行"c99 erf.c -o erf -lm -g -Wall -O3"指令。
</code></pre></li>
<li><p>Ubuntu能够正常运行第15页的makefile，Red Hat（服务器47）不能正常编译。</p></li>
<li><p>第21页：Using Libraries from Source一节，Red Hat上安装gsl库后pkg-config指令找不到路径，可能是权限问题导致的；Ubuntu上安装gsl库后pkg-config指令能找到安装位置，make指令编译能正常生成可执行文件，但执行时报下面的错误：</p></li>
</ul>


<p>./gsl_erf: error while loading shared libraries: libgsl.so.0: cannot open shared object file: No such file or directory</p>

<ul>
<li>第27页：Compiling form stdin一节介绍的在命令行中运行C代码的方法在Ubuntu上试验成功，首先在$HOME下新建一个allheads.h文件，内容为（与书中P26页内容一样，但不包括最后一行，否则会提示gsl_rng.h文件找不到）：</li>
</ul>


<p> #include &lt;math.h>
 #include &lt;time.h>
 #include &lt;stdio.h>
 #include &lt;unistd.h>
 #include &lt;stdlib.h></p>

<p> #include &lt;assert.h>
 // #include &lt;gsl/gsl_rng.h></p>

<p>然后修改.bashrc文件，在文件末尾增加下面3行内容（书中第28页）：</p>

<p> go_libs=&ldquo;-lm&rdquo;
 go_flags=&ldquo;-g -Wall -include allheads.h -O3&rdquo;
 alias go_c=&ldquo;c99 -xc &lsquo;-&rsquo; $go_libs $go_flags&rdquo;</p>

<p>然后在命令行下输入：</p>

<p> go_c &lt;&lt; &lsquo;&mdash;&rsquo;</p>

<h2> int main(){printf(&ldquo;Hello from the command line.\n&rdquo;);} </h2>

<p>没有报错说明正常编译完成，这时当前件夹下会出现一个a.out文件，用./a.out运行之，可以看到运行结果：</p>

<p> Hello from the command line.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言中使用其他文件中的函数]]></title>
    <link href="http://leetschau.github.io/blog/2012/12/18/095814/"/>
    <updated>2012-12-18T09:58:14+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/12/18/095814</id>
    <content type="html"><![CDATA[<p>例如main.c的main()方法中用myfunc.c中的mysub()函数，首先要在myfunc.c中实现mysub：</p>

<p> int mysub(int a, int b) {</p>

<p>  return a-b;
 }</p>

<p>之后main.c有两种方法引用：</p>

<ul>
<li>声明函数原型</li>
</ul>


<p> #include &lt;stdio.h></p>

<p> #include &lt;stdlib.h>
 int mysub(int a, int b);
 int main() {
  printf(&ldquo;Hello world!\n&rdquo;);
  int c = mysub(3,5);
  printf(&ldquo;result is: %d&rdquo;,c);
  return 0;
 }</p>

<ul>
<li>通过头文件引用</li>
</ul>


<p>将main.c中的"int mysub(int a, int b);&ldquo;拷贝到myfunc.h文件中，然后将main.c中的"int mysub(int a, int b);"改为：#include "myfunc.h"。</p>

<h1>Code::Blocks中生成头文件</h1>

<p>选中要生成头文件的C文件，主菜单 -> Edit -> Swap header/source。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes About Code::Blocks]]></title>
    <link href="http://leetschau.github.io/blog/2012/12/18/093649/"/>
    <updated>2012-12-18T09:36:49+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/12/18/093649</id>
    <content type="html"><![CDATA[<h1>Source Auto Formatting</h1>

<h2>define format style</h2>

<p>Main Menu -> Settings -> Editor -> Source formatter;</p>

<h2>define shortcuts</h2>

<p>Main Menu -> Settings -> Editor -> Keyboard shortcuts. I use &ldquo;F10&rdquo; as its shortcut;</p>

<h2>formatting code</h2>

<p>use the shortcut define in the previous step.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gdb Notes]]></title>
    <link href="http://leetschau.github.io/blog/2012/12/11/131018/"/>
    <updated>2012-12-11T13:10:18+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/12/11/131018</id>
    <content type="html"><![CDATA[<p>Ubuntu 11自带gcc和gdb，下面是使用gdb调试代码的过程：</p>

<ol>
<li><p>首先写一个简单的hw.c程序：</p>

<p> #include &lt;stdio.h>
 int main() {
     char str[] = &ldquo;hello, world&rdquo;;
     printf(&ldquo;%s\n&rdquo;,str);
     return 0;
 }</p></li>
<li><p>编译并运行源代码（gcc指令必须有-g选项，不能加-Wall选项，否则无法调试）：</p>

<p> chad@ubuntu:~/Documents$ gcc -g hw.c -o hw
 chad@ubuntu:~/Documents$ ./hw
 hello, world</p></li>
<li><p>用gdb调试编译出来的文件：</p>

<p> chad@ubuntu:~/Documents$ gdb hw
 GNU gdb (Ubuntu/Linaro 7.3-0ubuntu2) 7.3-2011.08
 &hellip;
 (gdb) b 3
 Breakpoint 1 at 0x8048449: file hw.c, line 3.
 (gdb) r
 Starting program: /home/chad/Documents/hw
 Breakpoint 1, main () at hw.c:3
 3   char str[] = &ldquo;hello, world&rdquo;;
 (gdb) p str
 $1 = &ldquo;\000\364\217*\000U&lt;\026\000\231\204\004\b&rdquo;
 (gdb) s
 4   printf(&ldquo;%s\n&rdquo;,str);
 (gdb) p str
 $2 = &ldquo;hello, world&rdquo;</p>

<p> (gdb) p str[1]=&lsquo;y&rsquo;   $3 = 121 &lsquo;y&rsquo;
 (gdb) p str
 $4 = &ldquo;hyllo, world&rdquo;</p>

<p> (gdb) p $2
 $5 = &ldquo;hello, world&rdquo;</p>

<p> (gdb) c
 Continuing.
 hello, world
 [Inferior 1 (process 3345) exited normally]
 (gdb) q
 chad@ubuntu:~/Documents$</p></li>
</ol>


<p>上述操作过程，代码前面的标号是行号。用户输入的指令，"b 3"表示在第3行打断点，r表示run，p表示print，s表示step（即step in），这里也可以用n（next，即step over），c表示continue，q表示quit。可以看到step指令之前打印str的值是一个随机值（因为还没有赋值），step之后（到第4行）就有了值；</p>

<p>p指令除了可以显示程序变量值，还可以修改变量值，如上面的p str[1]=&lsquo;y'；</p>

<p>gdb每次输出都被保持到了一个格式为$n的变量中，后面可以再引用这个变量，如上面的p $2；</p>

<p>可以用l(list)指令打印出完整的源代码。</p>

<h2>C++</h2>

<pre><code>$ g++ -g srcfile.cc -o rr
$ gdb rr
$ l
</code></pre>

<p>这里"-g"选项是必须的，否则gdb无法得到原文件信息。</p>

<h1>Windows平台</h1>

<p><a href="http://www.codeblocks.org/">Code::Blocks</a>是目前唯一实现了断点调试的Windows平台上C开发环境（它本身是跨平台的），带MinGW安装包100MB，不带MinGW的20MB多，比较符合轻量级的要求；</p>
]]></content>
  </entry>
  
</feed>
