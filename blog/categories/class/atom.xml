<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Class | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/class/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2014-08-27T14:11:47+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Eclipse项目中JDK的版本]]></title>
    <link href="http://leetschau.github.io/blog/2012/06/13/090430/"/>
    <updated>2012-06-13T09:04:30+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/06/13/090430</id>
    <content type="html"><![CDATA[<p>JDK6编译出来的class文件不能运行在JDK5的虚拟机上，因此用Eclipse开发/运行/打包项目时要注意Java编译器的版本，有3个位置（范围从大到小）会影响Java编译器的版本：</p>

<ol>
<li><p>Eclipse级全局JRE：Window->Preferences->Java->Installed JREs;</p></li>
<li><p>项目级JRE：Project->Properties下的：</p></li>
<li><p>Build Path -> Libraries -> JRE System Library;</p></li>
<li><p>Java Compiler -> JDK Compliance;</p></li>
<li><p>Run/Debug Configuration级JRE: 在这个Configuration的&#8221;JRE&#8221;标签页中设置；</p></li>
</ol>


<p>确定class文件版本的方法是查看class文件的第7个字节： 0x31-> JDK5, 0x32 ->JDK6, 0x33 ->JDK7;</p>

<p> class文件格式的详细介绍见 Java class file .</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Groovy文件与类的关系]]></title>
    <link href="http://leetschau.github.io/blog/2011/05/31/172859/"/>
    <updated>2011-05-31T17:28:59+08:00</updated>
    <id>http://leetschau.github.io/blog/2011/05/31/172859</id>
    <content type="html"><![CDATA[<p>Python中，文件是一个模块，可以包含多个类、函数或者普通语句，但Groovy采用了与Java一样的机制，即一个文件对应一个类，</p>

<p>具体的实现机制如下：（主要参考了 Groovy in Action : page:190）</p>

<p>在Groovy中类和文件的对应关系并不像Java中那么固定(Java中一个文件只能有一个声明为public的类和其他一些非公共的类和内嵌类) 。在同一个groovy文件中可以包含多个public的类定义。具体规则如下：</p>

<ol>
<li><p>纯脚本：如果在一个groovy文件中没有任何类定义，它将被当做script来处理，也就意味着这个文件将被透明的转换为一个Script类型的类，这个类的类名是脚本的文件名（不含扩展名和包名，在default包中）。groovy文件的内容被打包进run方法，另外在新产生的类中被加入一个main方法使外部代码可以执行该脚本；</p></li>
<li><p>纯类（类名是文件名）：如果在groovy文件正好有一个类的定义，并且该类的名字与文件名称相同，那么这就和java中的类与文件的一一对应关系相同。在一个groovy文件中可以包含多个不同可见性的类定义，并且没有强制性的要求其中有一个类的类名与文件名相同。groovyc编译器会很乐于把该文件中定义的所有的类都编译成*.class文件。如果你希望能够直接调用这个groovy script，比如说在使用groovy命令行或者在某个IDE中执行，那么你应该在该文件中的第一个类中定义一个main方法；</p></li>
<li><p>脚本/类混合：在一个groovy文件中可以混合类的定义和脚本定义。在这种情况下，那些脚本代码将会放入默认存在的主类（文件名类）的run方法，所以在这种情况下你不应该再定义一个和文件同名的类，否则会出现“类重复定义”错误。反过来说，如果显式地定义了主类，则主类之外，除了定义其他类，不能有任何其他脚本代码（包括语句和函数）；</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
