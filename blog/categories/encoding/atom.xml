<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Encoding | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/encoding/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-06-01T12:52:39+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[修改Linux系统的默认语言编码集]]></title>
    <link href="http://leetschau.github.io/blog/2012/12/20/195630/"/>
    <updated>2012-12-20T19:56:30+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/12/20/195630</id>
    <content type="html"><![CDATA[<h1>RedHat</h1>

<p>今天晚上发现服务器上vi的界面提示变成了乱码，只能将XShell的编码改为GBK才能正常显示，导致consolas字体无法使用，GBK编码下的字体丑陋无比，无法忍受，一轮google之后终于发现有人改了/etc/sysconfig/i18n文件，解决方法就是把GB18030改回到UTF-8：</p>

<p>root用户下修改/etc/sysconfig/i18n文件，将LANG=zh_CN.GB18030改为LANG=&ldquo;zh_CN.UTF-8"，新用户登录后就界面就是UTF-8编码了，如果改成en_US.UTF-8，vi的提示语言就变成英文了。</p>

<h1>Ubuntu</h1>

<ol>
<li><p>修改配置文件：/etc/default/locale内容改为：</p>

<p> LANG=&ldquo;en_US.UTF-8&rdquo;</p></li>
<li><p>update-locale</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unicode到UTF-8编码转换的Java实现]]></title>
    <link href="http://leetschau.github.io/blog/2012/12/17/151751/"/>
    <updated>2012-12-17T15:17:51+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/12/17/151751</id>
    <content type="html"><![CDATA[<p>Unicode到UTF-8转换的规则见笔记 字符编解码的故事 ，下面将转换过程代码化，以演示如何手工对byte数据进行操作，以及需要注意的问题（字节位的高低定义是：high<-->low）。</p>

<p> package encoding;
 import java.io.UnsupportedEncodingException;
 import org.junit.Test;
 public class Converter {
  public static void main(String[] args) throws UnsupportedEncodingException {
   char chnChar = &lsquo;联&rsquo;;
   System.out.println(&ldquo;UTF-8 bytes of &rdquo; + chnChar + &ldquo;: &rdquo; + convUnicode2utf8(chnChar));
  }
  /<em>*
   * 演示unicode到utf-8的转换过程。
   * @param 要进行转换的汉字
   * @throws UnsupportedEncodingException
   * @return 16进制表示的汉字UTF-8编码字节序列
   </em>/
  public static String convUnicode2utf8(char input) throws UnsupportedEncodingException {
   int lowByte = input &amp; 0xff;
   int highByte = (input &amp; 0xff00) >>> 8;    // 第二次运行时注释掉本行
   // byte highByte = (byte) ((input &amp; 0xff00) >>> 8); // 第二次运行时取消注释本行
   System.out.println(&ldquo;Unicode bytes of &rdquo; + input + &ldquo;: &rdquo; + Integer.toHexString(highByte)
     + &ldquo;, &rdquo; + Integer.toHexString(lowByte));
   // UTF-8的第1个字节是1110 + highByte前4位
   int high4inHighByte = highByte >>> 4;
   System.out.println(&ldquo;highByte>>>4: hex:&rdquo; + Integer.toHexString(high4inHighByte)
     + &ldquo;, demical:&rdquo; + high4inHighByte);
   int utf8Byte1 = (7 &lt;&lt; 5) + high4inHighByte;
   // UTF-8的第2个字节是10 + highByte后4位 + lowByte前2位
   int low4inHighByte = highByte &amp; 0xf;
   int high2inLowByte = lowByte >>> 6;
   int utf8Byte2 = (1 &lt;&lt; 7) + (low4inHighByte &lt;&lt; 2) + high2inLowByte;
   // UTF-8的第3个字节是10 + lowByte后6位
   int utf8Byte3 = (1 &lt;&lt; 7) + (lowByte &amp; 0x3f);
   String result = Integer.toHexString(utf8Byte1) + &ldquo;, &rdquo; + Integer.toHexString(utf8Byte2)
     + &ldquo;, &rdquo; + Integer.toHexString(utf8Byte3);
   return result;
  }
   public static String bytes2HexString(byte[] b) {
   String ret = &ldquo;&rdquo;;
   for (int i = 0; i &lt; b.length; i++) {
    String hex = Integer.toHexString(b[i] &amp; 0xFF);
    if (hex.length() == 1) {
     hex = &lsquo;0&rsquo; + hex;
    }
    ret += hex;
   }
   return ret;
  }
  }</p>

<p>第1次运行结果：</p>

<p> Unicode bytes of 联: 80, 54
 highByte>>>4: hex:8, demical:8
 UTF-8 bytes of 联: e8, 81, 94</p>

<p>第2次运行结果：</p>

<p> Unicode bytes of 联: ffffff80, 54
 highByte>>>4: hex:ffffff8, demical:268435448
 UTF-8 bytes of 联: 100000d8, 81, 94</p>

<h1>结果分析</h1>

<p>当highByte为byte型时（第二次运行），"Integer.toHexString(highByte)&ldquo;的运行结果是ffffff80，这是由于toHexString(int i)方法会先将i转换为int型，Java中没有无符号数的概念，0x80作为byte型数据的值是-128，转换成int型的-128就是ffffff80。后面的highByte>>>4也一样，移位操作符（>>和>>>）要求左右的操作数是int或者long，highByte首先被转换为int值0xffffff80，然后无符号右移4位，变为0x0ffffff8，即268435448，最后导致utf8Byte1得到错误的值。可见错误的根本原因在于移位运算符对byte型数据按有符号数进行了“私下”转换。</p>

<h1>解决方法</h1>

<p>当要对数据进行字节位操作时，要特别注意数据是有符号还是无符号的，如果是无符号的（例如汉字编码），并且要进行移位操作（主要是向右移位，向左移位不受是否有符号位影响），应将被处理的byte保存在int型变量中。</p>

<p>参考<a href="http://stackoverflow.com/questions/3948220/behaviour-of-unsigned-right-shift-applied-to-byte-variable%EF%BC%8C%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%AF%B4%E6%98%8E%E5%8F%82%E8%80%83">http://stackoverflow.com/questions/3948220/behaviour-of-unsigned-right-shift-applied-to-byte-variable%EF%BC%8C%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%AF%B4%E6%98%8E%E5%8F%82%E8%80%83</a>"Java in a Nutsehll"一书中"Bitwise and Shift Operators"一节。</p>

<h1>网络传输中的汉字和特殊字符</h1>

<p>Java程序用字节数组接收网络传输数据时，字节的值只要超过0x7f，直接打印出来就是负数，这是Java对byte类型的定义（-128~127）造成的，不是错误，需要打印日志或者屏显时用上面代码中的bytes2HexString()打印hex码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于ISO8859-1编码]]></title>
    <link href="http://leetschau.github.io/blog/2012/12/17/123944/"/>
    <updated>2012-12-17T12:39:44+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/12/17/123944</id>
    <content type="html"><![CDATA[<p>ISO-8859是ASCII编码的扩展规范，能够覆盖大部分欧洲语言。<a href="https://en.wikipedia.org/wiki/ISO_8859-1">ISO/IEC 8859-1</a>是ISO8859的一个最流行的实现方案，是Java的"default default"编码规则，及Java使用系统默认的编码方案失败时使用的编码方案（<a href="http://stackoverflow.com/questions/12659417/why-does-javas-string-getbytes-uses-iso-8859-1%EF%BC%89%E3%80%82">http://stackoverflow.com/questions/12659417/why-does-javas-string-getbytes-uses-iso-8859-1%EF%BC%89%E3%80%82</a></p>

<p>在进行String - byte[]转换时可以像UTF-8, unicode, gbk一样用ISO8859-1引用它，例如：</p>

<p> String result = new String(byteArray, &ldquo;ISO8859-1&rdquo;);</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java的字符编码集]]></title>
    <link href="http://leetschau.github.io/blog/2012/12/14/114124/"/>
    <updated>2012-12-14T11:41:24+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/12/14/114124</id>
    <content type="html"><![CDATA[<h1>实验步骤</h1>

<ol>
<li>CharSetTest.java文件（内容如下）在Windows下编译为class文件：</li>
</ol>


<p> import java.nio.charset.Charset;
 import java.io.OutputStreamWriter;
 import java.io.ByteArrayOutputStream;
 public class CharSetTest {
  public static void main(String[] args) {
   System.out.println(&ldquo;Default Charset=&rdquo; + Charset.defaultCharset());
   System.setProperty(&ldquo;file.encoding&rdquo;, &ldquo;Latin-1&rdquo;);
   System.out.println(&ldquo;file.encoding=&rdquo; + System.getProperty(&ldquo;file.encoding&rdquo;));
   System.out.println(&ldquo;Default Charset=&rdquo; + Charset.defaultCharset());
   System.out.println(&ldquo;Default Charset in Use=&rdquo; + getDefaultCharSet());</p>

<p>   System.out.println(&ldquo;Default 字符集（在使用中的）=&rdquo; + getDefaultCharSet());
  }
  private static String getDefaultCharSet() {
   OutputStreamWriter writer = new OutputStreamWriter(new ByteArrayOutputStream());
   String enc = writer.getEncoding();
   return enc;
  }
 }</p>

<ol>
<li>ftp到Red Hat Linux上运行：</li>
</ol>


<p>/opt/jdk1.6.0_35/bin/java CharSetTest</p>

<p>Default Charset=UTF-8
file.encoding=Latin-1
Default Charset=UTF-8
Default Charset in Use=UTF8
Default 字符集（在使用中的）=UTF8</p>

<p>/opt/jdk1.6.0_35/bin/java -Dfile.encoding=GBK CharSetTest</p>

<p>Default Charset=GBK
file.encoding=Latin-1
Default Charset=GBK
Default Charset in Use=GBK
Default ؖ·՚ʹԃאµģ©=GBK</p>

<p>（将XShell的显示编码改为GBK后可以正常显示汉字）</p>

<p>/opt/jdk1.6.0_35/bin/java -Dfile.encoding=UTF-8 CharSetTest
Default Charset=UTF-8
file.encoding=Latin-1
Default Charset=UTF-8
Default Charset in Use=UTF8
Default 字符集（在使用中的）=UTF8</p>

<ol>
<li>本地Windows上运行</li>
</ol>


<p>D:\Apps\Java\jdk1.6.0_35\jre\bin\java.exe CharSetTest
Default Charset=GBK
file.encoding=Latin-1
Default Charset=GBK
Default Charset in Use=GBK
Default 字符集（在使用中的）=GBK</p>

<p>D:\Apps\Java\jdk1.6.0_35\jre\bin\java.exe -Dfile.encoding=GBK CharSetTest</p>

<p>Default Charset=GBK
file.encoding=Latin-1
Default Charset=GBK
Default Charset in Use=GBK
Default 字符集（在使用中的）=GBK</p>

<p>D:\Apps\Java\jdk1.6.0_35\jre\bin\java.exe -Dfile.encoding=UTF-8 CharSetTest
Default Charset=UTF-8
file.encoding=Latin-1
Default Charset=UTF-8
Default Charset in Use=UTF8
Default 瀛楃闆嗭紙鍦ㄤ娇鐢ㄤ腑鐨勶級=UTF8</p>

<h1>结果分析</h1>

<p>Java文件使用GBK编码，但class文件中汉字是用UTF-8编码的，47上的测试表明不论-Dfile.encoding的值是什么，只要把与XShell的显示编码保持一致就可以正确显示。</p>

<p>参考文献：</p>

<p> <a href="http://stackoverflow.com/questions/1749064/how-to-find-default-charset-encoding-in-java">http://stackoverflow.com/questions/1749064/how-to-find-default-charset-encoding-in-java</a></p>

<p> <a href="http://stackoverflow.com/questions/2677419/determining-default-character-set-of-platform-in-java">http://stackoverflow.com/questions/2677419/determining-default-character-set-of-platform-in-java</a></p>

<p> <a href="http://stackoverflow.com/questions/5306153/how-to-get-terminals-character-encoding">http://stackoverflow.com/questions/5306153/how-to-get-terminals-character-encoding</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apache Commons-io的字符串编解码问题]]></title>
    <link href="http://leetschau.github.io/blog/2012/05/28/100022/"/>
    <updated>2012-05-28T10:00:22+08:00</updated>
    <id>http://leetschau.github.io/blog/2012/05/28/100022</id>
    <content type="html"><![CDATA[<p>用Apache org.apache.commons.io.input.Tailer监控日志文件变化很方便，但如果文件中有中文，回调函数TailerListener.handle中参数line是乱码，原因是目前的Tailer是按“西欧语言”（ISO8859-1）对日志文件进行解码的，而日志文件一般是用GBK或者UTF-8编码。解决方法是对line用ISO8859-1再进行一次编码得到原始的字节数组，然后用日志文件的格式进行解码，这样最终得到的字符串就OK了。实现方法如下：</p>

<p>服务类：</p>

<p> &hellip;</p>

<p> LogMonitorListener lml = new LogMonitorListener();</p>

<p> Tailer lmt = new Tailer(logfile, lml, 3000);</p>

<p> &hellip;</p>

<p> lmt.run();</p>

<p>监听器类：</p>

<p>public class LogMonitorListener extends TailerListenerAdapter {</p>

<p> &hellip;</p>

<p> @Override</p>

<p> public void handle(String line) {</p>

<p>  msg = new String(line.getBytes(&ldquo;ISO8859-1&rdquo;), &ldquo;GBK&rdquo;) ; //用来处理GBK格式的日志</p>

<p>   msg = new String(line.getBytes(&ldquo;ISO8859-1&rdquo;), &ldquo;UTF-8&rdquo;) ; //用来处理UTF-8格式的日志</p>

<p>  &hellip;</p>
]]></content>
  </entry>
  
</feed>
