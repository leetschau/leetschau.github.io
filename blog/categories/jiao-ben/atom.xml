<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 脚本 | Dark Matter in Cyberspace]]></title>
  <link href="http://leetschau.github.io/blog/categories/jiao-ben/atom.xml" rel="self"/>
  <link href="http://leetschau.github.io/"/>
  <updated>2015-01-04T11:42:13+08:00</updated>
  <id>http://leetschau.github.io/</id>
  <author>
    <name><![CDATA[Li Chao]]></name>
    <email><![CDATA[leetschau@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[计算总值的Ultraedit脚本]]></title>
    <link href="http://leetschau.github.io/blog/2010/10/18/141748/"/>
    <updated>2010-10-18T14:17:48+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/10/18/141748</id>
    <content type="html"><![CDATA[<p>// 使用方法：首先在一个空文本文件总写上需要做和的数字，每个数一行，选中所有数字，然后运行本脚本
var lineTerminator = &ldquo;\r\n&rdquo;;
var str = UltraEdit.activeDocument.selection;
var resultArr = new Array();
resultArr = str.split(lineTerminator);
var itemCnt = resultArr.length;
var total = 0;
for (var i = 0; i &lt; itemCnt; i++) {
 total = total+parseFloat(resultArr[i]);
}
UltraEdit.activeDocument.bottom();
UltraEdit.activeDocument.write(&ldquo;\r\n======================\r\n&rdquo;);
UltraEdit.activeDocument.write(&ldquo;Total value is: &rdquo; + total + &ldquo; Yuan.\r\n&rdquo;);
UltraEdit.activeDocument.write(&ldquo;Totally &rdquo;+itemCnt+&ldquo; items in the list.&rdquo;);
//UltraEdit.outputWindow.write(&ldquo;Total value is: &rdquo; + total + &ldquo; Yuan.&rdquo;);
//UltraEdit.outputWindow.write(&ldquo;Totally &rdquo;+itemCnt+&ldquo; items in the list.&rdquo;);</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[日志核查工具脚本业务逻辑]]></title>
    <link href="http://leetschau.github.io/blog/2010/09/20/103757/"/>
    <updated>2010-09-20T10:37:57+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/09/20/103757</id>
    <content type="html"><![CDATA[<p>用户确定线程号qth和时间范围[qst, qet]；</p>

<p>读入文本文件；</p>

<p>将有效行标志位vline设为false；</p>

<p>读入第一行数据，判断是否为日志输出；</p>

<p>若是：提取线程号thread_no和时间cur_time，将vline设为true；</p>

<p>否则：</p>

<p>若vline=true，输出该行</p>

<p>否则忽略该行；</p>

<p>若线程号不是qth 忽略该行；</p>

<p> 若cur_time&lt;qst忽略该行；</p>

<p> 输出本行数据，循环读入下一行文本；</p>

<p> 用grep -n定位起始位置，awk先判断时间范围，再判断线程号，当时间超出上限时，直接退出（close），不必读后续行（next）。</p>

<p>echo &ldquo;Please input thread number:&rdquo;
read qth
echo &ldquo;Please input start time:&rdquo;
read qst
echo &ldquo;Please input end time:&rdquo;
read qet</p>

<h1>echo $qth</h1>

<p>awk &lsquo;BEGIN{
   isLogLine=0;
   qth=&rsquo;&ldquo;$qth&rdquo;&lsquo;;
   qst=&rsquo;&ldquo;$qst&rdquo;&lsquo;;
   qet=&rsquo;&ldquo;$qet&rdquo;&lsquo;;
 }
 {
  if(substr($3,2,7)==&ldquo;thread_&rdquo;){ #检查是否为日志输出列</p>

<p>   thread_no=substr($3,9,length($3)-9);
   if(thread_no==qth){
    print &ldquo;the thread is in line:&rdquo;
    print NR
   }
  }
 }&lsquo; logex</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解析java源文件]]></title>
    <link href="http://leetschau.github.io/blog/2010/08/30/160444/"/>
    <updated>2010-08-30T16:04:44+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/08/30/160444</id>
    <content type="html"><![CDATA[<p>尝试从java源文件中解析出类、方法、属性等信息，但下面的代码没有完全实现。</p>

<p>Sub parseJava()
  Dim package_name as String
  &lsquo;read a file
  Documents.Open FileName:=&ldquo;f:\CommandCm.java&rdquo;, ConfirmConversions:=False, ReadOnly:=True
  paraNo = ActiveDocument.Paragraphs.Count
  For lineNo = 1 To paraNo
   Set curParaWords = ActiveDocument.Paragraphs(lineNo).Range.Words
   Dim strCurPara as String
   strCurPara = ActiveDocument.Paragraphs(lineNo).Range.Text
   If InStr(strCurPara, &ldquo;package&rdquo;)=1 Then
    &#8216;包名是package后、分号前的部分
    tmpStr = Right(strCurPara,Len(strCurPara)-Len(&ldquo;package&rdquo;)-1)
    package_name = Left(tmpStr, Len(tmpStr)-2)
   End If
   If InStr(strCurPara, &ldquo;public class&rdquo;)=1 Then
    &#8216;类名是这一行的第三个单词，且不含末尾空格
    class_name = RTrim(curParaWords(3).Text)
   End If
   If InStr(strCurPara, &ldquo;public interface&rdquo;)=1 Then
    &#8216;接口名是这一行的第三个单词，且不含末尾空格
    class_name = RTrim(curParaWords(3).Text)
   End If
   Select Case curParaWords(2).Text
   Case &ldquo;public&rdquo;</p>

<p>   Case &ldquo;private&rdquo;
   Case &ldquo;protected&rdquo;
   Case Else
   End Case
   If curParaWords(2)=&ldquo;public&rdquo; Then
    &lsquo;接口名是这一行的第三个单词，且不含末尾空格
    class_name = RTrim(ActiveDocument.Paragraphs(lineNo).Range.Words(3).Text)
   End If
  Next lineNo
  ActiveDocument.Close
End Sub</p>

<p> 下面是业务逻辑：</p>

<p>数据结构：</p>

<p> 类相关数据表ClassInfo（Map）</p>

<p> key: name, description, class_name, package, extends, interface;</p>

<p>属性数据表PropInfo（List<Map>）</p>

<p>方法数据表MethodInfo（List<Map>）</p>

<p>文本格式约定：</p>

<p>顶格、package起首代码行为package声明行；</p>

<p>顶格、public class起首的代码行是类声明行；</p>

<p> 顶格、 public  interface起首的代码行是接口声明行；</p>

<p> 一个tab后跟public、private、protected是方法或者属性</p>

<p> 有左括号的是方法， 左括号前单词是方法名，方法名前是返回值的数据类型；</p>

<p> 无左括号 的是 属性，等号左边单词是属性名，若无等号分号前单词是属性名，若都没有输出一条 “文件名：行号：异常属性/方法，手工提取” 提示；</p>

<p> 一个tab后跟其他字母 输出一条“文件名：行号：异常属性/方法，手工提取”提示；</p>

<p> 一个tab后跟非字母符号（如/*是注释，@是编译标志）略过；</p>

<p>流程：</p>

<p> 用户输入目标目录</p>

<p> 将文件名保存在ClassInfo.name和class_name中；</p>

<p> 加载该目录下所有java文件， 对于一个java文件：</p>

<p>第一次文本逐行读取：提取除方法/属性说明外所有信息；</p>

<p>第二次文本逐行读取：寻找以“* 方法名”开始的行，作为方法说明，放入对应的方法Map中；</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运行VIM脚本的方法]]></title>
    <link href="http://leetschau.github.io/blog/2010/07/10/142701/"/>
    <updated>2010-07-10T14:27:01+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/07/10/142701</id>
    <content type="html"><![CDATA[<p>1 将VIM脚本写在一个文本文件中，扩展名任意，一般就用txt，例如保存在f盘根目录下：f:\ex.txt；
2 在VIM中用:so（:source的简写）命令运行之：:so f:\ex.txt。
 脚本文件中的注释以英文的双引号（&#8221;）起始。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一行为文件名保存的文件的实现方法（VIM版）]]></title>
    <link href="http://leetschau.github.io/blog/2010/06/27/135846/"/>
    <updated>2010-06-27T13:58:46+08:00</updated>
    <id>http://leetschau.github.io/blog/2010/06/27/135846</id>
    <content type="html"><![CDATA[<p>问题描述
 例如文档1的内容是：
this is doc A
the following is contents
&hellip;
要保存为“this is doc A.txt”；
文档2的内容是：
that is B
some words more
&hellip;
要保存为“that is B.txt”。
文档的数量很多，无法对每一文档手工保存，希望有一款文本编辑器能用脚本（或者宏之类的）实现该功能。
 解决方案
 在_vimrc文件中加上如下内容：
 function Blog_Save()
 &ldquo; 删除空行，包括全是空格的行
 g/^\s*$/d
 &rdquo; 将文件第一行内容保存在变量line中
 let line = getline(1)
 &ldquo; 去掉其中的非法字符，如\等
 let line = substitute(line, &lsquo;[:/\]&rsquo;, &lsquo;-&rsquo;, &lsquo;g&rsquo;)
 let line = substitute(line, &lsquo;^\s+&rsquo;, &lsquo;&rsquo;, &lsquo;g&rsquo;)
 let line = substitute(line, &lsquo;\s+$&rsquo;, &lsquo;&rsquo;, &lsquo;g&rsquo;)
 let line = substitute(line, &lsquo; &rsquo;, &lsquo;\ &rsquo;, &lsquo;g&rsquo;)
 let line = substitute(line, &lsquo;\r&rsquo;, &lsquo;&rsquo;, &lsquo;g&rsquo;)
 &rdquo; 执行保存文件命令，其中点号是连接符，类似于PHP中的用法
 exe &lsquo;sav &rsquo;.line.&lsquo;.txt&rsquo;
endfunction
&ldquo; 定义一个【用户自定义命令】
command BlogSav call Blog_Save()
&rdquo; 键映射
:map <F5> <ESC>:BlogSav<CR>
 这段代码整体分为3部分：第一部分定义了一个函数，第二部分为这个函数定义了一个【用户自定义命令】，以便于在VIM的普通模式下用:+command的方法使用，第3部分是一个键映射，将按<ESC>、输入:BlogSav、按回车键这一系列动作映射到F5键上，这样只要按一下F5键，就实现了【问题描述】一节中设想的功能。</p>
]]></content>
  </entry>
  
</feed>
